--- a/crypto/gcm.c	2018-11-23 10:16:14.066931491 +0300
+++ a/crypto/gcm.c	2018-11-23 10:31:03.762053131 +0300
@@ -68,6 +68,10 @@
 	u8 iv[16];
 	u8 auth_tag[16];
 	u8 iauth_tag[16];
+#ifdef CONFIG_MACH_PENTAGRAM_SC7021_ACHIP
+	/* avoid auth_tag & src @ same cacheline */
+	u8 dummy[L1_CACHE_BYTES - 48];
+#endif
 	struct scatterlist src[3];
 	struct scatterlist dst[3];
 	struct scatterlist sg;
@@ -129,7 +133,12 @@
 	crypto_skcipher_clear_flags(ctr, CRYPTO_TFM_REQ_MASK);
 	crypto_skcipher_set_flags(ctr, crypto_aead_get_flags(aead) &
 				       CRYPTO_TFM_REQ_MASK);
+#ifdef CONFIG_CRYPTO_DEV_SP // TODO: dirty hack code, fix me
+	err = crypto_skcipher_setkey(ctr, key,
+		keylen | !strcmp(ctr->base.__crt_alg->cra_driver_name, "sp-aes-ctr"));
+#else
 	err = crypto_skcipher_setkey(ctr, key, keylen);
+#endif
 	crypto_aead_set_flags(aead, crypto_skcipher_get_flags(ctr) &
 				    CRYPTO_TFM_RES_MASK);
 	if (err)
@@ -162,7 +171,12 @@
 	crypto_ahash_clear_flags(ghash, CRYPTO_TFM_REQ_MASK);
 	crypto_ahash_set_flags(ghash, crypto_aead_get_flags(aead) &
 			       CRYPTO_TFM_REQ_MASK);
+#ifdef CONFIG_CRYPTO_DEV_SP // TODO: dirty hack code, fix me
+	err = crypto_ahash_setkey(ghash, (u8 *)&data->hash,
+		sizeof(be128) | !strcmp(ghash->base.__crt_alg->cra_driver_name, "sp-ghash"));
+#else
 	err = crypto_ahash_setkey(ghash, (u8 *)&data->hash, sizeof(be128));
+#endif
 	crypto_aead_set_flags(aead, crypto_ahash_get_flags(ghash) &
 			      CRYPTO_TFM_RES_MASK);
 
--- a/drivers/crypto/Kconfig	2018-11-23 10:16:14.195923828 +0300
+++ a/drivers/crypto/Kconfig	2018-11-23 10:31:03.767052834 +0300
@@ -9,6 +9,27 @@
 	  If you say N, all options in this submenu will be skipped and disabled.
 
 if CRYPTO_HW
+config CRYPTO_DEV_SP
+	tristate "Support for Sunplus Crypto Engine"
+	select CRYPTO_BLKCIPHER
+	select MPILIB
+	help
+	  Say 'Y' to support Sunplus AES/SHA3/HASH/RSA acceletor.
+
+	  If unsure say M. The compiled module will be
+	  called spcrypto.
+
+config CRYPTO_DEV_SP_TEST
+	bool "Sunplus Crypto Engine test code"
+	depends on CRYPTO_DEV_SP
+	help
+	  echo <test_id> > /sys/module/spcrypto/parameters/test
+	  test_id
+		0		all testcase (1-3)
+		1		rsa_test_case_montw
+		2		rsa_test_case_hw
+		3		rsa_test_case_random
+		x[N]	rsa multi-threads(N) burnin test
 
 config CRYPTO_DEV_PADLOCK
 	tristate "Support for VIA PadLock ACE"
--- a/drivers/crypto/Makefile	2018-11-23 10:16:14.195923828 +0300
+++ a/drivers/crypto/Makefile	2018-11-23 10:31:03.766052893 +0300
@@ -39,3 +39,4 @@
 obj-$(CONFIG_CRYPTO_DEV_VIRTIO) += virtio/
 obj-$(CONFIG_CRYPTO_DEV_VMX) += vmx/
 obj-$(CONFIG_CRYPTO_DEV_BCM_SPU) += bcm/
+obj-$(CONFIG_CRYPTO_DEV_SP)= sp/
--- a/drivers/crypto/sp/Makefile	1970-01-01 03:00:00.000000000 +0300
+++ a/drivers/crypto/sp/Makefile	2018-11-12 06:42:52.000000000 +0300
@@ -0,0 +1,18 @@
+
+ifneq ($(KERNELRELEASE),)
+	obj-$(CONFIG_CRYPTO_DEV_SP) = sp_crypto.o
+	sp_crypto-objs := sp-crypto.o \
+		sp-aes.o \
+		sp-hash.o \
+		sp-rsa.o 
+else
+    KERNELDIR ?= ../../../
+    PWD       := $(shell pwd)
+ 
+modules:
+	$(MAKE) -C $(KERNELDIR) ARCH=arm make CROSS_COMPILE=arm-xilinx-linux-gnueabi- M=$(PWD)  modules
+
+clean:
+	rm -rf *.o *~ core .depend .*.cmd *.ko *.mod.c .tmp_versions
+endif
+
--- a/drivers/crypto/sp/sp-aes.c	1970-01-01 03:00:00.000000000 +0300
+++ a/drivers/crypto/sp/sp-aes.c	2018-11-12 06:42:52.000000000 +0300
@@ -0,0 +1,492 @@
+/**
+ * Cryptographic API.
+ * Support for OMAP AES HW acceleration.
+ * Author:jz.xiang
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as published
+ * by the Free Software Foundation.
+ */
+
+#include <crypto/internal/aead.h>
+#include <crypto/aes.h>
+#include <crypto/algapi.h>
+#include <crypto/scatterwalk.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/crypto.h>
+#include <linux/delay.h>
+#include <crypto/aes.h>
+#include "sp-crypto.h"
+
+#define WORKBUF_SIZE (AES_BLOCK_SIZE + AES_BLOCK_SIZE + AES_MAX_KEYLENGTH)	// tmp + iv + key
+
+/* structs */
+struct sp_aes_ctx {
+	crypto_ctx_t base;
+
+	u8 *tmp, *iv;
+	dma_addr_t pa; // workbuf phy addr
+	u32 ivlen, keylen;
+};
+
+static int sp_cra_aes_init(struct crypto_tfm *tfm, u32 mode)
+{
+	struct sp_aes_ctx *ctx = crypto_tfm_ctx(tfm);
+
+	SP_CRYPTO_TRACE();
+
+	ctx->base.mode = mode;
+	ctx->ivlen = AES_BLOCK_SIZE;
+
+	ctx->tmp = dma_alloc_coherent(NULL, WORKBUF_SIZE, &ctx->pa, GFP_KERNEL);
+	ctx->iv = ctx->tmp + AES_BLOCK_SIZE;
+
+	return crypto_ctx_init(&ctx->base, SP_CRYPTO_AES);
+}
+
+static int sp_cra_aes_ecb_init(struct crypto_tfm *tfm)
+{
+	return sp_cra_aes_init(tfm, M_AES_ECB);
+}
+
+static int sp_cra_aes_cbc_init(struct crypto_tfm *tfm)
+{
+	return sp_cra_aes_init(tfm, M_AES_CBC);
+}
+
+static int sp_cra_aes_ctr_init(struct crypto_tfm *tfm)
+{
+	return sp_cra_aes_init(tfm, M_AES_CTR | (128 << 24)); // CTR M = 128
+}
+
+static void sp_cra_aes_exit(struct crypto_tfm *tfm)
+{
+	struct sp_aes_ctx *ctx = crypto_tfm_ctx(tfm);
+
+	dma_free_coherent(NULL, WORKBUF_SIZE, ctx->tmp, ctx->pa);
+	crypto_ctx_exit(crypto_tfm_ctx(tfm));
+}
+
+/*
+  * counter = counter  + 1
+  *  counter:small endian
+  */
+static void ctr_inc1(u8 *counter, u32 len)
+ {
+     u32 n = 0;
+     u8 c;
+
+     do {
+         c = counter[n];
+         ++c;
+         counter[n] = c;
+         if (c)
+             return;
+         ++n;
+     } while (n < len);
+ }
+
+
+/*
+  * counter = counter  + inc
+  *  counter:small endian
+  */
+static void ctr_inc(u8 *counter, u32 len, u32 inc)
+{
+	u32 c, c1;
+	u32 *p = (u32 *)counter;
+
+	c =  __le32_to_cpu(*p);
+	c1 = c;
+	c += inc;
+	*p = __cpu_to_le32(c);
+
+	if ((c >= inc) && (c >= c1)) {
+		return;
+	}
+
+	ctr_inc1(counter + sizeof(u32), len - sizeof(u32));
+}
+
+static void reverse_iv(u8 *dst, u8* src)
+{
+	int i = AES_BLOCK_SIZE;
+	while (i--) {
+		dst[i] = *(src++);
+	}
+}
+
+static void dump_sglist(struct scatterlist *sglist, int count)
+{
+#if 0
+	int i;
+	struct scatterlist *sg;
+
+	printk("sglist: %p\n", sglist);
+	for_each_sg(sglist, sg, count, i) {
+		printk("\t%08x (%08x)\n", sg_dma_address(sg), sg_dma_len(sg));
+	}
+#endif
+}
+
+static int sp_blk_aes_set_key(struct crypto_tfm *tfm,
+	const u8 *in_key, unsigned int key_len)
+{
+	struct sp_aes_ctx *ctx = crypto_tfm_ctx(tfm);
+
+	SP_CRYPTO_TRACE();
+#if 1 // TODO: dirty hack code, fix me
+	if (key_len & 1) {
+		key_len &= ~1;
+		ctx->base.mode = M_AES_CTR | (32 << 24); // GCTR M = 32;
+	}
+#endif
+	if (key_len != AES_KEYSIZE_128 && key_len != AES_KEYSIZE_192 && key_len != AES_KEYSIZE_256) {
+		SP_CRYPTO_ERR("unsupported AES key length: %d\n", key_len);
+		return -EINVAL;
+	}
+
+	ctx->keylen = key_len;
+	ctx->base.mode |= (key_len / 4) << 16; // AESPAR0_NK
+	memcpy(ctx->iv + ctx->ivlen, in_key, key_len); // key: iv + ivlen
+
+	return 0;
+}
+
+static int sp_blk_aes_crypt(struct blkcipher_desc *desc,
+	struct scatterlist *dst, struct scatterlist *src, u32 nbytes, u32 enc)
+{
+#define NO_WALK		0
+#define SRC_WALK	1
+#define DST_WALK	2
+#define BOTH_WALK	3
+
+	u32 flag = BOTH_WALK;
+	int ret = 0;
+	int src_cnt, dst_cnt;
+	dma_addr_t src_phy, dst_phy;
+	bool ioc;
+	u32 processed = 0, process = 0;
+	struct scatterlist *sp;
+	struct scatterlist *dp;
+	struct sp_aes_ctx *ctx = crypto_blkcipher_ctx(desc->tfm);
+	crypto_ctx_t *ctx0 = &ctx->base;
+	trb_ring_t *ring = AES_RING(ctx0->dd);
+	dma_addr_t iv_phy, key_phy, tmp_phy = 0;
+	u32 mode = ctx0->mode & M_MMASK;
+	u32 mm = ctx0->mode | enc; // AESPAR0 (trb.para.mode)
+
+	//printk(">>>>> %08x <<<<<\n", mm);
+	//dump_stack();
+	if (mode == M_AES_CTR) { // CTR mode: reverse iv byte-order for HW
+		reverse_iv(ctx->iv, desc->info);
+	} else {
+		memcpy(ctx->iv, desc->info, ctx->ivlen);
+		if (mode == M_AES_CBC && enc == M_DEC) {
+			scatterwalk_map_and_copy(desc->info, src,
+				nbytes - ctx->ivlen, ctx->ivlen, 0);
+		}
+	}
+
+	iv_phy = ctx->pa + AES_BLOCK_SIZE;
+	key_phy = iv_phy + ctx->ivlen;
+	sp = src;
+	dp = dst;
+
+	src_cnt = sg_nents(src);
+	dst_cnt = sg_nents(dst);
+
+	//dump_sglist(src, src_cnt);
+	if(unlikely(dma_map_sg(NULL, src, src_cnt, DMA_TO_DEVICE) <= 0)) {
+		SP_CRYPTO_ERR("sp aes map src sg  fail\n");
+		return -EINVAL;
+	}
+	dump_sglist(src, src_cnt);
+
+	//dump_sglist(dst, dst_cnt);
+	if(unlikely(dma_map_sg(NULL, dst, dst_cnt, DMA_FROM_DEVICE) <= 0)) {
+		SP_CRYPTO_ERR("sp aes map dst sg  fail\n");
+		dma_unmap_sg(NULL, src,  src_cnt, DMA_TO_DEVICE);
+		return -EINVAL;
+	}
+	dump_sglist(dst, dst_cnt);
+
+	if (mutex_lock_interruptible(&ring->lock)) {
+		dma_unmap_sg(NULL, src, src_cnt, DMA_TO_DEVICE);
+		dma_unmap_sg(NULL, dst, dst_cnt, DMA_FROM_DEVICE);
+		return -EINTR;
+	}
+	//mutex_lock(&ring->lock);
+
+	while (processed < nbytes) {
+		u32 reast;
+		trb_t *trb;
+		if (BOTH_WALK == flag) {
+			src_phy = sg_dma_address(sp);
+			dst_phy = sg_dma_address(dp);
+			if (sg_dma_len(sp) > sg_dma_len(dp)) {
+				process = sg_dma_len(dp);
+				dp = sg_next(dp);
+				flag = DST_WALK;
+				SP_CRYPTO_TRACE();
+			} else if(sg_dma_len(sp) == sg_dma_len(dp)) {
+				process = sg_dma_len(sp);
+				sp = sg_next(sp);
+				dp = sg_next(dp);
+				flag = BOTH_WALK;
+				SP_CRYPTO_TRACE();
+			} else {
+				process = sg_dma_len(sp);
+				sp = sg_next(sp);
+				flag = SRC_WALK;
+				SP_CRYPTO_TRACE();
+			}
+		} else if (DST_WALK == flag) {
+			src_phy += process;
+			dst_phy = sg_dma_address(dp);
+			reast = sg_dma_len(sp) - (src_phy - sg_dma_address(sp));
+			if(reast > sg_dma_len(dp)) {
+				process = sg_dma_len(dp);
+				dp = sg_next(dp);
+				flag = DST_WALK;
+			} else if(reast == sg_dma_len(dp)) {
+				process = sg_dma_len(dp);
+				dp = sg_next(dp);
+				sp = sg_next(sp);
+				flag = BOTH_WALK;
+			} else {
+				process = reast;
+				sp = sg_next(sp);
+				flag = SRC_WALK;
+			}
+		} else if (SRC_WALK == flag) {
+			src_phy = sg_dma_address(sp);
+			dst_phy += process;
+			reast = sg_dma_len(dp) - (dst_phy - sg_dma_address(dp));
+			if(reast > sg_dma_len(sp)) {
+				process = sg_dma_len(sp);
+				sp = sg_next(sp);
+				flag = SRC_WALK;
+			} else if(reast == sg_dma_len(sp)) {
+				process = sg_dma_len(sp);
+				dp = sg_next(dp);
+				sp = sg_next(sp);
+				flag = BOTH_WALK;
+			} else {
+				process = reast;
+				dp = sg_next(dp);
+				flag = DST_WALK;
+			}
+		} else {
+			src_phy += process;
+			dst_phy += process;
+		}
+
+		process = min_t(u32, process, nbytes - processed);
+		if (process < AES_BLOCK_SIZE) {
+			tmp_phy = ctx->pa;
+		} else if (process % AES_BLOCK_SIZE) {
+			process &= ~(AES_BLOCK_SIZE - 1);
+			flag = NO_WALK;
+		}
+
+		processed += process;
+		ioc = (processed == nbytes) || (ring->trb_sem.count == 1);
+
+		SP_CRYPTO_TRACE();
+		if (tmp_phy)
+			trb = crypto_ctx_queue(ctx0, src_phy, tmp_phy, iv_phy, key_phy, AES_BLOCK_SIZE, mm, ioc);
+		else
+			trb = crypto_ctx_queue(ctx0, src_phy, dst_phy, iv_phy, key_phy, process, mm, ioc);
+		if (!trb) {
+			ret = -EINTR;
+			goto out;
+		}
+		iv_phy = 0; // after iv inital value, using HW auto-iv
+
+		if (ioc) {
+			SP_CRYPTO_TRACE();
+			ret = crypto_ctx_exec(ctx0);
+			if (ret) {
+				//if (ret == -ERESTARTSYS) ret = 0;
+				goto out;
+			}
+		}
+	};
+	SP_CRYPTO_TRACE();
+#if 1
+	BUG_ON(processed != nbytes);
+#else
+	if (processed != nbytes) {
+		SP_CRYPTO_ERR("proccessed %d bytes != need process %d bytes\n", processed, nbytes);
+		ret = -EINVAL;
+	}
+#endif
+
+out:
+	mutex_unlock(&ring->lock);
+	dma_unmap_sg(NULL, src, src_cnt, DMA_TO_DEVICE);
+ 	dma_unmap_sg(NULL, dst, dst_cnt, DMA_FROM_DEVICE);
+
+	if (tmp_phy) {
+		//dump_buf(ctx->tmp, AES_BLOCK_SIZE);
+		scatterwalk_map_and_copy(ctx->tmp, dst, nbytes - process, process, 1);
+	}
+
+	// update iv for return
+	if (mode == M_AES_CBC && enc == M_ENC) {
+		scatterwalk_map_and_copy(desc->info, dst,
+			nbytes - ctx->ivlen, ctx->ivlen, 0);
+	} else if (mode == M_AES_CTR) {
+		ctr_inc(ctx->iv, ctx->ivlen, nbytes / AES_BLOCK_SIZE);
+		reverse_iv(desc->info, ctx->iv);
+	}
+
+	return ret;
+}
+
+static int sp_blk_aes_encrypt(struct blkcipher_desc *desc,
+	struct scatterlist *dst, struct scatterlist *src, unsigned int nbytes)
+{
+	return sp_blk_aes_crypt(desc, dst, src, nbytes, M_ENC);
+}
+
+static int sp_blk_aes_decrypt(struct blkcipher_desc *desc,
+	struct scatterlist *dst, struct scatterlist *src, unsigned int nbytes)
+{
+	return sp_blk_aes_crypt(desc, dst, src, nbytes, M_DEC);
+}
+
+/* tell the block cipher walk routines that this is a stream cipher by
+ * setting cra_blocksize to 1. Even using blkcipher_walk_virt_block
+ * during encrypt/decrypt doesn't solve this problem, because it calls
+ * blkcipher_walk_done under the covers, which doesn't use walk->blocksize,
+ * but instead uses this tfm->blocksize. */
+struct crypto_alg sp_aes_alg[] = {
+
+	{
+		.cra_name		 = "ecb(aes)",
+		.cra_driver_name = "sp-aes-ecb",
+		.cra_priority	 = 300,
+		.cra_flags		 = CRYPTO_ALG_TYPE_BLKCIPHER,
+		.cra_blocksize	 = AES_BLOCK_SIZE,
+		.cra_alignmask	 = 0xf,
+		.cra_ctxsize	 = sizeof(struct sp_aes_ctx),
+		.cra_type		 = &crypto_blkcipher_type,
+		.cra_module 	 = THIS_MODULE,
+		.cra_init		 = sp_cra_aes_ecb_init,
+		.cra_exit		 = sp_cra_aes_exit,
+		.cra_blkcipher = {
+			.min_keysize = AES_MIN_KEY_SIZE,
+			.max_keysize = AES_MAX_KEY_SIZE,
+			.ivsize 	 = AES_BLOCK_SIZE,
+			.setkey 	 = sp_blk_aes_set_key,
+			.encrypt	 = sp_blk_aes_encrypt,
+			.decrypt	 = sp_blk_aes_decrypt,
+		}
+	},
+	{
+		.cra_name		 = "cbc(aes)",
+		.cra_driver_name = "sp-aes-cbc",
+		.cra_priority	 = 300,
+		.cra_flags		 = CRYPTO_ALG_TYPE_BLKCIPHER,
+		.cra_blocksize	 = AES_BLOCK_SIZE,
+		.cra_alignmask	 = 0xf,
+		.cra_ctxsize	 = sizeof(struct sp_aes_ctx),
+		.cra_type		 = &crypto_blkcipher_type,
+		.cra_module 	 = THIS_MODULE,
+		.cra_init		 = sp_cra_aes_cbc_init,
+		.cra_exit		 = sp_cra_aes_exit,
+		.cra_blkcipher = {
+			.min_keysize = AES_MIN_KEY_SIZE,
+			.max_keysize = AES_MAX_KEY_SIZE,
+			.ivsize 	 = AES_BLOCK_SIZE,
+			.setkey 	 = sp_blk_aes_set_key,
+			.encrypt	 = sp_blk_aes_encrypt,
+			.decrypt	 = sp_blk_aes_decrypt,
+		}
+	},
+	{
+		.cra_name		 = "ctr(aes)",
+		.cra_driver_name = "sp-aes-ctr",
+		.cra_priority	 = 300,
+		.cra_flags		 = CRYPTO_ALG_TYPE_BLKCIPHER,
+		.cra_blocksize	 = 1, // TODO: AES_BLOCK_SIZE ???
+		.cra_alignmask	 = 0xf,
+		.cra_ctxsize	 = sizeof(struct sp_aes_ctx),
+		.cra_type		 = &crypto_blkcipher_type,
+		.cra_module 	 = THIS_MODULE,
+		.cra_init		 = sp_cra_aes_ctr_init,
+		.cra_exit		 = sp_cra_aes_exit,
+		.cra_blkcipher = {
+			.min_keysize = AES_MIN_KEY_SIZE,
+			.max_keysize = AES_MAX_KEY_SIZE,
+			.ivsize 	 = AES_BLOCK_SIZE,
+			.setkey 	 = sp_blk_aes_set_key,
+			.encrypt	 = sp_blk_aes_encrypt,
+			.decrypt	 = sp_blk_aes_decrypt,
+		}
+
+	},
+};
+
+int sp_aes_finit(void)
+{
+	SP_CRYPTO_TRACE();
+	return crypto_unregister_algs(sp_aes_alg, ARRAY_SIZE(sp_aes_alg));
+}
+EXPORT_SYMBOL(sp_aes_finit);
+
+int sp_aes_init(void)
+{
+	SP_CRYPTO_TRACE();
+	return  crypto_register_algs(sp_aes_alg, ARRAY_SIZE(sp_aes_alg));
+}
+EXPORT_SYMBOL(sp_aes_init);
+
+void sp_aes_irq(void *devid, u32 flag)
+{
+	struct sp_crypto_dev *dev = devid;
+	trb_ring_t *ring = AES_RING(dev);
+
+#ifdef TRACE_WAIT_ORDER
+	SP_CRYPTO_INF(">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> %s:%08x %08x %08x %d\n", __FUNCTION__,
+		flag, dev->reg->AES_ER, dev->reg->AESDMA_CRCR, ring->trb_sem.count/*kfifo_len(&ring->f)*/);
+#else
+	SP_CRYPTO_INF(">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> %s:%08x %08x %08x\n", __FUNCTION__, flag, dev->reg->AES_ER, dev->reg->AESDMA_CRCR);
+#endif
+	if (flag & AES_TRB_IF) { // autodma/trb done
+		trb_t *trb = ring->head;
+		ring->irq_count++;
+		if (!trb->cc) dump_trb(trb);
+		while (trb->cc) {
+			//dump_trb(trb);
+			if (trb->ioc) {
+				crypto_ctx_t *ctx = trb->priv;
+				if (ctx->type == SP_CRYPTO_AES) {
+#ifdef TRACE_WAIT_ORDER
+					wait_queue_head_t *w;
+					BUG_ON(!kfifo_get(&ring->f, &w));
+					BUG_ON(w != &ctx->wait);
+#endif
+					ctx->done = true;
+					wake_up(&ctx->wait);
+				}
+				else {
+					printk("\nAES_SKIP: %08x\n", ctx->type);
+					dump_trb(trb);
+				}
+			}
+			trb = trb_put(ring);
+		}
+	}
+#ifdef USE_ERF
+	if (flag & AES_ERF_IF) { // event ring full
+		SP_CRYPTO_ERR("\n!!! %08x %08x\n", dev->reg->AESDMA_ERBAR, dev->reg->AESDMA_ERDPR);
+		dev->reg->AESDMA_RCSR |= AUTODMA_RCSR_ERF; // clear event ring full
+	}
+#endif
+	SP_CRYPTO_INF("\n");
+}
+EXPORT_SYMBOL(sp_aes_irq);
+
--- a/drivers/crypto/sp/sp-aes.h	1970-01-01 03:00:00.000000000 +0300
+++ a/drivers/crypto/sp/sp-aes.h	2018-11-12 06:42:52.000000000 +0300
@@ -0,0 +1,8 @@
+#ifndef __SP_AES_H__
+#define __SP_AES_H__
+
+int sp_aes_finit(void);
+int sp_aes_init(void);
+void sp_aes_irq(void *devid, u32 flag);
+
+#endif /*  */
--- a/drivers/crypto/sp/sp-crypto.c	1970-01-01 03:00:00.000000000 +0300
+++ a/drivers/crypto/sp/sp-crypto.c	2018-11-12 06:42:52.000000000 +0300
@@ -0,0 +1,666 @@
+/*
+ * 1.sunplus crypto alg driver
+ * author:jz.xiang
+ */
+
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/crypto.h>
+#include <linux/interrupt.h>
+#include <linux/of_platform.h>
+#include <linux/io.h>
+#include <mach/io_map.h>
+
+#include "sp-crypto.h"
+#include "sp-aes.h"
+#include "sp-hash.h"
+#include "sp-rsa.h"
+
+#ifdef CONFIG_CRYPTO_DEV_SP_TEST
+#include "sp-crypto-test.c"
+#endif
+
+#if 0
+#define IO_BASE0                (0x9c000000)
+#define CRYPTO_IRQ_NUM    		(148)
+#define CRYPTO_REG_BASE   		(IO_BASE0 + 84*32*4)
+//#define CRYPTO_IRQ_NUM    		(91)
+//#define CRYPTO_REG_BASE   		(0x40000000)
+#endif
+
+static struct sp_crypto_dev sp_dd_tb[1];
+
+void dump_buf(u8 *buf, u32 len)
+{
+	static char s[] = "       |       \n";
+	char ss[52] = "";
+	u32 i = 0, j;
+	printk("buf:%p, len:%d\n", buf, len);
+	while (i < len) {
+		j = i & 0x0F;
+		sprintf(ss + j * 3, "%02x%c", buf[i], s[j]);
+		i++;
+		if ((i & 0x0F) == 0) {
+			printk(ss);
+			ss[0] = 0;
+		}
+	}
+	if (i & 0x0F) {
+		//strcat(ss, "\n");
+		printk(ss);
+	}
+}
+EXPORT_SYMBOL(dump_buf);
+
+#define OUT(fmt, args...) \
+do {	\
+	p += sprintf(p, fmt, ##args); \
+} while (0);
+
+static char *print_trb(char *p, trb_t * trb)
+{
+	OUT("trb ========== %p\n", trb);
+	OUT(" c:0x%x\n", trb->c);
+	OUT("cc:0x%x\n", trb->cc);
+	OUT("tc:0x%x\n", trb->tc);
+	OUT("ioc:0x%x\n", trb->ioc);
+	OUT("type:0x%x\n", trb->type);
+	OUT("size:0x%x\n", trb->size);
+	OUT("sptr:0x%0x\n", trb->sptr);
+	OUT("dptr:0x%0x\n", trb->dptr);
+	OUT("mode:0x%x\n", trb->mode);
+	OUT("iptr:0x%x\n", trb->iptr);
+	OUT("kptr:0x%x\n", trb->kptr);
+	OUT("priv:%p\n", trb->priv);
+
+	return p;
+}
+
+static char *print_hw(char *p, trb_t *trb)
+{
+	volatile struct sp_crypto_reg *reg = sp_dd_tb->reg;
+	trb_ring_t *ring;
+	int i, j;
+
+	// AES
+	ring = AES_RING(sp_dd_tb);
+	OUT("AES_CR   : %08x\n", reg->AES_CR);
+	OUT("AES_ER   : %08x\n", reg->AES_ER);
+	OUT("AES_CRCR : %08x\n", reg->AESDMA_CRCR);
+	OUT("sem.count: %d\n", ring->trb_sem.count);
+	OUT("head     : %p\n", ring->head);
+	OUT("tail     : %p\n", ring->tail);
+	OUT("triggers : %d\n", ring->trigger_count);
+	OUT("irqs     : %d\n", ring->irq_count);
+#ifdef TRACE_WAIT_ORDER
+	OUT("wait.len : %d\n", kfifo_len(&ring->f));
+#endif
+	//if (trb || (reg->AESDMA_CRCR & AUTODMA_CRCR_CRR)) // dump_trb || running
+	{
+		//i = (trb ? trb : (trb_t *)__va(reg->AES_CR)) - ring->trb;
+		i = ring->head - ring->trb;
+		for (j = -2; j < 3; j++) {
+			p = print_trb(p, ring->trb + ((i + j + 127) % 127));
+		}
+	}
+
+	OUT("\n");
+	// HASH
+	ring = HASH_RING(sp_dd_tb);
+	OUT("HASH_CR  : %08x\n", reg->HASH_CR);
+	OUT("HASH_ER  : %08x\n", reg->HASH_ER);
+	OUT("HAHS_CRCR: %08x\n", reg->HASHDMA_CRCR);
+	OUT("sem.count: %d\n", ring->trb_sem.count);
+	OUT("head     : %p\n", ring->head);
+	OUT("tail     : %p\n", ring->tail);
+	OUT("triggers : %d\n", ring->trigger_count);
+	OUT("irqs     : %d\n", ring->irq_count);
+#ifdef TRACE_WAIT_ORDER
+	OUT("wait.len : %d\n", kfifo_len(&ring->f));
+#endif
+	//if (trb || (reg->HASHDMA_CRCR & AUTODMA_CRCR_CRR)) // dump_trb || running
+	{
+		//i = (trb ? trb : (trb_t *)__va(reg->HASH_CR)) - ring->trb;
+		i = ring->head - ring->trb;
+		for (j = -2; j < 3; j++) {
+			p = print_trb(p, ring->trb + ((i + j + 127) % 127));
+		}
+	}
+
+	return p;
+}
+
+void dump_trb(trb_t *trb)
+{
+	char s[300];
+	print_trb(s, trb);
+	printk(s);
+}
+
+/* hwcfg: enable/disable aes/hash hw
+echo <aes:-1~2> [hash:-1~2] [print] > /sys/module/spcrypto/parameters/hwcfg
+-1: no change
+ 0: disable
+ 1: enable
+ 2: toggle
+*/
+static int hwcfg_set(const char *val, const struct kernel_param *kp)
+{
+	static int f_aes = 1, f_hash = 1; // initial status: aes & hash enabled
+	int en_aes = -1, en_hash = -1, pr = 1;
+	int ret;
+
+	sscanf(val, "%d %d %d", &en_aes, &en_hash, &pr);
+
+	if (en_aes >= 0) {
+		if (en_aes > 1) en_aes = 1 - f_aes; // toggle
+		ret = en_aes ? sp_aes_init() : sp_aes_finit();
+		f_aes = en_aes;
+		if (pr) printk("sp_aes %s: %d\n", en_aes ? "enable": "disable", ret);
+	}
+	if (en_hash >= 0) {
+		if (en_hash > 1) en_hash = 1 - f_hash; // toggle
+		ret = en_hash ? sp_hash_init() : sp_hash_finit();
+		f_hash = en_hash;
+		if (pr) printk("sp_hash %s: %d\n", en_hash ? "enable": "disable", ret);
+	}
+
+	return 0;
+}
+
+static int hwcfg_get(char *buffer, const struct kernel_param *kp)
+{
+	return print_hw(buffer, NULL) - buffer;
+}
+
+static const struct kernel_param_ops hwcfg_ops = {
+	.set = hwcfg_set,
+	.get = hwcfg_get,
+};
+module_param_cb(hwcfg, &hwcfg_ops, NULL, 0600);
+
+int crypto_ctx_init(crypto_ctx_t *ctx, crypto_type_t type)
+{
+ 	init_waitqueue_head(&ctx->wait);
+	ctx->dd = sp_crypto_alloc_dev(SP_CRYPTO_AES);
+	//sema_init(&ctx->sem, 1);
+	ctx->type = type;
+
+	return 0;
+}
+
+void crypto_ctx_exit(crypto_ctx_t *ctx)
+{
+ 	sp_crypto_free_dev(ctx->dd, SP_CRYPTO_AES);
+}
+
+int crypto_ctx_exec(crypto_ctx_t *ctx)
+{
+	trb_ring_t *ring = TRB_RING(ctx);
+	volatile struct sp_crypto_reg *reg = ctx->dd->reg;
+
+	ring->tail->c = 0; // clear tail_trb.c for HW stop
+	ctx->done = false;
+	smp_wmb();
+	ring->trigger_count++;
+	if (ctx->type == SP_CRYPTO_HASH) {
+		SP_CRYPTO_INF("HASH_CR  : %08x\n", reg->HASH_CR);
+		SP_CRYPTO_INF("HASH_ER  : %08x\n", reg->HASH_ER);
+		SP_CRYPTO_INF("HASH_CRCR: %08x\n", reg->HASHDMA_CRCR);
+		if (!(reg->HASHDMA_CRCR & AUTODMA_CRCR_CRR)) {	// autodma not running
+			reg->HASHDMA_RTR |= AUTODMA_TRIGGER;		// trigger autodma run
+		}
+#if 1
+		//if (!(ctx->mode & M_FINAL))
+		{ // busy-waiting, can't sleep in hash //update
+			while (!ctx->done); // TODO: handle timeout
+			return 0;
+		}
+#endif
+	} else {
+		SP_CRYPTO_INF("AES_CR  : %08x\n", reg->AES_CR);
+		SP_CRYPTO_INF("AES_ER  : %08x\n", reg->AES_ER);
+		SP_CRYPTO_INF("AES_CRCR: %08x\n", reg->AESDMA_CRCR);
+		if (!(reg->AESDMA_CRCR & AUTODMA_CRCR_CRR)) {
+			reg->AESDMA_RTR |= AUTODMA_TRIGGER;
+		}
+	}
+
+#if 1
+	{
+		int ret = wait_event_interruptible_timeout(ctx->wait, ctx->done, 60*HZ);
+		if (!ret) ret = -ETIMEDOUT;
+		if (ret < 0) {
+			return ret;
+		}
+	}
+	return 0;
+#else // if wakeup crashed in aes/hash irq, try use this
+	return wait_event_timeout(ctx->wait, ctx->done, 60*HZ) ? 0 : -ETIMEDOUT;
+#endif
+}
+
+trb_t *crypto_ctx_queue(crypto_ctx_t *ctx,
+	dma_addr_t src, dma_addr_t dst,
+	dma_addr_t iv, dma_addr_t key,
+	u32 len, u32 mode, bool ioc)
+{
+	trb_ring_t *ring = TRB_RING(ctx);
+	trb_t *trb = trb_get(ring);
+
+	if (trb) {
+#ifdef TRACE_WAIT_ORDER
+		if (ioc) kfifo_put(&ring->f, &ctx->wait);
+#endif
+		trb->priv = ctx;
+		trb->ioc  = ioc;
+		trb->size = len;
+		trb->sptr = src;
+		trb->dptr = dst;
+		trb->mode = mode;
+		trb->iptr = iv;
+		trb->kptr = key;
+		smp_wmb();
+		trb->c    = ~0;	// this field must write at last
+		//dump_trb(trb);
+	}
+
+	return trb;
+}
+
+inline trb_t *trb_next(trb_t *trb)
+{
+	trb++;
+	return (trb->type == TRB_LINK) ? (trb_t *)(trb->dptr) : trb;
+}
+
+inline trb_t *trb_get(trb_ring_t *ring)
+{
+	trb_t *trb = NULL;
+	if (!down_interruptible(&ring->trb_sem)) {
+		trb = ring->tail;
+		ring->tail = trb_next(ring->tail);
+		BUG_ON(!trb);
+	}
+	return trb;
+}
+
+/* USE_IN_IRQ, move ring head to next */
+inline trb_t *trb_put(trb_ring_t *ring)
+{
+	up(&ring->trb_sem);
+	ring->head->cc = 0;
+	ring->head = trb_next(ring->head);
+	return ring->head;
+}
+
+/* USE_IN_IRQ, reset ring head & tail to base addr */
+inline void trb_ring_reset(trb_ring_t *ring)
+{
+	ring->head = ring->tail = ring->trb;
+}
+
+static trb_ring_t *trb_ring_new(u32 size)
+{
+	trb_ring_t *ring;
+
+	ring = kzalloc(sizeof(trb_ring_t), GFP_KERNEL);
+	if (unlikely(IS_ERR(ring))) {
+		return ring;
+	}
+
+	ring->trb = dma_alloc_coherent(NULL, PAGE_SIZE, &ring->pa, GFP_KERNEL);
+	if (unlikely(IS_ERR(ring->trb))) {
+		kfree(ring);
+		return ERR_CAST(ring->trb);
+	}
+
+	ring->head = ring->tail = ring->trb;
+	sema_init(&ring->trb_sem, size - 2); // not include link trb & tail trb
+	mutex_init(&ring->lock);
+#ifdef TRACE_WAIT_ORDER
+	INIT_KFIFO(ring->f);
+#endif
+
+	size--;
+	ring->link = ring->trb + size;
+	ring->link->type = TRB_LINK;
+	ring->link->sptr = ring->pa;				// PA
+	ring->link->dptr = (dma_addr_t)ring->trb;	// VA
+	while (size--) {
+		ring->trb[size].type = TRB_NORMAL;
+	}
+
+	return ring;
+}
+
+static void trb_ring_free(trb_ring_t *ring)
+{
+	dma_free_coherent(NULL, PAGE_SIZE, ring->trb, ring->pa);
+	kfree(ring);
+}
+
+irqreturn_t sp_crypto_irq(int irq, void *dev_id)
+{
+	struct sp_crypto_dev *dev = dev_id;
+	u32 secif = dev->reg->SECIF;
+	u32 flag;
+
+	dev->reg->SECIF = secif; // clear int
+	//printk(KERN_ERR "<%04x>", secif);
+
+	/* aes hash rsa may come at one irq */
+	flag = secif & (AES_TRB_IF | AES_ERF_IF | AES_DMA_IF | AES_CMD_RD_IF);
+	if (flag)
+		sp_aes_irq(dev_id, flag);
+
+	flag = secif & (HASH_TRB_IF | HASH_ERF_IF | HASH_DMA_IF | HASH_CMD_RD_IF);
+	if (flag)
+		sp_hash_irq(dev_id, flag);
+
+	flag = secif & RSA_DMA_IF;
+	if (flag)
+		sp_rsa_irq(dev_id, flag);
+
+	return IRQ_HANDLED;
+}
+
+/* alloc hw dev */
+struct sp_crypto_dev *sp_crypto_alloc_dev(int type)
+{
+#if 0
+	int i;
+	struct sp_crypto_dev  *dev = sp_dd_tb;
+	for (i = 0; i < sizeof(sp_dd_tb)/sizeof(sp_dd_tb[0]); i++)
+	{
+		switch(type) {
+			case SP_CRYPTO_RSA:
+				if(atomic_read(&dev->rsa_ref_cnt) >
+					atomic_read(&sp_dd_tb[i].rsa_ref_cnt))
+					dev = &sp_dd_tb[i];
+
+				break;
+			case SP_CRYPTO_AES:
+				if(atomic_read(&dev->aes_ref_cnt) >
+					atomic_read(&sp_dd_tb[i].aes_ref_cnt))
+					dev = &sp_dd_tb[i];
+				break;
+			case SP_CRYPTO_HASH:
+				if(atomic_read(&dev->hash_ref_cnt) >
+					atomic_read(&sp_dd_tb[i].hash_ref_cnt))
+					dev = &sp_dd_tb[i];
+				break;
+		}
+	}
+
+	switch(type) {
+		case SP_CRYPTO_RSA:
+			atomic_inc(&dev->rsa_ref_cnt);
+			break;
+		case SP_CRYPTO_AES:
+			atomic_inc(&dev->aes_ref_cnt);
+			break;
+		case SP_CRYPTO_HASH:
+			atomic_inc(&dev->hash_ref_cnt);
+			break;
+	}
+	//spcrypto_dump_dev(dev);
+	return dev;
+#else
+	return sp_dd_tb;
+#endif
+}
+
+/* free hw dev */
+void sp_crypto_free_dev(struct sp_crypto_dev *dev, u32 type)
+{
+#if 0
+	switch(type) {
+		case SP_CRYPTO_RSA:
+			if (atomic_read(&dev->rsa_ref_cnt) == 0) {
+				SP_CRYPTO_ERR("rsa_ref_cnt underflow\n");
+				return ;
+			}
+			atomic_dec(&dev->rsa_ref_cnt);
+			return ;
+		case SP_CRYPTO_AES:
+			if (atomic_read(&dev->aes_ref_cnt) == 0) {
+				SP_CRYPTO_ERR("aes_ref_cnt underflow\n");
+				return ;
+			}
+			atomic_dec(&dev->aes_ref_cnt);
+			return ;
+		case SP_CRYPTO_HASH:
+			if (atomic_read(&dev->hash_ref_cnt) == 0) {
+				SP_CRYPTO_ERR("hash_ref_cnt underflow\n");
+				return ;
+			}
+			atomic_dec(&dev->hash_ref_cnt);
+			return ;
+	}
+#endif
+}
+
+static int sp_crypto_probe(struct platform_device *pdev)
+{
+	struct resource *res_irq;
+	volatile struct sp_crypto_reg *reg;
+	trb_ring_t *ring;
+	u32 phy_addr;
+	struct sp_crypto_dev *dev = sp_dd_tb;//platform_get_drvdata(pdev);
+	int ret = 0;
+
+	SP_CRYPTO_TRACE();
+
+#ifdef VA_B_REG
+	dev->reg = (void *)(VA_B_REG + 84 * 32 * 4);
+#else
+	{
+		struct resource *res_mem;
+		void __iomem *membase;
+
+		res_mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+		if (!res_mem)
+			return -ENODEV;
+
+		membase = devm_ioremap_resource(&pdev->dev, res_mem);
+		if (IS_ERR(membase))
+			return PTR_ERR(membase);
+
+		dev->reg = membase;
+	}
+#endif
+
+	res_irq = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
+	if (!res_irq)
+		return -ENODEV;
+
+	dev->irq = res_irq->start;
+
+	platform_set_drvdata(pdev, dev);
+	reg = dev->reg;
+	SP_CRYPTO_INF("SP_CRYPTO_ENGINE @ %p =================\n", reg);
+
+	/////////////////////////////////////////////////////////////////////////////////
+
+	dev->version = reg->VERSION;
+	SP_CRYPTO_INF("devid %d version %0x\n", dev->devid, dev->version);
+
+#if 0
+	atomic_set(&dev->rsa_ref_cnt, 0);
+	atomic_set(&dev->aes_ref_cnt, 0);
+	atomic_set(&dev->hash_ref_cnt, 0);
+	dev->state = SEC_DEV_INAVTIVE;
+#endif
+
+	SP_CRYPTO_TRACE();
+	HASH_RING(dev) = ring = trb_ring_new(HASH_CMD_RING_SIZE);
+	ERR_OUT(ring, out0, "new hash_cmd_ring");
+
+	phy_addr = ring->pa;
+	reg->HASHDMA_CRCR  = phy_addr | AUTODMA_CRCR_FLAGS;
+	reg->HASHDMA_ERBAR = phy_addr;
+#ifdef USE_ERF
+	reg->HASHDMA_ERDPR = phy_addr + (HASH_EVENT_RING_SIZE - 1) * TRB_SIZE;
+#else
+	reg->HASHDMA_ERDPR = phy_addr + HASH_EVENT_RING_SIZE * TRB_SIZE;
+#endif
+	reg->HASHDMA_RCSR  = (HASH_EVENT_RING_SIZE - 1);
+	reg->HASHDMA_RCSR |= AUTODMA_RCSR_ERF;
+	reg->HASHDMA_RCSR |= AUTODMA_RCSR_EN; // TODO: HW issue, autodma enable must be alone
+	SP_CRYPTO_INF("HASH_RING === VA:%p PA:%08x\n", ring->trb, phy_addr);
+	SP_CRYPTO_INF("HASH_RCSR: %08x\n", reg->HASHDMA_RCSR);
+	SP_CRYPTO_INF("HASH_RING: %08x %d\n", phy_addr, ring->trb_sem.count);
+	SP_CRYPTO_INF("HASH_CR  : %08x\n", reg->HASH_CR);
+	SP_CRYPTO_INF("HASH_ER  : %08x\n", reg->HASH_ER);
+
+	SP_CRYPTO_TRACE();
+	AES_RING(dev) = ring = trb_ring_new(AES_CMD_RING_SIZE);
+	ERR_OUT(ring, out1, "new hash_cmd_ring");
+
+	phy_addr = ring->pa;
+	reg->AESDMA_CRCR  = phy_addr | AUTODMA_CRCR_FLAGS;
+	reg->AESDMA_ERBAR = phy_addr;
+#ifdef USE_ERF
+	reg->AESDMA_ERDPR = phy_addr + (AES_EVENT_RING_SIZE - 1) * TRB_SIZE;
+#else
+	reg->AESDMA_ERDPR = phy_addr + AES_EVENT_RING_SIZE * TRB_SIZE;
+#endif
+	reg->AESDMA_RCSR  = (AES_EVENT_RING_SIZE - 1);
+	reg->AESDMA_RCSR |= AUTODMA_RCSR_ERF;
+	reg->AESDMA_RCSR |= AUTODMA_RCSR_EN; // TODO: same as above
+	SP_CRYPTO_INF("AES_RING  === VA:%p PA:%08x\n", ring->trb, phy_addr);
+	SP_CRYPTO_INF("AES_RCSR : %08x\n", reg->AESDMA_RCSR);
+	SP_CRYPTO_INF("AES_RING : %08x %d\n", phy_addr, ring->trb_sem.count);
+	SP_CRYPTO_INF("AES_CR   : %08x\n", reg->AES_CR);
+	SP_CRYPTO_INF("AES_ER   : %08x\n", reg->AES_ER);
+
+	ret = request_irq(dev->irq, sp_crypto_irq, IRQF_TRIGGER_HIGH, "sp_crypto", dev);
+	ERR_OUT(ret, out2, "request_irq(%d)", dev->irq);
+
+	SP_CRYPTO_TRACE();
+#ifdef USE_ERF
+	reg->SECIE = RSA_DMA_IE | AES_TRB_IE | HASH_TRB_IE | AES_ERF_IE | HASH_ERF_IE;
+#else
+	reg->SECIE = RSA_DMA_IE | AES_TRB_IE | HASH_TRB_IE;
+#endif
+	SP_CRYPTO_INF("SECIE: %08x\n", reg->SECIE);
+	//BUG_ON(1);
+
+	return 0;
+
+out2:
+	trb_ring_free(AES_RING(dev));
+out1:
+	trb_ring_free(HASH_RING(dev));
+out0:
+	return ret;
+}
+
+static int sp_crypto_remove(struct platform_device *pdev)
+{
+	struct sp_crypto_dev *dev = platform_get_drvdata(pdev);
+	volatile struct sp_crypto_reg *reg = dev->reg;
+
+	SP_CRYPTO_TRACE();
+
+	/* hw stop */
+	reg->HASHDMA_RCSR |= AUTODMA_RCSR_ERF;	// clear event ring full
+	reg->HASHDMA_CRCR |= AUTODMA_CRCR_CS;	// stop running
+	reg->HASHDMA_RCSR &= ~AUTODMA_RCSR_EN;	// disable autodma
+	reg->AESDMA_RCSR  |= AUTODMA_RCSR_ERF;
+	reg->AESDMA_CRCR  |= AUTODMA_CRCR_CS;
+	reg->AESDMA_RCSR  &= ~AUTODMA_RCSR_EN;
+
+	/*  free resource*/
+	free_irq(dev->irq, dev);
+	trb_ring_free(AES_RING(dev));
+	trb_ring_free(HASH_RING(dev));
+#ifndef VA_B_REG
+	devm_iounmap(&pdev->dev, (void *)dev->reg);
+#endif
+
+	return 0;
+}
+
+static const struct of_device_id sp_crypto_of_match[] = {
+	{ .compatible = "sunplus,sp-crypto" },
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, sp_crypto_of_match);
+
+static struct platform_driver sp_crtpto_driver = {
+	.probe		= sp_crypto_probe,
+	.remove		= sp_crypto_remove,
+	.driver		= {
+		.name	= "sp_crypto",
+		.owner	= THIS_MODULE,
+		.of_match_table = of_match_ptr(sp_crypto_of_match),
+	},
+};
+
+static int __init sp_crypto_module_init(void)
+{
+	int ret = 0;
+
+	SP_CRYPTO_TRACE();
+
+	ret = sp_hash_init();
+	ERR_OUT(ret, out0, "sp_hash_init");
+	ret = sp_aes_init();
+	ERR_OUT(ret, out1, "sp_aes_init");
+
+	platform_driver_register(&sp_crtpto_driver);
+#if 0
+	for (i = 0; i < ARRAY_SIZE(sp_dd_tb); ++i) {
+		struct platform_device *pdev = platform_device_alloc("sp_crypto", i);
+		sp_dd_tb[i].device = &pdev->dev;
+		sp_dd_tb[i].reg = ioremap((u32)sp_dd_tb[i].reg, sizeof(struct sp_crypto_reg));
+		platform_set_drvdata(pdev, &sp_dd_tb[i]);
+		platform_device_add(pdev);
+
+		SP_CRYPTO_INF("SP_CRYPTO_ENGINE_%d =================\n", i);
+		SP_CRYPTO_INF("reg     : %p\n", sp_dd_tb[i].reg);
+		SP_CRYPTO_INF("version : %x\n", sp_dd_tb[i].reg->VERSION);
+		SP_CRYPTO_INF("regsize : %d\n", sizeof(struct sp_crypto_reg));
+	}
+
+	// must after reg ioremap, it's used in sp_rsa_init()
+#endif
+	SP_CRYPTO_TRACE();
+	ret = sp_rsa_init();
+	ERR_OUT(ret, out2, "sp_rsa_init");
+
+	return 0;
+
+out2:
+	sp_aes_finit();
+out1:
+	sp_hash_finit();
+out0:
+	return ret;
+}
+
+static void __exit sp_crypto_module_exit(void)
+{
+	SP_CRYPTO_TRACE();
+#if 0
+	for (i = 0; i < ARRAY_SIZE(sp_dd_tb); ++i) {
+		platform_device_del(to_platform_device(sp_dd_tb[i].device));
+		platform_device_put(to_platform_device(sp_dd_tb[i].device));
+		iounmap((void *)sp_dd_tb[i].reg);
+	}
+#endif
+	platform_driver_unregister(&sp_crtpto_driver);
+
+	sp_rsa_finit();
+	sp_aes_finit();
+	sp_hash_finit();
+}
+
+module_init(sp_crypto_module_init);
+module_exit(sp_crypto_module_exit);
+
+MODULE_DESCRIPTION("sunplus aes sha3 rsa hw acceleration support.");
+MODULE_LICENSE("GPL v2");
+MODULE_AUTHOR("sunplus ltd jz.xiang");
--- a/drivers/crypto/sp/sp-crypto.h	1970-01-01 03:00:00.000000000 +0300
+++ a/drivers/crypto/sp/sp-crypto.h	2018-11-12 06:42:52.000000000 +0300
@@ -0,0 +1,558 @@
+#ifndef __SP_CRYPTO_H__
+#define __SP_CRYPTO_H__
+
+#include <linux/types.h>
+#include <linux/wait.h>
+#include <linux/semaphore.h>
+#include <linux/mutex.h>
+#include <linux/platform_device.h>
+#include <linux/dma-direction.h>
+#include <linux/kfifo.h>
+#include <asm/cacheflush.h>
+#include <crypto/scatterwalk.h>
+
+//#define SP_CRYPTO_LOCAL_TEST
+//#define USE_ERF				// use event_ring_full intr
+//#define TRACE_WAIT_ORDER		// trace wait/wake_up order
+
+#define CACHE_LINE_SIZE			(32)
+#define CACHE_LINE_MASK			(CACHE_LINE_SIZE - 1)
+#define CACHE_ALIGN(l)			ALIGN(l, CACHE_LINE_SIZE)
+
+#define TRB_SIZE				sizeof(trb_t)
+
+#define AES_RING(p)				((p)->rings[0])
+#define HASH_RING(p)			((p)->rings[1])
+#define TRB_RING(p)				((p)->dd->rings[(p)->type - SP_CRYPTO_AES])
+
+#define HASH_CMD_RING_SIZE		(PAGE_SIZE / TRB_SIZE)
+#define HASH_CMD_RING_SG		(1)
+#define AES_CMD_RING_SIZE		(PAGE_SIZE / TRB_SIZE)
+#define AES_CMD_RING_SG			(1)
+#define HASH_EVENT_RING_SIZE	(HASH_CMD_RING_SIZE * HASH_CMD_RING_SG)
+#define AES_EVENT_RING_SIZE		(AES_CMD_RING_SIZE * AES_CMD_RING_SG)
+
+#define TRB_RING_ALIGN_MASK		(32 - 1)
+
+#define BUS_SMALL_ENDIAN
+#define dev_reg					u32
+#define BITS_PER_REG			(32)
+#define SP_TRB_PARA_LEN			(12)
+
+#define AUTODMA_CRCR_ADDR_MASK	(~TRB_RING_ALIGN_MASK)
+#define AUTODMA_CRCR_CP			(1 << 4)
+#define AUTODMA_CRCR_CRR		(1 << 3)
+#define AUTODMA_CRCR_CS			(1 << 1)
+#define AUTODMA_CRCR_RCS		(1 << 0)
+
+#define AUTODMA_RCSR_EN			(1 << 31)
+#define AUTODMA_RCSR_ERF		(1 << 30)
+#define AUTODMA_RCSR_SIZE_MASK	(0xffff)
+
+#define AUTODMA_ERBAR_ERBA_MASK	(~TRB_RING_ALIGN_MASK)
+#define AUTODMA_TRIGGER			(1)
+
+#ifdef BUS_SMALL_ENDIAN
+#define AUTODMA_CRCR_FLAGS		(AUTODMA_CRCR_RCS | AUTODMA_CRCR_CP)
+#else
+#define AUTODMA_CRCR_FLAGS		(AUTODMA_CRCR_RCS)
+#endif
+
+#define SP_CRYPTO_TRUE			(1)
+#define SP_CRYPTO_FALSE			(0)
+
+#define TRB_NORMAL				(1)
+#define TRB_LINK				(2)
+
+typedef enum {
+	SP_CRYPTO_AES = 0x20180428,
+	SP_CRYPTO_HASH,
+	SP_CRYPTO_RSA,
+} crypto_type_t;
+
+typedef struct trb_s {
+
+	/* Cycle bits. indicates the current cycle of the ring */
+#ifdef BUS_SMALL_ENDIAN
+	void *priv;
+#else				/*  */
+	u32 c;
+	//u32 rsv0:31;
+#endif				/*  */
+	/* Completion Code. only use in event trb
+	 *   0 Invalid Indicates this field has not been updated
+	 *   1 Success indicates the transfer is successfully completed
+	 */
+	u32 cc:1;
+
+	/* Toggle Cycle bit. Used in link TRB only.
+	 *   indicates the cycle bits will be toggle in trb_next segment.
+	 */
+	u32 tc:1;
+
+	/* Interrupt On Complete.
+	 *   when this bit is set, controller will set an interrupt
+	 *   after this TRB is transmitted.
+	 */
+	u32 ioc:1;
+
+	u32 rsv1:1;
+
+	/* TRB type:
+	 *   0x1: Normal. Normal TRB used in trb_ring.
+	 *   0x2: Link. Link TRB to link to trb_ring segments
+	 */
+	u32 type:4;
+
+	u32 rsv2:8;
+
+	/*  Plain text size in bytes.
+	 * indicates the read/write data bytes of this TRB. 0 means 0 length data.
+	 */
+	u32 size:16;
+
+	/*For link TRB indicates the trb_next segment address.
+	 * or  Source data pointer(depend on ENDC)
+	 */
+	dma_addr_t sptr;
+
+	/* Destination data pointer (depend on ENDC)
+	 */
+	dma_addr_t dptr;
+
+	/* Parameter
+	 */
+	u32 mode;
+	dma_addr_t iptr; /* Initial Vector/Counter (IV/ICB) pointer */
+	dma_addr_t kptr; /* AES/GHASH: Key/Sub-Key pointer */
+
+#ifdef BUS_SMALL_ENDIAN
+	//u32 rsv3:31;
+
+	/* Cycle bits. indicates the current cycle of the ring */
+	u32 c;
+
+#else				/*  */
+	void *priv;
+
+#endif				/*  */
+}trb_t;
+
+typedef struct trb_ring_s {
+	trb_t *trb;
+	dma_addr_t pa;
+
+	/* get trb at tail, put trb at head */
+	trb_t *head;
+	trb_t *tail;
+	trb_t *link;
+
+	struct mutex lock;
+	struct semaphore trb_sem; /* sem to protect over use of trb */
+
+	u32 trigger_count;
+	u32 irq_count;
+
+#ifdef TRACE_WAIT_ORDER
+	DECLARE_KFIFO(f, wait_queue_head_t *, 32);
+#endif
+} trb_ring_t;
+
+struct sp_crypto_dev {
+	trb_ring_t *rings[2]; // AES/HASH
+	volatile struct sp_crypto_reg *reg;
+	u32 irq;
+	u32 version;
+	u32 devid;
+	//struct device *device;
+#if 0
+	atomic_t rsa_ref_cnt;	/*reference count */
+	atomic_t aes_ref_cnt;
+	atomic_t hash_ref_cnt;
+	u32 state;
+
+#define SEC_DEV_INAVTIVE  	0
+#define SEC_DEV_ACTIVE    	1
+#endif
+};
+
+
+typedef struct crypto_ctx_s {
+	struct sp_crypto_dev *dd;
+
+	crypto_type_t type;
+	u32 mode; // PAR0
+
+	volatile bool done;
+	wait_queue_head_t wait;
+	//struct semaphore sem;
+} crypto_ctx_t;
+
+/* trb.para.mode */
+#define M_MMASK		0x7F		// mode mask
+// AES
+#define M_AES_ECB	0x00000000
+#define M_AES_CBC	0x00000001
+#define M_AES_CTR	0x00000002
+#define M_ENC		(0 << 7)	// 0: encrypt
+#define M_DEC		(1 << 7)	// 1: decrypt
+// HASH
+#define M_MD5		0x00000000
+#define M_SHA3		0x00000001
+#define M_SHA3_224	0x00000001
+#define M_SHA3_256	0x00010001
+#define M_SHA3_384	0x00020001
+#define M_SHA3_512	0x00030001
+#define M_GHASH		0x00000002
+#define M_UPDATE	(0 << 7)	// 0: update
+#define M_FINAL		(1 << 7)	// 1: final
+
+#define AES_CMD_RD_IF	(1 << 8)
+#define HASH_CMD_RD_IF	(1 << 7)
+#define AES_TRB_IF		(1 << 6)
+#define HASH_TRB_IF		(1 << 5)
+#define AES_ERF_IF		(1 << 4)
+#define HASH_ERF_IF		(1 << 3)
+#define AES_DMA_IF		(1 << 2)
+#define HASH_DMA_IF		(1 << 1)
+#define RSA_DMA_IF		(1 << 0)
+
+#define AES_CMD_RD_IE	(1 << 8)
+#define HASH_CMD_RD_IE	(1 << 7)
+#define AES_TRB_IE		(1 << 6)
+#define HASH_TRB_IE		(1 << 5)
+#define AES_ERF_IE		(1 << 4)
+#define HASH_ERF_IE		(1 << 3)
+#define AES_DMA_IE		(1 << 2)
+#define HASH_DMA_IE		(1 << 1)
+#define RSA_DMA_IE		(1 << 0)
+
+struct sp_crypto_reg {
+
+	/*  Field Name  Bit     Access Description  */
+	/*  0.0 AES DMA Control Status register (AESDMACS)
+	   SIZE        31:16   RW DMA Transfer Length
+	   Reserved    15:4    RO Reserved
+	   ED          3       RO Endian 0:little endian 1:big endian
+	   Reserved    2:1     RO Reserved
+	   EN          0       RW DMA enable, it will be auto-clear to 0
+	   when DMA finishes
+	 */
+	dev_reg AESDMACS;
+
+	/* 0.1 AES Source Data pointer (AESSPTR) */
+	/*  SPTR        31:0    RW Source address must 32B alignment */
+	dev_reg AESSPTR;
+
+	/* 0.2 AES Destination Data pointer (AESDPTR)
+	   DPTR        31:0    RW Destination address must 32B alignment
+	 */
+	dev_reg AESDPTR;
+
+	/* 0.3 0.4 0.5: AES Parameters */
+	dev_reg AESPAR0; // mode
+	dev_reg AESPAR1; // iptr
+	dev_reg AESPAR2; // kptr
+
+	/* 0.6 HASH DMA Control Status register (HASHDMACS)
+	   SIZE        31:16   RW DMA Transfer Length
+	   Reserved    15:4    RO Reserved
+	   ED          3       RO Endian 0:little endian 1:big endian
+	   Reserved    2:1     RO Reserved
+	   EN          0       RW DMA enable, it will be auto-clear to 0
+	   when DMA finishes
+	 */
+	dev_reg HASHDMACS;
+
+	/* 0.7 HASH Source Data pointer (HASHSPTR)
+	   SPTR 31:0 RW Source address must 32B alignment
+	 */
+	dev_reg HASHSPTR;
+
+	/* 0.8 HASH Destination Data pointer (HASHDPTR)
+	   DPTR        31:0    RW Source address must 32B alignment
+	 */
+	dev_reg HASHDPTR;
+
+	/* 0.9 0.10 0.11: HASH Parameters */
+	dev_reg HASHPAR0; // mode
+	dev_reg HASHPAR1; // iptr
+	dev_reg HASHPAR2; // kptr(hptr)
+
+	/*0.12 RSA DMA Control Status register (RSADMACS)
+	   SIZE        31:16   RW DMA Transfer Length
+	   Reserved    15:4    RO Reserved
+	   ED          3       RO Endian 0:little endian 1:big endian
+	   Reserved    2:1     RO Reserved
+	   EN          0       RW DMA enable, it will be auto-clear to 0
+	   when DMA finishes
+	 */
+	dev_reg RSADMACS;
+#define RSA_DMA_ENABLE  (1 << 0)
+#define RSA_DATA_BE     (1 << 3)
+#define RSA_DATA_LE     (0 << 3)
+#define RSA_DMA_SIZE(x) (x << 16)
+
+	/*0.13 RSA Source Data pointer (RSASPTR)
+	   SPTR        31:0    RW Source(X) address Z=X**Y (mod N),
+	   must 32B alignment
+	 */
+	dev_reg RSASPTR;
+
+	/* 0.14 RSA Destination Data pointer (RSADPTR)
+	   DPTR        31:0    RW Destination(Z) address Z=X**Y (mod N),
+	   must 32B alignment
+	 */
+	dev_reg RSADPTR;
+
+	/* 0.15 RSA Dma Parameter 0 (RSAPAR0)
+	   D           31:16   RW N length, Only support 64*n(3<=n<=32)
+	   Reserved    15:8    RO Reserved
+	   PRECALC     7       RW Precalculate P2
+							  0: Precalculate and write back to pointer from P2PTR
+							  1: Fetch from P2PTR
+	   Reserved    6:0     RO Reserved
+	 */
+	dev_reg RSAPAR0;
+#define RSA_SET_PARA_D(x)   ((x) << 16)
+#define RSA_PARA_PRECAL_P2  (0 << 7)
+#define RSA_PARA_FETCH_P2   (1 << 7)
+
+	/*  0.16 RSA Dma Parameter 1 (RSAPAR1)
+	   YPTR 31:0 RW Y pointer Z=X**Y (mod N)
+	 */
+	dev_reg RSAYPTR;
+
+	/* 0.17 RSA Dma Parameter 2 (RSAPAR2)
+	   NPTR 31:0 RW N pointer Z=X**Y (mod N)
+	 */
+	dev_reg RSANPTR;
+
+	/* 0.18 RSA Dma Parameter 3 (RSAPAR3)
+	 * P2PTR 31:0 RW P2 pointer P2 = P**2(mod N)
+	 */
+	dev_reg RSAP2PTR;
+
+	/*0.19 0.20 RSA Dma Parameter 4 (RSAPAR4)
+	   WPTR 31:0 RW W pointer W= -N**-1(mod N)
+	 */
+	dev_reg RSAWPTRL;
+	dev_reg RSAWPTRH;
+
+	/* 0.21 AES DMA Command Ring Control Register (AESDMA_CRCR)
+	   CRPTR       31:5    RW Command Ring Pointer The command ring
+	   should be 32bytes aligned
+	   CP          4       RW Cycle bit Position 0:Word 0[0] 1:Word7[31]
+	   CRR         3       RO Command Ring Running Indicates the command
+	   ring is running, SW can only change the pointer
+	   when this bit is cleared
+	   Reserved    2       RO Reserved
+	   CS          1       RW Command Ring Stop
+	   Write 1 to stop the command ring
+	   RCS         0       RW Ring Cycle State
+	   Indicates the initial state of ring cycle bit
+	 */
+	dev_reg AESDMA_CRCR;
+
+
+	/*0.22 AES DMA Event Ring Base Address Register (AESDMA_ERBAR)
+	   ERBA        31:4    RW Event Ring Base Address
+	   the first TRB of the status will be write to this address
+	   Reserved 3:0 RO Reserved
+	 */
+	dev_reg AESDMA_ERBAR;
+
+	/*0.23 AES DMA Event Ring De-queue Pointer Register (AESDMA_ERDPR)
+	   ERDP        31:4    RW Event Ring De-queue Pointer
+	   Indicates the TRB address of which the CPU is
+	   processing now
+	   Reserved    3:0     RO Reserved
+	 */
+	dev_reg AESDMA_ERDPR;
+
+	/*0.24 AES DMA Ring Control and Status Register (AESDMA_RCSR)
+	   EN          31      RW Auto DMA enable
+	   	To enable the auto DMA feature
+	   ERF         30      RW1C Event ring Full
+	   	Indicates the Event Ring has been writing full
+	   Reserved    29:16   RO  Reserved
+	   Size        15:0    RW Event Ring Size
+	   	HWwill write to ERBA if the size reaches this value
+	   	and ERDP != ERBA (number of trbs)
+	 */
+	dev_reg AESDMA_RCSR;
+
+	/* 0.25 AES DMA Ring Trig Register (AESDMA_RTR)
+	   Reserved    31:1    RO Reserved
+	   CRT         0       RW Command Ring Trig
+	   After SW write a ¡¯1¡¯ to this bit, HW will start transfer
+	   TRBs until the ring is empty or stopped
+	 */
+	dev_reg AESDMA_RTR;
+
+	/* 0.26 HASH DMA Command Ring Control Register (HASHDMA_CRCR)
+	   CRPTR       31:5    RW  Command Ring Pointer
+	   The command ring should be 32bytes aligned
+	   CP          4       RW Cycle bit Position
+	   0:Word 0[0] 1:Word7[31]
+	   CRR         3       RO Command Ring Running
+	   Indicates the command ring is running, SW can only
+	   change the pointer when this bit is cleared
+	   Reserved    2       RO Reserved
+	   CS          1       RW Command Ring Stop
+	   Write 1 to stop the command ring
+	   RCS         0       RW Ring Cycle State
+	   Indicates the initial state of ring cycle bit
+	 */
+	dev_reg HASHDMA_CRCR;
+
+
+	/* 0.27 HASH DMA Event Ring Base Address Register (HASHDMA_ERBAR)
+	   ERBA        31:4    RW Event Ring Base Address
+	   The first TRB of the status will be write to this address
+	   Reserved    3:0     RO Reserved
+	 */
+	dev_reg HASHDMA_ERBAR;
+
+	/* 0.28 HASH DMA Event Ring De-queue Pointer Register (HASHDMA_ERDPR)
+	   ERDP        31:4    RW Event Ring De-queue Pointer
+	   Indicates the TRB address of which the CPU is processing now
+	   Reserved    3:0     RO Reserved
+	 */
+	dev_reg HASHDMA_ERDPR;
+
+	/*0.29 HASH DMA Ring Control and Status Register (HASHDMA_RCSR)
+	   EN          31      RW Auto DMA enable
+	   To enable the auto DMA feature
+	   ERF         30      RW1C Event ring Full
+	   Indicates the Event Ring has been writing full
+	   Reserved    29:16   RO Reserved
+	   Size 15:0 RW Event Ring Size
+	   HWwill write to ERBA if the size reaches this value and  ERDP != ERBA
+	 */
+	dev_reg HASHDMA_RCSR;
+
+	/* 0.30 HASH DMA Ring Trig Register (HASHDMA_RTR)
+	   Reserved    31:1    RO Reserved
+	   CRT         0       RW Command Ring Trig
+	   After SW write a ¡¯1¡¯ to this bit, HW will start transfer
+	   TRBs until the ring is empty or stopped
+	 */
+	dev_reg HASHDMA_RTR;
+
+	/* 0.31 */
+	dev_reg reserved;
+
+
+
+	/* 1.0 SEC IP Version (VERSION)
+	   VERSION 31:0 RO the date of version
+	 */
+	dev_reg VERSION;
+
+	/* 1.1 Interrupt Enable (SECIE)
+	   Reserve     31:7    RO Reserve
+	   AES_TRB_IE  6       RW AES TRB done interrupt enable
+	   HASH TRB IE 5       RW HASH TRB done interrupt enable
+	   AES_ERF_IE  4       RW AES Event Ring Full interrupt enable
+	   HASH_ERF_IE 3       RW HASH Event Ring Full interrupt enable
+	   AES_DMA_IE  2       RW AES DMA finish interrupt enable
+	   HASH_DMA_IE 1       RW HASH DMA finish interrupt enable
+	   RSA_DMA_IE  0       RW RSA DMA finish interrupt enable
+	 */
+	dev_reg SECIE;
+
+
+	/* 1.2 Interrupt Flag (SECIF)
+	   Reserve     31:7    RO Reserve
+	   AES_TRB_IF  6       RW AES TRB done interrupt flag
+	   HASH_TRB_IF 5       RW HASH TRB done interrupt flag
+	   AES_ERF_IF  4       RW AES Event Ring Full interrupt flag
+	   HASH_ERF_IF 3       RW HASH Event Ring Full interrupt flag
+	   AES_DMA_IF  2       RW AES DMA finish interrupt flag
+	   HASH_DMA_IF 1       RW HASH DMA finish interrupt flag
+	   RSA_DMA_IF  0       RW RSA DMA finish interrupt flag
+	 */
+	dev_reg SECIF;
+
+#if 1 // for debug
+	dev_reg AES_CR;		// AES  cmd ring pointer
+	dev_reg AES_ER; 	// AES  evt ring pointer
+	dev_reg HASH_CR;	// HASH cmd ring pointer
+	dev_reg HASH_ER; 	// HASH evt ring pointer
+#endif
+
+};
+
+/* funciton  */
+#define ERR_OUT(err, label, info, ...) \
+do { \
+	if (unlikely(IS_ERR((void *)(err)))) { \
+		ret = PTR_ERR((void *)(err)); \
+		SP_CRYPTO_ERR("ERR(%d) @ %s(%d): "info"\n", ret, __FUNCTION__, __LINE__, ##__VA_ARGS__); \
+		goto label; \
+	} \
+} while (0)
+
+//#define SP_CRYPTO_TRACE()  printk(KERN_DEBUG "%s:%d\n", __FUNCTION__, __LINE__)
+#define SP_CRYPTO_TRACE()
+#define SP_CRYPTO_ERR(fmt, ...)  printk(KERN_ERR fmt, ##__VA_ARGS__)
+#define SP_CRYPTO_WAR(fmt, ...)  printk(KERN_WARNING fmt, ##__VA_ARGS__)
+#define SP_CRYPTO_INF(fmt, ...)  //printk(KERN_INFO fmt, ##__VA_ARGS__)
+#define SP_CRYPTO_DBG(fmt, ...)  //printk(KERN_DEBUG fmt, ##__VA_ARGS__)
+
+void sp_crypto_free_dev(struct sp_crypto_dev *dev, u32 type);
+struct sp_crypto_dev *sp_crypto_alloc_dev(int type);
+
+int crypto_ctx_init(crypto_ctx_t *ctx, crypto_type_t type);
+void crypto_ctx_exit(crypto_ctx_t *ctx);
+int crypto_ctx_exec(crypto_ctx_t *ctx);
+trb_t *crypto_ctx_queue(crypto_ctx_t *ctx,
+	dma_addr_t src, dma_addr_t dst,
+	dma_addr_t iv, dma_addr_t key,
+	u32 len, u32 mode, bool ioc);
+
+trb_t *trb_next(trb_t *trb);
+trb_t *trb_get(trb_ring_t *ring);
+trb_t *trb_put(trb_ring_t *ring);		/* USE_IN_IRQ, move ring tail to next */
+void trb_ring_reset(trb_ring_t *ring);	/* USE_IN_IRQ, reset ring head & tail to base addr */
+
+void dump_trb(trb_t *trb);
+
+extern void dump_buf(u8 *buf, u32 len);
+
+#if 0
+static inline void DCACHE_FLUSH(void *start, size_t size)
+{
+	unsigned long flags;
+
+	SP_CRYPTO_INF("DCACHE_FLUSH: %p ~ %p    %x\n", start, start + size, size);
+	local_irq_save(flags);
+	dmac_flush_range(start, start + size);
+	outer_flush_range(__pa(start), __pa(start) + size);
+	local_irq_restore(flags);
+}
+//#endif
+static inline void DCACHE_CLEAN(void *start, size_t size)
+{
+	unsigned long flags;
+
+	local_irq_save(flags);
+	arm_dma_ops.sync_single_for_device(NULL, __pa(start), size, DMA_TO_DEVICE);
+	//dmac_map_area(start, size, DMA_TO_DEVICE);
+	//outer_clean_range(__pa(start), __pa(start) + size);
+	local_irq_restore(flags);
+}
+static inline void DCACHE_INVALIDATE(void *start, size_t size)
+{
+	unsigned long flags;
+
+	local_irq_save(flags);
+	arm_dma_ops.sync_single_for_cpu(NULL, __pa(start), size, DMA_FROM_DEVICE);
+	//outer_inv_range(__pa(start), __pa(start) + size);
+	//dmac_unmap_area(start, size, DMA_FROM_DEVICE);
+	local_irq_restore(flags);
+}
+#endif
+
+#endif //__SP_CRYPTO_H__
--- a/drivers/crypto/sp/sp-crypto-test.c	1970-01-01 03:00:00.000000000 +0300
+++ a/drivers/crypto/sp/sp-crypto-test.c	2018-11-12 06:42:52.000000000 +0300
@@ -0,0 +1,1188 @@
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/slab.h>
+#include <linux/mpi.h>
+#include <linux/random.h>
+#include <linux/kthread.h>
+
+#include "sp-crypto.h"
+#include "sp-rsa.h"
+
+typedef int (*test_func)(void *para);
+
+struct test_case {
+	test_func fun;
+	const char *name;
+};
+
+typedef struct rsa_keypair_t{
+	char e1[256];
+	char e2[256];
+	char n[256];
+	u32 len;
+	u32 sort;  /*0:big endbian, 1:small endbian*/
+}rsa_keypair_t;
+
+
+rsa_keypair_t rsa_keyparit[] =
+{
+	// 0
+	{
+		.e1 = { 0x01, 0x00, 0x01 },
+		.e2 = { 0x41, 0x2a, 0xc0, 0x34, 0x13, 0x69, 0x05, 0xbe, 0x69, 0xaa, 0x41, 0xb7, 0x27, 0x77, 0x5c, 0x68, 0x44, 0x90, 0x1b, 0x6b, 0xc6, 0x28, 0xd7, 0x32, 0x0e, 0x95, 0xee, 0x7c, 0x1a, 0xa8, 0x13, 0x8e, 0xb3, 0xb6, 0x47, 0xaf, 0x48, 0xce, 0xd4, 0x03, 0xea, 0xd5, 0xed, 0x21, 0x77, 0xb2, 0x39, 0x2c, 0xc6, 0x3b, 0x85, 0xdd, 0xe7, 0xd3, 0x4e, 0x29, 0xe0, 0x0e, 0xdd, 0x52, 0x49, 0xd9, 0x2a, 0x92, 0xf3, 0xdd, 0x0d, 0x99, 0x14, 0x86, 0xb8, 0x89, 0x68, 0x71, 0x57, 0xc6, 0x47, 0x45, 0x4e, 0xf7, 0xa8, 0xf0, 0x1d, 0xad, 0x4e, 0x01, 0x1a, 0x14, 0xc2, 0x89, 0xe4, 0x08, 0xbc, 0xcd, 0x86, 0x6a, 0x6a, 0xc3, 0x24, 0xc5, 0xd5, 0x6a, 0xef, 0x30, 0xac, 0x7a, 0xc6, 0xd3, 0x4c, 0x51, 0xd1, 0xe9, 0x2a, 0xbf, 0x79, 0xfa, 0x1d, 0x91, 0x81, 0xb4, 0x79, 0x73, 0x39, 0x0f, 0xdd, 0x38, 0xa7, 0xb2, 0x8b, 0x00, 0xe3, 0xc7, 0xdc, 0x47, 0x46, 0x0c, 0x27, 0x7d, 0x99, 0xc1, 0x1d, 0xfd, 0x36, 0x16, 0x06, 0xaa, 0x76, 0x5a, 0x5a, 0x42, 0x5c, 0xdb, 0x75, 0x4d, 0xe0, 0xe0, 0xe0, 0xc0, 0x09, 0x2f, 0x57, 0xe9, 0x4c, 0x9a, 0xc0, 0xcf, 0x24, 0xcb, 0xaf, 0xe4, 0xda, 0x15, 0x3a, 0x74, 0x5f, 0x8e, 0xc2, 0x38, 0xfc, 0x9c, 0x2a, 0xd3, 0x74, 0x20, 0xce, 0x28, 0x4e, 0x53, 0xe3, 0xe6, 0xf1, 0xff, 0x34, 0x56, 0x7c, 0xf4, 0x45, 0xa2, 0x56, 0xdb, 0xcf, 0x18, 0x45, 0xf3, 0x0c, 0x7d, 0xd0, 0xa6, 0x6c, 0xd9, 0xcf, 0x5c, 0xfc, 0xab, 0x87, 0x35, 0x06, 0x40, 0xf4, 0xb8, 0x46, 0x16, 0xee, 0x31, 0x50, 0xf5, 0x24, 0xdc, 0xca, 0xf0, 0xec, 0xd4, 0x04, 0x52, 0x7b, 0x3c, 0xb5, 0x40, 0x2c, 0xb3, 0x07, 0x6f, 0x7a, 0x82, 0x39, 0x1b, 0x8e, 0xaa, 0x36, 0xfd, 0x39, 0x86, 0xde, 0xef, 0xbc, 0x04 },
+		.n = { 0x4b, 0x86, 0xf8, 0x84, 0xfc, 0x68, 0xcc, 0xd2, 0x01, 0x14, 0xc7,
+			 0xcb, 0x34, 0x48, 0xf0, 0xce, 0x9e, 0xd9, 0xae, 0x02, 0x19, 0xee,
+			 0xe9, 0xaf, 0xb5, 0xcf, 0xcf, 0xba, 0xec, 0x39, 0x40, 0x03, 0xd2,
+			 0x61, 0x50, 0x1f, 0x25, 0x04, 0x82, 0x44, 0x98, 0x45, 0xef, 0xed,
+			 0xf5, 0xcd, 0x9d, 0x61, 0xa1, 0x30, 0x3e, 0xf6, 0x47, 0x37, 0x27,
+			 0x2d, 0x56, 0xed, 0x3a, 0xe0, 0x6a, 0x69, 0x8a, 0xe2, 0x00, 0x06,
+			 0x8d, 0x81, 0x07, 0x5e, 0xb0, 0xe9, 0xa1, 0x75, 0xf4, 0x62, 0x2f,
+			 0xfe, 0x84, 0xce, 0x29, 0x8f, 0x6a, 0xe2, 0x9b, 0x4a, 0x3a, 0x62,
+			 0xfc, 0x58, 0xb9, 0x6c, 0x0d, 0xd0, 0x18, 0x5d, 0x00, 0x13, 0xd4,
+			 0x8a, 0x80, 0xda, 0xe1, 0xfa, 0x04, 0x3e, 0xd7, 0x49, 0x17, 0x3d,
+			 0xdd, 0x2b, 0xa2, 0x22, 0x67, 0xf1, 0x8b, 0x5c, 0x79, 0x4d, 0x8e,
+			 0xc4, 0x21, 0x95, 0x79, 0x7a, 0x8c, 0xfd, 0xaa, 0x21, 0xa8, 0x70,
+			 0x6b, 0x67, 0x9a, 0x28, 0xf5, 0xda, 0x60, 0xa3, 0x5b, 0xcb, 0x75,
+			 0x10, 0xc6, 0x00, 0xae, 0x06, 0x5a, 0xf5, 0x0d, 0x62, 0x2e, 0x6b,
+			 0x29, 0xac, 0x28, 0x9a, 0x1e, 0x65, 0x55, 0xab, 0x52, 0x52, 0x9d,
+			 0xe1, 0xa7, 0xbd, 0xc2, 0x39, 0x7a, 0xab, 0x0e, 0xec, 0x5c, 0xe2,
+			 0xc5, 0xf2, 0x63, 0x3c, 0x05, 0x34, 0xd8, 0xa9, 0xec, 0xaf, 0xf1,
+			 0x8c, 0x14, 0xf7, 0xea, 0x89, 0x86, 0x8f, 0x50, 0x9f, 0xdc, 0x7b,
+			 0x21, 0x0c, 0x7f, 0x2a, 0xa4, 0x8f, 0x78, 0xcb, 0x07, 0x15, 0xb7,
+			 0x0f, 0xff, 0xd6, 0x61, 0x0c, 0x5e, 0xa8, 0x19, 0x46, 0x7b, 0xb9,
+			 0xa2, 0xea, 0x3d, 0xdb, 0xc7, 0x9f, 0x28, 0x86, 0x7e, 0x69, 0x6c,
+			 0xb3, 0x21, 0xa6, 0x59, 0x4a, 0x8a, 0x73, 0x4f, 0xab, 0xd6, 0x87,
+			 0x10, 0x0b, 0x7c, 0xa1, 0x2a, 0x70, 0xdd, 0xa6, 0xfc, 0x75, 0x09,
+			 0x97, 0x87, 0xc5 },
+			 .len = 256,
+			 .sort = 1,
+	},
+
+		// 1
+	{
+		.e2 = { 0x01, 0x00, 0x01 },
+		.e1 = { 0x41, 0x2a, 0xc0, 0x34, 0x13, 0x69, 0x05, 0xbe, 0x69, 0xaa, 0x41, 0xb7, 0x27, 0x77, 0x5c, 0x68, 0x44, 0x90, 0x1b, 0x6b, 0xc6, 0x28, 0xd7, 0x32, 0x0e, 0x95, 0xee, 0x7c, 0x1a, 0xa8, 0x13, 0x8e, 0xb3, 0xb6, 0x47, 0xaf, 0x48, 0xce, 0xd4, 0x03, 0xea, 0xd5, 0xed, 0x21, 0x77, 0xb2, 0x39, 0x2c, 0xc6, 0x3b, 0x85, 0xdd, 0xe7, 0xd3, 0x4e, 0x29, 0xe0, 0x0e, 0xdd, 0x52, 0x49, 0xd9, 0x2a, 0x92, 0xf3, 0xdd, 0x0d, 0x99, 0x14, 0x86, 0xb8, 0x89, 0x68, 0x71, 0x57, 0xc6, 0x47, 0x45, 0x4e, 0xf7, 0xa8, 0xf0, 0x1d, 0xad, 0x4e, 0x01, 0x1a, 0x14, 0xc2, 0x89, 0xe4, 0x08, 0xbc, 0xcd, 0x86, 0x6a, 0x6a, 0xc3, 0x24, 0xc5, 0xd5, 0x6a, 0xef, 0x30, 0xac, 0x7a, 0xc6, 0xd3, 0x4c, 0x51, 0xd1, 0xe9, 0x2a, 0xbf, 0x79, 0xfa, 0x1d, 0x91, 0x81, 0xb4, 0x79, 0x73, 0x39, 0x0f, 0xdd, 0x38, 0xa7, 0xb2, 0x8b, 0x00, 0xe3, 0xc7, 0xdc, 0x47, 0x46, 0x0c, 0x27, 0x7d, 0x99, 0xc1, 0x1d, 0xfd, 0x36, 0x16, 0x06, 0xaa, 0x76, 0x5a, 0x5a, 0x42, 0x5c, 0xdb, 0x75, 0x4d, 0xe0, 0xe0, 0xe0, 0xc0, 0x09, 0x2f, 0x57, 0xe9, 0x4c, 0x9a, 0xc0, 0xcf, 0x24, 0xcb, 0xaf, 0xe4, 0xda, 0x15, 0x3a, 0x74, 0x5f, 0x8e, 0xc2, 0x38, 0xfc, 0x9c, 0x2a, 0xd3, 0x74, 0x20, 0xce, 0x28, 0x4e, 0x53, 0xe3, 0xe6, 0xf1, 0xff, 0x34, 0x56, 0x7c, 0xf4, 0x45, 0xa2, 0x56, 0xdb, 0xcf, 0x18, 0x45, 0xf3, 0x0c, 0x7d, 0xd0, 0xa6, 0x6c, 0xd9, 0xcf, 0x5c, 0xfc, 0xab, 0x87, 0x35, 0x06, 0x40, 0xf4, 0xb8, 0x46, 0x16, 0xee, 0x31, 0x50, 0xf5, 0x24, 0xdc, 0xca, 0xf0, 0xec, 0xd4, 0x04, 0x52, 0x7b, 0x3c, 0xb5, 0x40, 0x2c, 0xb3, 0x07, 0x6f, 0x7a, 0x82, 0x39, 0x1b, 0x8e, 0xaa, 0x36, 0xfd, 0x39, 0x86, 0xde, 0xef, 0xbc, 0x04 },
+		.n = { 0x4b, 0x86, 0xf8, 0x84, 0xfc, 0x68, 0xcc, 0xd2, 0x01, 0x14, 0xc7,
+			 0xcb, 0x34, 0x48, 0xf0, 0xce, 0x9e, 0xd9, 0xae, 0x02, 0x19, 0xee,
+			 0xe9, 0xaf, 0xb5, 0xcf, 0xcf, 0xba, 0xec, 0x39, 0x40, 0x03, 0xd2,
+			 0x61, 0x50, 0x1f, 0x25, 0x04, 0x82, 0x44, 0x98, 0x45, 0xef, 0xed,
+			 0xf5, 0xcd, 0x9d, 0x61, 0xa1, 0x30, 0x3e, 0xf6, 0x47, 0x37, 0x27,
+			 0x2d, 0x56, 0xed, 0x3a, 0xe0, 0x6a, 0x69, 0x8a, 0xe2, 0x00, 0x06,
+			 0x8d, 0x81, 0x07, 0x5e, 0xb0, 0xe9, 0xa1, 0x75, 0xf4, 0x62, 0x2f,
+			 0xfe, 0x84, 0xce, 0x29, 0x8f, 0x6a, 0xe2, 0x9b, 0x4a, 0x3a, 0x62,
+			 0xfc, 0x58, 0xb9, 0x6c, 0x0d, 0xd0, 0x18, 0x5d, 0x00, 0x13, 0xd4,
+			 0x8a, 0x80, 0xda, 0xe1, 0xfa, 0x04, 0x3e, 0xd7, 0x49, 0x17, 0x3d,
+			 0xdd, 0x2b, 0xa2, 0x22, 0x67, 0xf1, 0x8b, 0x5c, 0x79, 0x4d, 0x8e,
+			 0xc4, 0x21, 0x95, 0x79, 0x7a, 0x8c, 0xfd, 0xaa, 0x21, 0xa8, 0x70,
+			 0x6b, 0x67, 0x9a, 0x28, 0xf5, 0xda, 0x60, 0xa3, 0x5b, 0xcb, 0x75,
+			 0x10, 0xc6, 0x00, 0xae, 0x06, 0x5a, 0xf5, 0x0d, 0x62, 0x2e, 0x6b,
+			 0x29, 0xac, 0x28, 0x9a, 0x1e, 0x65, 0x55, 0xab, 0x52, 0x52, 0x9d,
+			 0xe1, 0xa7, 0xbd, 0xc2, 0x39, 0x7a, 0xab, 0x0e, 0xec, 0x5c, 0xe2,
+			 0xc5, 0xf2, 0x63, 0x3c, 0x05, 0x34, 0xd8, 0xa9, 0xec, 0xaf, 0xf1,
+			 0x8c, 0x14, 0xf7, 0xea, 0x89, 0x86, 0x8f, 0x50, 0x9f, 0xdc, 0x7b,
+			 0x21, 0x0c, 0x7f, 0x2a, 0xa4, 0x8f, 0x78, 0xcb, 0x07, 0x15, 0xb7,
+			 0x0f, 0xff, 0xd6, 0x61, 0x0c, 0x5e, 0xa8, 0x19, 0x46, 0x7b, 0xb9,
+			 0xa2, 0xea, 0x3d, 0xdb, 0xc7, 0x9f, 0x28, 0x86, 0x7e, 0x69, 0x6c,
+			 0xb3, 0x21, 0xa6, 0x59, 0x4a, 0x8a, 0x73, 0x4f, 0xab, 0xd6, 0x87,
+			 0x10, 0x0b, 0x7c, 0xa1, 0x2a, 0x70, 0xdd, 0xa6, 0xfc, 0x75, 0x09,
+			 0x97, 0x87, 0xc5
+		},
+		.len = 256,
+		.sort = 1,
+	},
+
+	{
+		.e1 = {
+			0x35,
+		},
+		.e2 = {
+			0x22, 0x3a, 0x4b, 0xf9, 0x6c, 0x05, 0x82, 0x4a, 0xd4, 0xf1, 0x59, 0x5f, 0xd5, 0x93, 0x72,
+			0x53, 0xca, 0x76, 0x5f, 0x18, 0xd4, 0xc5, 0xa5, 0x74, 0x1a, 0x5f, 0x94, 0x4e, 0xe5, 0xec,
+			0x1b, 0xdb, 0x5f, 0xf0, 0x7e, 0x19, 0xde, 0x28, 0xdd, 0xba, 0x92, 0xaa, 0x04, 0x4c, 0xa8,
+			0x43, 0x8c, 0x53, 0xe5, 0x39, 0xb6, 0x76, 0x25, 0x8e, 0x3c, 0x48, 0x1f, 0x49, 0x14, 0x07,
+			0xc8, 0xfb, 0xa8, 0xd6, 0xc4, 0xb9, 0x54, 0xf1, 0xe7, 0x17, 0x8b, 0xbb, 0x57, 0x1f, 0x9f,
+			0x07, 0x4f, 0xe0, 0xea, 0xad, 0xf3, 0x7d, 0xca, 0xd3, 0xd9, 0xf0, 0x04, 0x49, 0xe7, 0x75,
+			0x89, 0x10, 0xdb, 0x86, 0xa0, 0xc8, 0x0a, 0xce, 0x37, 0x6d, 0xa0, 0x4d, 0x76, 0x70, 0xe0,
+			0xfc, 0x20, 0xbf, 0xd6, 0x0f, 0x4b, 0xac, 0x26, 0x18, 0x28, 0x8a, 0x74, 0xdc, 0x03, 0x93,
+			0x67, 0xde, 0x63, 0x2f, 0xbc, 0xb5, 0xa0, 0x7e, 0xa3, 0x27, 0x4e, 0xcb, 0xc2, 0xe3, 0xf2,
+			0xde, 0x0f, 0x59, 0x60, 0x6e, 0x78, 0x04, 0xbb, 0x9a, 0xc6, 0xd0, 0x32, 0xf2, 0xcf, 0xb0,
+			0x9d, 0x12, 0x99, 0x76, 0x09, 0xd3, 0x00, 0x98, 0xa2, 0x3f, 0x82, 0x8b, 0xfe, 0x0f, 0x88,
+			0xd6, 0xb4, 0x6d, 0xa3, 0x93, 0x2e, 0x33, 0x10, 0xb0, 0xeb, 0xf4, 0xbd, 0xa1, 0x32, 0x6f,
+			0x23, 0x27, 0x52, 0x20, 0x54, 0x7a, 0x99, 0x59, 0x04, 0x14, 0xa9, 0xff, 0x26, 0xb3, 0xb5,
+			0x00, 0x0f, 0x71, 0x0f, 0x5c, 0xdd, 0xcb, 0x44, 0xf7, 0xee, 0x53, 0x83, 0x11, 0x88, 0x56,
+			0x27, 0xa5, 0xa3, 0xdc, 0x95, 0xb1, 0x9f, 0xc7, 0x43, 0x96, 0xe6, 0x9d, 0x82, 0xa9, 0x7a,
+			0x89, 0x01, 0xa7, 0x8b, 0x1e, 0xff, 0xba, 0xb4, 0xaf, 0x8a, 0x43, 0xb6, 0xf5, 0x79, 0xaf,
+			0xa0, 0xc5, 0xd3, 0xb8, 0x7b, 0x1b, 0x62, 0x80, 0xb2, 0x9b, 0x48, 0x78, 0x41, 0x31, 0x26,
+			0x45,
+		},
+		.n = {
+			0xc9, 0x90, 0x31, 0x2e, 0x98, 0x92, 0x38, 0x2a, 0x74, 0x37, 0xf1, 0xdf, 0x06, 0x2b,
+			0x68, 0x5f, 0x36, 0x80, 0x30, 0x04, 0x01, 0x6f, 0x79, 0x01, 0x0d, 0x16, 0x69, 0x5e, 0xd8,
+			0x35, 0x87, 0x9a, 0x18, 0x88, 0x3b, 0xed, 0xaa, 0x7e, 0xe0, 0xd8, 0xed, 0xe9, 0x35, 0xc3,
+			0x6d, 0x1c, 0x01, 0x7c, 0x45, 0xe2, 0x16, 0x0d, 0x16, 0x0c, 0xb8, 0x53, 0x62, 0xe7, 0x3d,
+			0x11, 0x66, 0xad, 0x8c, 0xf0, 0xbf, 0x5f, 0xd7, 0xc9, 0x6d, 0x51, 0xc5, 0x16, 0x56, 0x64,
+			0xe1, 0x63, 0xf2, 0xd7, 0x2d, 0x1c, 0xd2, 0xc8, 0x55, 0x18, 0x75, 0x30, 0x19, 0x41, 0x6f,
+			0x7b, 0x43, 0x9c, 0x29, 0x35, 0x41, 0x0b, 0xcd, 0xda, 0xd4, 0xa2, 0x05, 0x56, 0x64, 0x26,
+			0xf4, 0x05, 0xa4, 0x69, 0xb3, 0xaf, 0x68, 0x4b, 0x19, 0x38, 0xee, 0xbd, 0x93, 0xba, 0x4d,
+			0xf2, 0x47, 0x3a, 0x0f, 0x35, 0x90, 0x2d, 0x94, 0xb2, 0xa4, 0x49, 0xbc, 0xfb, 0x27, 0x33,
+			0x8a, 0x03, 0xc8, 0xa8, 0xc3, 0x19, 0x61, 0xb6, 0x1b, 0xb8, 0x92, 0x4e, 0xb3, 0xc6, 0x33,
+			0x3a, 0x62, 0xf2, 0x22, 0x6b, 0xf9, 0xfa, 0x32, 0x06, 0x68, 0x51, 0x3f, 0x57, 0x68, 0xe0,
+			0x53, 0xcf, 0xc8, 0xe0, 0x0e, 0x3c, 0x50, 0x8d, 0x52, 0x9b, 0x80, 0x60, 0x9c, 0xef, 0xad,
+			0x64, 0x21, 0x27, 0x87, 0x14, 0xed, 0x5a, 0x9d, 0xc1, 0x2d, 0x30, 0x86, 0x5d, 0xe4, 0xa9,
+			0x10, 0x9a, 0x44, 0x8d, 0x9c, 0xba, 0x0e, 0xa0, 0xbe, 0x4e, 0x4e, 0x07, 0xe8, 0x59, 0xe3,
+			0x32, 0x31, 0xb0, 0xee, 0xae, 0x62, 0x5c, 0xd3, 0x0d, 0xce, 0x50, 0x31, 0x0c, 0xf2, 0xb5,
+			0x72, 0x54, 0x86, 0xa4, 0x75, 0x0f, 0x82, 0x0c, 0xef, 0x7b, 0xf1, 0x10, 0x0f, 0x75, 0x57,
+			0x4d, 0x6c, 0x30, 0xdf, 0x34, 0x91, 0xc1, 0xec, 0x45, 0x75, 0x67, 0xba, 0xc8, 0x48, 0xbc,
+			0x3b, 0x9b,
+		},
+		.len = 256,
+	},
+	{
+		.e2 = {
+			0x35,
+		},
+		.e1 = {
+			0x22, 0x3a, 0x4b, 0xf9, 0x6c, 0x05, 0x82, 0x4a, 0xd4, 0xf1, 0x59, 0x5f, 0xd5, 0x93, 0x72,
+			0x53, 0xca, 0x76, 0x5f, 0x18, 0xd4, 0xc5, 0xa5, 0x74, 0x1a, 0x5f, 0x94, 0x4e, 0xe5, 0xec,
+			0x1b, 0xdb, 0x5f, 0xf0, 0x7e, 0x19, 0xde, 0x28, 0xdd, 0xba, 0x92, 0xaa, 0x04, 0x4c, 0xa8,
+			0x43, 0x8c, 0x53, 0xe5, 0x39, 0xb6, 0x76, 0x25, 0x8e, 0x3c, 0x48, 0x1f, 0x49, 0x14, 0x07,
+			0xc8, 0xfb, 0xa8, 0xd6, 0xc4, 0xb9, 0x54, 0xf1, 0xe7, 0x17, 0x8b, 0xbb, 0x57, 0x1f, 0x9f,
+			0x07, 0x4f, 0xe0, 0xea, 0xad, 0xf3, 0x7d, 0xca, 0xd3, 0xd9, 0xf0, 0x04, 0x49, 0xe7, 0x75,
+			0x89, 0x10, 0xdb, 0x86, 0xa0, 0xc8, 0x0a, 0xce, 0x37, 0x6d, 0xa0, 0x4d, 0x76, 0x70, 0xe0,
+			0xfc, 0x20, 0xbf, 0xd6, 0x0f, 0x4b, 0xac, 0x26, 0x18, 0x28, 0x8a, 0x74, 0xdc, 0x03, 0x93,
+			0x67, 0xde, 0x63, 0x2f, 0xbc, 0xb5, 0xa0, 0x7e, 0xa3, 0x27, 0x4e, 0xcb, 0xc2, 0xe3, 0xf2,
+			0xde, 0x0f, 0x59, 0x60, 0x6e, 0x78, 0x04, 0xbb, 0x9a, 0xc6, 0xd0, 0x32, 0xf2, 0xcf, 0xb0,
+			0x9d, 0x12, 0x99, 0x76, 0x09, 0xd3, 0x00, 0x98, 0xa2, 0x3f, 0x82, 0x8b, 0xfe, 0x0f, 0x88,
+			0xd6, 0xb4, 0x6d, 0xa3, 0x93, 0x2e, 0x33, 0x10, 0xb0, 0xeb, 0xf4, 0xbd, 0xa1, 0x32, 0x6f,
+			0x23, 0x27, 0x52, 0x20, 0x54, 0x7a, 0x99, 0x59, 0x04, 0x14, 0xa9, 0xff, 0x26, 0xb3, 0xb5,
+			0x00, 0x0f, 0x71, 0x0f, 0x5c, 0xdd, 0xcb, 0x44, 0xf7, 0xee, 0x53, 0x83, 0x11, 0x88, 0x56,
+			0x27, 0xa5, 0xa3, 0xdc, 0x95, 0xb1, 0x9f, 0xc7, 0x43, 0x96, 0xe6, 0x9d, 0x82, 0xa9, 0x7a,
+			0x89, 0x01, 0xa7, 0x8b, 0x1e, 0xff, 0xba, 0xb4, 0xaf, 0x8a, 0x43, 0xb6, 0xf5, 0x79, 0xaf,
+			0xa0, 0xc5, 0xd3, 0xb8, 0x7b, 0x1b, 0x62, 0x80, 0xb2, 0x9b, 0x48, 0x78, 0x41, 0x31, 0x26,
+			0x45,
+		},
+		.n = {
+			0xc9, 0x90, 0x31, 0x2e, 0x98, 0x92, 0x38, 0x2a, 0x74, 0x37, 0xf1, 0xdf, 0x06, 0x2b,
+			0x68, 0x5f, 0x36, 0x80, 0x30, 0x04, 0x01, 0x6f, 0x79, 0x01, 0x0d, 0x16, 0x69, 0x5e, 0xd8,
+			0x35, 0x87, 0x9a, 0x18, 0x88, 0x3b, 0xed, 0xaa, 0x7e, 0xe0, 0xd8, 0xed, 0xe9, 0x35, 0xc3,
+			0x6d, 0x1c, 0x01, 0x7c, 0x45, 0xe2, 0x16, 0x0d, 0x16, 0x0c, 0xb8, 0x53, 0x62, 0xe7, 0x3d,
+			0x11, 0x66, 0xad, 0x8c, 0xf0, 0xbf, 0x5f, 0xd7, 0xc9, 0x6d, 0x51, 0xc5, 0x16, 0x56, 0x64,
+			0xe1, 0x63, 0xf2, 0xd7, 0x2d, 0x1c, 0xd2, 0xc8, 0x55, 0x18, 0x75, 0x30, 0x19, 0x41, 0x6f,
+			0x7b, 0x43, 0x9c, 0x29, 0x35, 0x41, 0x0b, 0xcd, 0xda, 0xd4, 0xa2, 0x05, 0x56, 0x64, 0x26,
+			0xf4, 0x05, 0xa4, 0x69, 0xb3, 0xaf, 0x68, 0x4b, 0x19, 0x38, 0xee, 0xbd, 0x93, 0xba, 0x4d,
+			0xf2, 0x47, 0x3a, 0x0f, 0x35, 0x90, 0x2d, 0x94, 0xb2, 0xa4, 0x49, 0xbc, 0xfb, 0x27, 0x33,
+			0x8a, 0x03, 0xc8, 0xa8, 0xc3, 0x19, 0x61, 0xb6, 0x1b, 0xb8, 0x92, 0x4e, 0xb3, 0xc6, 0x33,
+			0x3a, 0x62, 0xf2, 0x22, 0x6b, 0xf9, 0xfa, 0x32, 0x06, 0x68, 0x51, 0x3f, 0x57, 0x68, 0xe0,
+			0x53, 0xcf, 0xc8, 0xe0, 0x0e, 0x3c, 0x50, 0x8d, 0x52, 0x9b, 0x80, 0x60, 0x9c, 0xef, 0xad,
+			0x64, 0x21, 0x27, 0x87, 0x14, 0xed, 0x5a, 0x9d, 0xc1, 0x2d, 0x30, 0x86, 0x5d, 0xe4, 0xa9,
+			0x10, 0x9a, 0x44, 0x8d, 0x9c, 0xba, 0x0e, 0xa0, 0xbe, 0x4e, 0x4e, 0x07, 0xe8, 0x59, 0xe3,
+			0x32, 0x31, 0xb0, 0xee, 0xae, 0x62, 0x5c, 0xd3, 0x0d, 0xce, 0x50, 0x31, 0x0c, 0xf2, 0xb5,
+			0x72, 0x54, 0x86, 0xa4, 0x75, 0x0f, 0x82, 0x0c, 0xef, 0x7b, 0xf1, 0x10, 0x0f, 0x75, 0x57,
+			0x4d, 0x6c, 0x30, 0xdf, 0x34, 0x91, 0xc1, 0xec, 0x45, 0x75, 0x67, 0xba, 0xc8, 0x48, 0xbc,
+			0x3b, 0x9b,
+		},
+		.len = 256,
+	},
+
+
+	// 2
+	{
+		.e1 = {0x01, 0x00, 0x01},
+		.e2 = {
+			0x93, 0x32, 0xa1, 0xc0, 0x9f, 0xda, 0x89, 0x28, 0x69, 0x30, 0x34, 0x8a, 0x5e, 0x1e,
+			0xed, 0x56, 0xf9, 0x1e, 0xbd, 0x50, 0xfd, 0x7a, 0x35, 0xa0, 0x70, 0x04, 0x18, 0xbc, 0x79,
+			0x71, 0xc1, 0xdb, 0x31, 0xca, 0x3b, 0x69, 0xe3, 0x31, 0xa0, 0x77, 0x75, 0xa8, 0xcc, 0x52,
+			0x2d, 0x76, 0x0f, 0xda, 0x27, 0xcd, 0x70, 0xeb, 0x60, 0x66, 0xae, 0x38, 0xf4, 0xac, 0xc7,
+			0x2c, 0x2d, 0x3d, 0xab, 0x08, 0x3a, 0xdc, 0x4c, 0xe7, 0x48, 0xc4, 0x81, 0xe9, 0xd4, 0xc6,
+			0xe2, 0x61, 0xce, 0x30, 0x4b, 0x88, 0x7c, 0xb2, 0xaa, 0x55, 0x6f, 0xef, 0xa0, 0x7d, 0x1e,
+			0x1e, 0x8a, 0x99, 0x84, 0x97, 0x8f, 0x27, 0xea, 0xb6, 0xba, 0x39, 0xd2, 0x59, 0x90, 0x65,
+			0xef, 0xb1, 0xcd, 0xa0, 0xae, 0x34, 0xf1, 0x64, 0xd2, 0x7b, 0xa9, 0xe8, 0x12, 0xc5, 0x47,
+			0x2f, 0xf6, 0x15, 0xff, 0xe9, 0x53, 0xbd, 0xa7, 0xe4, 0x5c, 0x65, 0x37, 0xea, 0xa8, 0xab,
+			0xb2, 0x38, 0x0b, 0x73, 0xbc, 0xb8, 0x13, 0xea, 0xb8, 0x50, 0x72, 0x9a, 0x68, 0x3a, 0x09,
+			0x3c, 0x79, 0x0e, 0x62, 0xef, 0xae, 0x95, 0xe7, 0x4e, 0xb3, 0x96, 0x9a, 0xe0, 0x90, 0xc0,
+			0xb5, 0xb5, 0xae, 0x24, 0x38, 0xf0, 0x8a, 0x6a, 0xbc, 0x50, 0xe0, 0x16, 0xcf, 0xfd, 0x9e,
+			0x63, 0xc7, 0xd2, 0x88, 0xd2, 0x49, 0xdf, 0x61, 0xdb, 0xea, 0xca, 0xac, 0x3a, 0x07, 0xbc,
+			0x20, 0xda, 0x69, 0xe8, 0x5a, 0x8b, 0xca, 0xf8, 0x5d, 0xf3, 0xab, 0xcd, 0x7b, 0x8c, 0xd9,
+			0x8c, 0x16, 0xa5, 0x0d, 0xfc, 0x0a, 0x81, 0x5e, 0x66, 0x50, 0x05, 0x27, 0xa4, 0x68, 0x9a,
+			0x19, 0xee, 0xa1, 0x2e, 0xc0, 0x61, 0x08, 0xec, 0x76, 0x60, 0x67, 0x15, 0x84, 0x03, 0x48,
+			0xfa, 0xcb, 0xc8, 0xf4, 0xef, 0x71, 0xff, 0x46, 0x49, 0x98, 0x87, 0x87, 0xa2, 0x0e, 0xda,
+			0xf4, 0xb9,
+		},
+		.n  = {
+			0xbb, 0x4c, 0xdf, 0x2f, 0xce, 0xe8, 0x82, 0x8e, 0x97, 0xa1, 0x3b, 0xb1, 0x38, 0xfb,
+			0x66, 0x53, 0x2f, 0xcf, 0x0b, 0x37, 0x82, 0x20, 0x36, 0xaf, 0xfd, 0x65, 0xee, 0x7a, 0x2c,
+			0x51, 0x31, 0x5d, 0x9d, 0x95, 0x59, 0xf0, 0x98, 0x45, 0x3e, 0xec, 0xf2, 0xf9, 0x50, 0x91,
+			0xe6, 0x58, 0x12, 0x69, 0x52, 0x24, 0xc6, 0x48, 0x6c, 0xd7, 0x87, 0x79, 0xe4, 0xb3, 0x87,
+			0x9f, 0x32, 0xdf, 0x05, 0xd6, 0xf6, 0xc3, 0x3e, 0xe8, 0x7e, 0x4e, 0x79, 0xd5, 0xfe, 0x62,
+			0x19, 0xf5, 0x74, 0xa6, 0x8e, 0x72, 0x03, 0x11, 0x46, 0xf9, 0x04, 0x97, 0xcc, 0x40, 0x82,
+			0x3e, 0x10, 0x5a, 0x56, 0x7a, 0xef, 0xb8, 0x28, 0x45, 0xf7, 0xc8, 0x1d, 0xa3, 0xee, 0xa4,
+			0x12, 0xb5, 0x0e, 0xdb, 0xe1, 0x1c, 0xb3, 0xb7, 0xde, 0x7b, 0x6a, 0xb0, 0x29, 0xfa, 0x09,
+			0x0a, 0xd6, 0x39, 0x42, 0x46, 0xdd, 0xb9, 0x5e, 0x72, 0xfe, 0x69, 0xf3, 0x27, 0xf0, 0x0f,
+			0x6d, 0x42, 0xef, 0x81, 0xa1, 0x15, 0xc9, 0xed, 0xa3, 0x30, 0x14, 0xef, 0x76, 0x5e, 0xdd,
+			0xb8, 0xa4, 0x5c, 0x71, 0x7a, 0xdf, 0x40, 0x66, 0x06, 0x3f, 0x80, 0x42, 0x2a, 0x4a, 0x90,
+			0xe2, 0xa8, 0xeb, 0x9a, 0x51, 0x50, 0x10, 0x69, 0x92, 0x37, 0xca, 0x90, 0xce, 0x62, 0xe1,
+			0x39, 0x27, 0x7a, 0xe2, 0x41, 0x66, 0x95, 0x16, 0xbc, 0x5e, 0x62, 0x69, 0x80, 0xc1, 0x80,
+			0x56, 0x8b, 0x12, 0x7d, 0x16, 0x85, 0xea, 0x93, 0x54, 0xe5, 0x63, 0xed, 0xac, 0x31, 0xe6,
+			0x57, 0x2e, 0xd1, 0x35, 0xd1, 0x4c, 0xed, 0x99, 0x38, 0x8f, 0xf5, 0x09, 0x92, 0x85, 0xe2,
+			0xd8, 0x67, 0x01, 0x23, 0x26, 0xae, 0x59, 0x35, 0x2b, 0x2c, 0x09, 0xef, 0xf8, 0xe3, 0x1f,
+			0xc7, 0x5f, 0x92, 0x19, 0x6e, 0x21, 0x87, 0x38, 0x40, 0x43, 0x0b, 0x02, 0x6c, 0x72, 0x6e,
+			0xcc, 0xb3,
+		},
+		.len = 256,
+
+	},
+
+	// 3
+	{
+		.e2 = {0x01, 0x00, 0x01},
+		.e1 = {
+			0x93, 0x32, 0xa1, 0xc0, 0x9f, 0xda, 0x89, 0x28, 0x69, 0x30, 0x34, 0x8a, 0x5e, 0x1e,
+			0xed, 0x56, 0xf9, 0x1e, 0xbd, 0x50, 0xfd, 0x7a, 0x35, 0xa0, 0x70, 0x04, 0x18, 0xbc, 0x79,
+			0x71, 0xc1, 0xdb, 0x31, 0xca, 0x3b, 0x69, 0xe3, 0x31, 0xa0, 0x77, 0x75, 0xa8, 0xcc, 0x52,
+			0x2d, 0x76, 0x0f, 0xda, 0x27, 0xcd, 0x70, 0xeb, 0x60, 0x66, 0xae, 0x38, 0xf4, 0xac, 0xc7,
+			0x2c, 0x2d, 0x3d, 0xab, 0x08, 0x3a, 0xdc, 0x4c, 0xe7, 0x48, 0xc4, 0x81, 0xe9, 0xd4, 0xc6,
+			0xe2, 0x61, 0xce, 0x30, 0x4b, 0x88, 0x7c, 0xb2, 0xaa, 0x55, 0x6f, 0xef, 0xa0, 0x7d, 0x1e,
+			0x1e, 0x8a, 0x99, 0x84, 0x97, 0x8f, 0x27, 0xea, 0xb6, 0xba, 0x39, 0xd2, 0x59, 0x90, 0x65,
+			0xef, 0xb1, 0xcd, 0xa0, 0xae, 0x34, 0xf1, 0x64, 0xd2, 0x7b, 0xa9, 0xe8, 0x12, 0xc5, 0x47,
+			0x2f, 0xf6, 0x15, 0xff, 0xe9, 0x53, 0xbd, 0xa7, 0xe4, 0x5c, 0x65, 0x37, 0xea, 0xa8, 0xab,
+			0xb2, 0x38, 0x0b, 0x73, 0xbc, 0xb8, 0x13, 0xea, 0xb8, 0x50, 0x72, 0x9a, 0x68, 0x3a, 0x09,
+			0x3c, 0x79, 0x0e, 0x62, 0xef, 0xae, 0x95, 0xe7, 0x4e, 0xb3, 0x96, 0x9a, 0xe0, 0x90, 0xc0,
+			0xb5, 0xb5, 0xae, 0x24, 0x38, 0xf0, 0x8a, 0x6a, 0xbc, 0x50, 0xe0, 0x16, 0xcf, 0xfd, 0x9e,
+			0x63, 0xc7, 0xd2, 0x88, 0xd2, 0x49, 0xdf, 0x61, 0xdb, 0xea, 0xca, 0xac, 0x3a, 0x07, 0xbc,
+			0x20, 0xda, 0x69, 0xe8, 0x5a, 0x8b, 0xca, 0xf8, 0x5d, 0xf3, 0xab, 0xcd, 0x7b, 0x8c, 0xd9,
+			0x8c, 0x16, 0xa5, 0x0d, 0xfc, 0x0a, 0x81, 0x5e, 0x66, 0x50, 0x05, 0x27, 0xa4, 0x68, 0x9a,
+			0x19, 0xee, 0xa1, 0x2e, 0xc0, 0x61, 0x08, 0xec, 0x76, 0x60, 0x67, 0x15, 0x84, 0x03, 0x48,
+			0xfa, 0xcb, 0xc8, 0xf4, 0xef, 0x71, 0xff, 0x46, 0x49, 0x98, 0x87, 0x87, 0xa2, 0x0e, 0xda,
+			0xf4, 0xb9,
+		},
+		.n	= {
+			0xbb, 0x4c, 0xdf, 0x2f, 0xce, 0xe8, 0x82, 0x8e, 0x97, 0xa1, 0x3b, 0xb1, 0x38, 0xfb,
+			0x66, 0x53, 0x2f, 0xcf, 0x0b, 0x37, 0x82, 0x20, 0x36, 0xaf, 0xfd, 0x65, 0xee, 0x7a, 0x2c,
+			0x51, 0x31, 0x5d, 0x9d, 0x95, 0x59, 0xf0, 0x98, 0x45, 0x3e, 0xec, 0xf2, 0xf9, 0x50, 0x91,
+			0xe6, 0x58, 0x12, 0x69, 0x52, 0x24, 0xc6, 0x48, 0x6c, 0xd7, 0x87, 0x79, 0xe4, 0xb3, 0x87,
+			0x9f, 0x32, 0xdf, 0x05, 0xd6, 0xf6, 0xc3, 0x3e, 0xe8, 0x7e, 0x4e, 0x79, 0xd5, 0xfe, 0x62,
+			0x19, 0xf5, 0x74, 0xa6, 0x8e, 0x72, 0x03, 0x11, 0x46, 0xf9, 0x04, 0x97, 0xcc, 0x40, 0x82,
+			0x3e, 0x10, 0x5a, 0x56, 0x7a, 0xef, 0xb8, 0x28, 0x45, 0xf7, 0xc8, 0x1d, 0xa3, 0xee, 0xa4,
+			0x12, 0xb5, 0x0e, 0xdb, 0xe1, 0x1c, 0xb3, 0xb7, 0xde, 0x7b, 0x6a, 0xb0, 0x29, 0xfa, 0x09,
+			0x0a, 0xd6, 0x39, 0x42, 0x46, 0xdd, 0xb9, 0x5e, 0x72, 0xfe, 0x69, 0xf3, 0x27, 0xf0, 0x0f,
+			0x6d, 0x42, 0xef, 0x81, 0xa1, 0x15, 0xc9, 0xed, 0xa3, 0x30, 0x14, 0xef, 0x76, 0x5e, 0xdd,
+			0xb8, 0xa4, 0x5c, 0x71, 0x7a, 0xdf, 0x40, 0x66, 0x06, 0x3f, 0x80, 0x42, 0x2a, 0x4a, 0x90,
+			0xe2, 0xa8, 0xeb, 0x9a, 0x51, 0x50, 0x10, 0x69, 0x92, 0x37, 0xca, 0x90, 0xce, 0x62, 0xe1,
+			0x39, 0x27, 0x7a, 0xe2, 0x41, 0x66, 0x95, 0x16, 0xbc, 0x5e, 0x62, 0x69, 0x80, 0xc1, 0x80,
+			0x56, 0x8b, 0x12, 0x7d, 0x16, 0x85, 0xea, 0x93, 0x54, 0xe5, 0x63, 0xed, 0xac, 0x31, 0xe6,
+			0x57, 0x2e, 0xd1, 0x35, 0xd1, 0x4c, 0xed, 0x99, 0x38, 0x8f, 0xf5, 0x09, 0x92, 0x85, 0xe2,
+			0xd8, 0x67, 0x01, 0x23, 0x26, 0xae, 0x59, 0x35, 0x2b, 0x2c, 0x09, 0xef, 0xf8, 0xe3, 0x1f,
+			0xc7, 0x5f, 0x92, 0x19, 0x6e, 0x21, 0x87, 0x38, 0x40, 0x43, 0x0b, 0x02, 0x6c, 0x72, 0x6e,
+			0xcc, 0xb3,
+		},
+		.len = 256,
+
+	},
+#if 1
+	// 4
+	{
+		.e1 = {
+			0x01,0x00,0x01,
+		},
+		.e2 = {
+			0x75, 0xd5, 0x82, 0xa1, 0x8b, 0x10, 0x3f, 0xe6, 0xf0, 0x01, 0x4d, 0x46, 0xa0, 0xc1, 0x58,
+			0xcc, 0x6b, 0xa0, 0x32, 0xab, 0xc7, 0x9c, 0x80, 0xc3, 0x5d, 0xdf, 0xb1, 0x77, 0x11, 0xef,
+			0x50, 0xd9, 0xb9, 0x5f, 0x40, 0xe2, 0xdc, 0xd2, 0x9b, 0xb0, 0xed, 0xd5, 0xd4, 0x00, 0x0b,
+			0x55, 0x84, 0xad, 0xe6, 0x54, 0x28, 0x8d, 0x88, 0x30, 0xc4, 0xf5, 0x13, 0xbb, 0x83, 0x23,
+			0xcf, 0xbf, 0x65, 0xfe, 0x4c, 0xd2, 0x8e, 0xdf, 0x0a, 0xbd, 0x26, 0xae, 0x4d, 0x3c, 0x60,
+			0xc0, 0xcf, 0x5a, 0xcd, 0x2c, 0x9e, 0xd4, 0xa0, 0xc9, 0x23, 0x38, 0xa9, 0xd9, 0x4b, 0x1f,
+			0x45, 0x45, 0x40, 0x9b, 0xa5, 0xf7, 0xdf, 0x46, 0x01, 0x1a, 0x1b, 0xbe, 0x33, 0xa2, 0x00,
+			0x6f, 0xe8, 0x00, 0xf4, 0xd4, 0x33, 0x76, 0x6e, 0x0a, 0x9f, 0x4c, 0xd8, 0xd7, 0x89, 0x64,
+			0xe1, 0x2e, 0x83, 0xe1, 0x60, 0x9d, 0x3a, 0xc1,
+		},
+		.n = {
+			0xca, 0x2a, 0x28, 0x37, 0xb0, 0x80, 0xa3, 0xc9, 0x04, 0xac, 0x37, 0x76, 0x92, 0xfe,
+			0xf5, 0x4f, 0x24, 0xcd, 0xad, 0xb7, 0x3f, 0x6b, 0xa7, 0x14, 0x92, 0x69, 0xd7, 0xcb, 0x6d,
+			0x6f, 0x76, 0x45, 0xce, 0x8f, 0xa2, 0x30, 0x92, 0x82, 0x91, 0x1d, 0xd3, 0x88, 0x43, 0xf7,
+			0xdf, 0x7e, 0x5c, 0x8c, 0x16, 0x2e, 0xe4, 0x2d, 0xd1, 0x70, 0x33, 0x9d, 0xa6, 0x59, 0x15,
+			0xe0, 0x6d, 0x64, 0xdd, 0xc4, 0x06, 0x90, 0x1e, 0xc4, 0xcd, 0x44, 0xf3, 0x4c, 0x33, 0x5b,
+			0x0c, 0x97, 0x5d, 0x40, 0x2b, 0xca, 0x75, 0x16, 0x9a, 0x71, 0x5a, 0xfb, 0x22, 0x26, 0xcb,
+			0x47, 0xd0, 0x8b, 0x43, 0xd2, 0x9d, 0x53, 0x17, 0x6b, 0xe8, 0x7f, 0xc3, 0x3b, 0xe8, 0x67,
+			0x31, 0xe7, 0x33, 0xb3, 0xd7, 0x76, 0xc2, 0x58, 0xfa, 0x8c, 0x2b, 0x80, 0x17, 0x23, 0xef,
+			0x7e, 0x67, 0xdd, 0xee, 0xca, 0x8c, 0xa1, 0x22, 0xc7,
+		},
+		.len = 128,
+	},
+	{
+		.e2 = {
+			0x01,0x00,0x01,
+		},
+		.e1 = {
+			0x75, 0xd5, 0x82, 0xa1, 0x8b, 0x10, 0x3f, 0xe6, 0xf0, 0x01, 0x4d, 0x46, 0xa0, 0xc1, 0x58,
+			0xcc, 0x6b, 0xa0, 0x32, 0xab, 0xc7, 0x9c, 0x80, 0xc3, 0x5d, 0xdf, 0xb1, 0x77, 0x11, 0xef,
+			0x50, 0xd9, 0xb9, 0x5f, 0x40, 0xe2, 0xdc, 0xd2, 0x9b, 0xb0, 0xed, 0xd5, 0xd4, 0x00, 0x0b,
+			0x55, 0x84, 0xad, 0xe6, 0x54, 0x28, 0x8d, 0x88, 0x30, 0xc4, 0xf5, 0x13, 0xbb, 0x83, 0x23,
+			0xcf, 0xbf, 0x65, 0xfe, 0x4c, 0xd2, 0x8e, 0xdf, 0x0a, 0xbd, 0x26, 0xae, 0x4d, 0x3c, 0x60,
+			0xc0, 0xcf, 0x5a, 0xcd, 0x2c, 0x9e, 0xd4, 0xa0, 0xc9, 0x23, 0x38, 0xa9, 0xd9, 0x4b, 0x1f,
+			0x45, 0x45, 0x40, 0x9b, 0xa5, 0xf7, 0xdf, 0x46, 0x01, 0x1a, 0x1b, 0xbe, 0x33, 0xa2, 0x00,
+			0x6f, 0xe8, 0x00, 0xf4, 0xd4, 0x33, 0x76, 0x6e, 0x0a, 0x9f, 0x4c, 0xd8, 0xd7, 0x89, 0x64,
+			0xe1, 0x2e, 0x83, 0xe1, 0x60, 0x9d, 0x3a, 0xc1,
+		},
+		.n = {
+			0xca, 0x2a, 0x28, 0x37, 0xb0, 0x80, 0xa3, 0xc9, 0x04, 0xac, 0x37, 0x76, 0x92, 0xfe,
+			0xf5, 0x4f, 0x24, 0xcd, 0xad, 0xb7, 0x3f, 0x6b, 0xa7, 0x14, 0x92, 0x69, 0xd7, 0xcb, 0x6d,
+			0x6f, 0x76, 0x45, 0xce, 0x8f, 0xa2, 0x30, 0x92, 0x82, 0x91, 0x1d, 0xd3, 0x88, 0x43, 0xf7,
+			0xdf, 0x7e, 0x5c, 0x8c, 0x16, 0x2e, 0xe4, 0x2d, 0xd1, 0x70, 0x33, 0x9d, 0xa6, 0x59, 0x15,
+			0xe0, 0x6d, 0x64, 0xdd, 0xc4, 0x06, 0x90, 0x1e, 0xc4, 0xcd, 0x44, 0xf3, 0x4c, 0x33, 0x5b,
+			0x0c, 0x97, 0x5d, 0x40, 0x2b, 0xca, 0x75, 0x16, 0x9a, 0x71, 0x5a, 0xfb, 0x22, 0x26, 0xcb,
+			0x47, 0xd0, 0x8b, 0x43, 0xd2, 0x9d, 0x53, 0x17, 0x6b, 0xe8, 0x7f, 0xc3, 0x3b, 0xe8, 0x67,
+			0x31, 0xe7, 0x33, 0xb3, 0xd7, 0x76, 0xc2, 0x58, 0xfa, 0x8c, 0x2b, 0x80, 0x17, 0x23, 0xef,
+			0x7e, 0x67, 0xdd, 0xee, 0xca, 0x8c, 0xa1, 0x22, 0xc7,
+		},
+		.len = 128,
+	},
+#endif
+	{
+		.e1 = {
+			0x01,0x00,0x01,
+		},
+		.e2 = {
+			0xab, 0x60, 0x07, 0x69, 0xf5, 0xe4, 0xc5, 0xa4, 0xda, 0x82, 0x36, 0x84, 0x09, 0xda,
+			0x93, 0x34, 0x6f, 0x96, 0xd0, 0x65, 0x94, 0x47, 0x92, 0x9e, 0xa4, 0xe9, 0xd7, 0x75, 0x7d,
+			0xd2, 0x96, 0x1a, 0xe2, 0xe9, 0xa0, 0x8a, 0xc8, 0x70, 0x5c, 0x9e, 0xde, 0x1a, 0xc6, 0xa3,
+			0xde, 0x25, 0x0f, 0x7f, 0xff, 0xd1, 0xed, 0xb1, 0x28, 0x14, 0x7e, 0x18, 0x85, 0xdf, 0xef,
+			0x83, 0x06, 0xed, 0xf5, 0x91,
+		},
+
+		.n = {
+			0xcc, 0x8c, 0xb4, 0x33, 0x16, 0x34, 0x9b, 0x94, 0xa7, 0xa7, 0x4e, 0xef, 0x45, 0xf2,
+			0x85, 0x7c, 0xd5, 0x53, 0xa4, 0x73, 0xb8, 0xf8, 0x4a, 0xec, 0xc5, 0x33, 0x66, 0x40, 0x5d,
+			0x6f, 0x09, 0xbf, 0xb3, 0x4d, 0x5f, 0x16, 0xb4, 0xe9, 0x48, 0x52, 0x64, 0x82, 0xc4, 0x24,
+			0x17, 0x94, 0x12, 0x1f, 0x66, 0x51, 0xea, 0x64, 0xc7, 0x7c, 0x15, 0x10, 0xa4, 0x2b, 0x0e,
+			0x83, 0xdc, 0x7e, 0x8d, 0xcd,
+		},
+		.len = 64,
+	},
+
+	{
+		.e2 = {
+			0x01,0x00,0x01,
+		},
+		.e1 = {
+			0xab, 0x60, 0x07, 0x69, 0xf5, 0xe4, 0xc5, 0xa4, 0xda, 0x82, 0x36, 0x84, 0x09, 0xda,
+			0x93, 0x34, 0x6f, 0x96, 0xd0, 0x65, 0x94, 0x47, 0x92, 0x9e, 0xa4, 0xe9, 0xd7, 0x75, 0x7d,
+			0xd2, 0x96, 0x1a, 0xe2, 0xe9, 0xa0, 0x8a, 0xc8, 0x70, 0x5c, 0x9e, 0xde, 0x1a, 0xc6, 0xa3,
+			0xde, 0x25, 0x0f, 0x7f, 0xff, 0xd1, 0xed, 0xb1, 0x28, 0x14, 0x7e, 0x18, 0x85, 0xdf, 0xef,
+			0x83, 0x06, 0xed, 0xf5, 0x91,
+		},
+
+		.n = {
+			0xcc, 0x8c, 0xb4, 0x33, 0x16, 0x34, 0x9b, 0x94, 0xa7, 0xa7, 0x4e, 0xef, 0x45, 0xf2,
+			0x85, 0x7c, 0xd5, 0x53, 0xa4, 0x73, 0xb8, 0xf8, 0x4a, 0xec, 0xc5, 0x33, 0x66, 0x40, 0x5d,
+			0x6f, 0x09, 0xbf, 0xb3, 0x4d, 0x5f, 0x16, 0xb4, 0xe9, 0x48, 0x52, 0x64, 0x82, 0xc4, 0x24,
+			0x17, 0x94, 0x12, 0x1f, 0x66, 0x51, 0xea, 0x64, 0xc7, 0x7c, 0x15, 0x10, 0xa4, 0x2b, 0x0e,
+			0x83, 0xdc, 0x7e, 0x8d, 0xcd,
+		},
+		.len = 64,
+	},
+	{
+		.e1 = {
+			0x01,0x00,0x01,
+		},
+		.e2 = {
+			0x94, 0x39, 0xa6, 0x92, 0xf7, 0x1c, 0x69, 0x15, 0x7c, 0x5c, 0x04, 0x58, 0xbc, 0x4f,
+			0x6f, 0xc9, 0x4f, 0x0a, 0x5c, 0xee, 0xd9, 0xa1, 0x62, 0x06, 0x98, 0x40, 0x00, 0x80, 0x72,
+			0xb8, 0xe1, 0xa1,
+		},
+		.n = {
+			0xc2, 0xad, 0x8d, 0xd5, 0x01, 0x85, 0x40, 0x7e, 0x46, 0xa1, 0xdd, 0xd8, 0x8d, 0x06,
+			0x39, 0x41, 0x58, 0xbd, 0x2e, 0x4c, 0x27, 0xd1, 0xd9, 0x04, 0xd5, 0x24, 0x3b, 0x59, 0x7a,
+			0x4c, 0xaa, 0x0d,
+		},
+		.len = 32,
+	},
+
+	{
+		.e2 = {
+			0x01,0x00,0x01,
+		},
+		.e1 = {
+			0x94, 0x39, 0xa6, 0x92, 0xf7, 0x1c, 0x69, 0x15, 0x7c, 0x5c, 0x04, 0x58, 0xbc, 0x4f,
+			0x6f, 0xc9, 0x4f, 0x0a, 0x5c, 0xee, 0xd9, 0xa1, 0x62, 0x06, 0x98, 0x40, 0x00, 0x80, 0x72,
+			0xb8, 0xe1, 0xa1,
+		},
+		.n = {
+			0xc2, 0xad, 0x8d, 0xd5, 0x01, 0x85, 0x40, 0x7e, 0x46, 0xa1, 0xdd, 0xd8, 0x8d, 0x06,
+			0x39, 0x41, 0x58, 0xbd, 0x2e, 0x4c, 0x27, 0xd1, 0xd9, 0x04, 0xd5, 0x24, 0x3b, 0x59, 0x7a,
+			0x4c, 0xaa, 0x0d,
+		},
+		.len = 32,
+	},
+	{
+		.e1 = {
+			0x29, 0x99, 0x7d, 0x25,
+		},
+
+		.e2 = {
+			0xb7, 0x7b, 0x10, 0x49, 0x2c, 0x0a, 0xfd, 0x82, 0xcd, 0x8c, 0xf8, 0x4f, 0x8e, 0xd5,
+			0x79, 0x45, 0x0c, 0x76, 0xbe, 0x83, 0xae, 0xef, 0xb5, 0xad, 0x87, 0x8c, 0x80, 0x66, 0xea,
+			0xdd, 0xb3, 0x38, 0x2c, 0x28, 0x15, 0xdd, 0xfb, 0x2a, 0x52, 0x40, 0xb0, 0xcb, 0x06, 0xdf,
+			0x3a, 0x21, 0x72, 0x28, 0xdb, 0x78, 0xba, 0x4b, 0xe9, 0x5c, 0x3c, 0x0f, 0x12, 0x90, 0x85,
+			0xd0, 0xe8, 0x84, 0xfe, 0x9a, 0x20, 0x5f, 0x59, 0x16, 0xc2, 0xdd, 0x2a, 0x32, 0x32, 0x66,
+			0x83, 0x22, 0xf7, 0x81, 0x6f, 0xc1, 0x4d, 0x1a, 0x08, 0xb3, 0xb2, 0x98, 0xb8, 0xc0, 0xa1,
+			0x0a, 0x6d, 0x73, 0x99, 0xfb, 0x38, 0x95, 0xc7, 0x61, 0xfa, 0xea, 0xdb, 0x3e, 0x5c, 0x96,
+			0xce, 0x17, 0xca, 0xad, 0x88, 0x85, 0xb8, 0x72, 0xcc, 0xa4, 0xa8, 0x32, 0xb3, 0x19, 0xf7,
+			0xa9, 0x1f, 0xcd, 0xa0, 0x5f, 0x28, 0x26, 0xab, 0xc1, 0x02, 0xcc, 0xa4, 0x29, 0x4a, 0x6e,
+			0xdf, 0x57, 0x46, 0x0f, 0x7f, 0xa7, 0xbe, 0xef, 0x07, 0x92, 0xb6, 0xe5, 0x39, 0xa1, 0x42,
+			0x35, 0x26, 0x9b, 0x6f, 0xd6, 0x9f, 0xc6, 0x0f, 0x57, 0xfa, 0xc1, 0x7c, 0xf5, 0x6d, 0x66,
+			0x7d, 0x22, 0xf4, 0x4a, 0xc0, 0x63, 0x5f, 0xb2, 0x2b, 0xea, 0x37, 0xf6, 0x80, 0xce, 0x6e,
+			0xf1, 0x4c, 0x1d, 0xab, 0x86, 0x4b, 0x72, 0x62, 0xb5, 0xb1, 0x71, 0x8b, 0x75, 0xff, 0xd0,
+			0x24, 0x5e, 0xa8, 0x97, 0x92, 0x5f, 0xbd, 0xb8, 0x39, 0x15, 0x0f, 0x26, 0x74, 0x1b, 0x78,
+			0x37, 0x16, 0xb1, 0xee, 0xd1, 0x80, 0xe8, 0x61, 0xe3, 0x5a, 0x72, 0x12, 0x6d, 0x38, 0x44,
+			0x80, 0x00, 0x51, 0xa1, 0x92, 0x8c, 0x9b, 0x60, 0x63, 0x19, 0x09, 0x16, 0x0e, 0xda, 0x34,
+			0x1e, 0x69, 0x31, 0xc3, 0x2a, 0xa9, 0x9a, 0xaf, 0x0f, 0x36, 0xcc, 0x38, 0xde, 0x2e, 0xb6,
+			0x0a, 0xe9,
+		},
+		.n = {
+			0xe4, 0x8b, 0xb8, 0x04, 0x9c, 0x4c, 0xfd, 0xa2, 0x0c, 0x2c, 0xb2, 0x21, 0xa1, 0x79,
+			0xbd, 0xd0, 0x67, 0xfa, 0x19, 0xd5, 0xd7, 0x7e, 0x2e, 0x63, 0xe3, 0x4a, 0xf8, 0x0f, 0x3c,
+			0x21, 0x86, 0x20, 0xee, 0x79, 0x3d, 0xf9, 0x3f, 0x4d, 0x88, 0xfe, 0x54, 0xee, 0xde, 0x18,
+			0xf1, 0x20, 0x06, 0xa7, 0x60, 0x8e, 0x68, 0x5b, 0x83, 0x65, 0x19, 0xa3, 0xc2, 0x26, 0xa8,
+			0xbb, 0xd7, 0xa6, 0x04, 0x99, 0x67, 0x87, 0xec, 0xc3, 0x57, 0x37, 0x9f, 0xb9, 0xc3, 0xd7,
+			0x3d, 0xc5, 0x17, 0x4e, 0x0b, 0x67, 0xcd, 0x70, 0x82, 0x24, 0x31, 0x0e, 0x83, 0xab, 0xa0,
+			0xd4, 0x63, 0xc1, 0xed, 0x95, 0xf4, 0x04, 0xdf, 0xc0, 0x45, 0x3b, 0xfe, 0xe7, 0xa6, 0x17,
+			0x7d, 0x3c, 0xb3, 0xfb, 0x72, 0xff, 0x46, 0x99, 0xe4, 0x95, 0xe1, 0xad, 0xb8, 0x41, 0x5b,
+			0x75, 0xa4, 0x5f, 0xba, 0xb2, 0xbc, 0xe6, 0xfe, 0x4b, 0x74, 0x07, 0xe6, 0xfc, 0xf0, 0xb2,
+			0xe1, 0x0e, 0x63, 0x65, 0x41, 0x55, 0x66, 0xc2, 0xc4, 0x4a, 0xa8, 0x4d, 0x0c, 0x2d, 0xd3,
+			0x37, 0x62, 0x4b, 0x1a, 0x00, 0x98, 0xc7, 0x63, 0xea, 0x04, 0xf7, 0xff, 0x0c, 0xff, 0x50,
+			0x48, 0x2e, 0x99, 0x50, 0x8a, 0xaf, 0x23, 0x3f, 0xff, 0x05, 0x0d, 0x0b, 0xa1, 0xf4, 0x2d,
+			0xd3, 0x0a, 0xfd, 0xf7, 0x08, 0xfc, 0x84, 0xc4, 0xdf, 0x6a, 0xc9, 0xd1, 0x1d, 0xba, 0xb5,
+			0x28, 0xd4, 0x4a, 0x7c, 0x83, 0x99, 0x04, 0xbe, 0x96, 0x97, 0x21, 0x3c, 0xa9, 0xf0, 0xff,
+			0xbe, 0xcd, 0xc8, 0x4d, 0x10, 0x9b, 0x9c, 0xf1, 0x63, 0x68, 0xf2, 0x22, 0x03, 0xce, 0xc7,
+			0x80, 0x50, 0x1f, 0xdb, 0xdd, 0x41, 0x10, 0x59, 0xe0, 0x12, 0xa4, 0xc4, 0x46, 0x47, 0x62,
+			0xa3, 0xe0, 0x14, 0x19, 0xe6, 0x80, 0x2b, 0x28, 0x42, 0x85, 0x69, 0x34, 0xe0, 0x55, 0xb8,
+			0x5f, 0x0b,
+		},
+		.len  = 256,
+	},
+	{
+			.e2 = {
+				0x29, 0x99, 0x7d, 0x25,
+			},
+
+			.e1 = {
+				0xb7, 0x7b, 0x10, 0x49, 0x2c, 0x0a, 0xfd, 0x82, 0xcd, 0x8c, 0xf8, 0x4f, 0x8e, 0xd5,
+				0x79, 0x45, 0x0c, 0x76, 0xbe, 0x83, 0xae, 0xef, 0xb5, 0xad, 0x87, 0x8c, 0x80, 0x66, 0xea,
+				0xdd, 0xb3, 0x38, 0x2c, 0x28, 0x15, 0xdd, 0xfb, 0x2a, 0x52, 0x40, 0xb0, 0xcb, 0x06, 0xdf,
+				0x3a, 0x21, 0x72, 0x28, 0xdb, 0x78, 0xba, 0x4b, 0xe9, 0x5c, 0x3c, 0x0f, 0x12, 0x90, 0x85,
+				0xd0, 0xe8, 0x84, 0xfe, 0x9a, 0x20, 0x5f, 0x59, 0x16, 0xc2, 0xdd, 0x2a, 0x32, 0x32, 0x66,
+				0x83, 0x22, 0xf7, 0x81, 0x6f, 0xc1, 0x4d, 0x1a, 0x08, 0xb3, 0xb2, 0x98, 0xb8, 0xc0, 0xa1,
+				0x0a, 0x6d, 0x73, 0x99, 0xfb, 0x38, 0x95, 0xc7, 0x61, 0xfa, 0xea, 0xdb, 0x3e, 0x5c, 0x96,
+				0xce, 0x17, 0xca, 0xad, 0x88, 0x85, 0xb8, 0x72, 0xcc, 0xa4, 0xa8, 0x32, 0xb3, 0x19, 0xf7,
+				0xa9, 0x1f, 0xcd, 0xa0, 0x5f, 0x28, 0x26, 0xab, 0xc1, 0x02, 0xcc, 0xa4, 0x29, 0x4a, 0x6e,
+				0xdf, 0x57, 0x46, 0x0f, 0x7f, 0xa7, 0xbe, 0xef, 0x07, 0x92, 0xb6, 0xe5, 0x39, 0xa1, 0x42,
+				0x35, 0x26, 0x9b, 0x6f, 0xd6, 0x9f, 0xc6, 0x0f, 0x57, 0xfa, 0xc1, 0x7c, 0xf5, 0x6d, 0x66,
+				0x7d, 0x22, 0xf4, 0x4a, 0xc0, 0x63, 0x5f, 0xb2, 0x2b, 0xea, 0x37, 0xf6, 0x80, 0xce, 0x6e,
+				0xf1, 0x4c, 0x1d, 0xab, 0x86, 0x4b, 0x72, 0x62, 0xb5, 0xb1, 0x71, 0x8b, 0x75, 0xff, 0xd0,
+				0x24, 0x5e, 0xa8, 0x97, 0x92, 0x5f, 0xbd, 0xb8, 0x39, 0x15, 0x0f, 0x26, 0x74, 0x1b, 0x78,
+				0x37, 0x16, 0xb1, 0xee, 0xd1, 0x80, 0xe8, 0x61, 0xe3, 0x5a, 0x72, 0x12, 0x6d, 0x38, 0x44,
+				0x80, 0x00, 0x51, 0xa1, 0x92, 0x8c, 0x9b, 0x60, 0x63, 0x19, 0x09, 0x16, 0x0e, 0xda, 0x34,
+				0x1e, 0x69, 0x31, 0xc3, 0x2a, 0xa9, 0x9a, 0xaf, 0x0f, 0x36, 0xcc, 0x38, 0xde, 0x2e, 0xb6,
+				0x0a, 0xe9,
+			},
+			.n = {
+				0xe4, 0x8b, 0xb8, 0x04, 0x9c, 0x4c, 0xfd, 0xa2, 0x0c, 0x2c, 0xb2, 0x21, 0xa1, 0x79,
+				0xbd, 0xd0, 0x67, 0xfa, 0x19, 0xd5, 0xd7, 0x7e, 0x2e, 0x63, 0xe3, 0x4a, 0xf8, 0x0f, 0x3c,
+				0x21, 0x86, 0x20, 0xee, 0x79, 0x3d, 0xf9, 0x3f, 0x4d, 0x88, 0xfe, 0x54, 0xee, 0xde, 0x18,
+				0xf1, 0x20, 0x06, 0xa7, 0x60, 0x8e, 0x68, 0x5b, 0x83, 0x65, 0x19, 0xa3, 0xc2, 0x26, 0xa8,
+				0xbb, 0xd7, 0xa6, 0x04, 0x99, 0x67, 0x87, 0xec, 0xc3, 0x57, 0x37, 0x9f, 0xb9, 0xc3, 0xd7,
+				0x3d, 0xc5, 0x17, 0x4e, 0x0b, 0x67, 0xcd, 0x70, 0x82, 0x24, 0x31, 0x0e, 0x83, 0xab, 0xa0,
+				0xd4, 0x63, 0xc1, 0xed, 0x95, 0xf4, 0x04, 0xdf, 0xc0, 0x45, 0x3b, 0xfe, 0xe7, 0xa6, 0x17,
+				0x7d, 0x3c, 0xb3, 0xfb, 0x72, 0xff, 0x46, 0x99, 0xe4, 0x95, 0xe1, 0xad, 0xb8, 0x41, 0x5b,
+				0x75, 0xa4, 0x5f, 0xba, 0xb2, 0xbc, 0xe6, 0xfe, 0x4b, 0x74, 0x07, 0xe6, 0xfc, 0xf0, 0xb2,
+				0xe1, 0x0e, 0x63, 0x65, 0x41, 0x55, 0x66, 0xc2, 0xc4, 0x4a, 0xa8, 0x4d, 0x0c, 0x2d, 0xd3,
+				0x37, 0x62, 0x4b, 0x1a, 0x00, 0x98, 0xc7, 0x63, 0xea, 0x04, 0xf7, 0xff, 0x0c, 0xff, 0x50,
+				0x48, 0x2e, 0x99, 0x50, 0x8a, 0xaf, 0x23, 0x3f, 0xff, 0x05, 0x0d, 0x0b, 0xa1, 0xf4, 0x2d,
+				0xd3, 0x0a, 0xfd, 0xf7, 0x08, 0xfc, 0x84, 0xc4, 0xdf, 0x6a, 0xc9, 0xd1, 0x1d, 0xba, 0xb5,
+				0x28, 0xd4, 0x4a, 0x7c, 0x83, 0x99, 0x04, 0xbe, 0x96, 0x97, 0x21, 0x3c, 0xa9, 0xf0, 0xff,
+				0xbe, 0xcd, 0xc8, 0x4d, 0x10, 0x9b, 0x9c, 0xf1, 0x63, 0x68, 0xf2, 0x22, 0x03, 0xce, 0xc7,
+				0x80, 0x50, 0x1f, 0xdb, 0xdd, 0x41, 0x10, 0x59, 0xe0, 0x12, 0xa4, 0xc4, 0x46, 0x47, 0x62,
+				0xa3, 0xe0, 0x14, 0x19, 0xe6, 0x80, 0x2b, 0x28, 0x42, 0x85, 0x69, 0x34, 0xe0, 0x55, 0xb8,
+				0x5f, 0x0b,
+			},
+			.len  = 256,
+		},
+
+#if 0
+	{
+		.e1 = {
+			0x01,0x00,0x01,
+		},
+		.e2 = {
+			0xa1, 0x04, 0x4b, 0x7e, 0x17, 0x03, 0x8a, 0x09, 0x39, 0xf8, 0xbc, 0xb2, 0xff, 0x09,
+			0xb2, 0xd9,
+		},
+		.n = {
+			0xa4, 0x05, 0x20, 0x85, 0xb4, 0xbb, 0x19, 0x5a, 0x13, 0x94, 0x77, 0xb7, 0xdb, 0x34,
+			0x67, 0x73,
+		},
+		.len = 16,
+	},
+
+	{
+		.e2 = {
+			0x01,0x00,0x01,
+		},
+		.e1 = {
+			0xa1, 0x04, 0x4b, 0x7e, 0x17, 0x03, 0x8a, 0x09, 0x39, 0xf8, 0xbc, 0xb2, 0xff, 0x09,
+			0xb2, 0xd9,
+		},
+		.n = {
+			0xa4, 0x05, 0x20, 0x85, 0xb4, 0xbb, 0x19, 0x5a, 0x13, 0x94, 0x77, 0xb7, 0xdb, 0x34,
+			0x67, 0x73,
+		},
+		.len = 16,
+	},
+
+	{
+		.e1 = {
+			0x01,0x00,0x01,
+		},
+		.e2 = {
+			0x9c, 0x65, 0xc7, 0x24, 0x11, 0xd6, 0xf0, 0xde, 0xce, 0x04, 0x43, 0x19, 0x78, 0x4c,
+			0x8f, 0xe9,
+		},
+		.n = {
+			0xa8, 0xab, 0x2f, 0x2d, 0x56, 0x33, 0x25, 0x16, 0xe5, 0xb4, 0x93, 0x71, 0xe9, 0xb4,
+			0xc2, 0x87,
+		},
+
+		.len = 16,
+	},
+
+	{
+		.e2 = {
+			0x01,0x00,0x01,
+		},
+		.e1 = {
+			0x9c, 0x65, 0xc7, 0x24, 0x11, 0xd6, 0xf0, 0xde, 0xce, 0x04, 0x43, 0x19, 0x78, 0x4c,
+			0x8f, 0xe9,
+		},
+		.n = {
+			0xa8, 0xab, 0x2f, 0x2d, 0x56, 0x33, 0x25, 0x16, 0xe5, 0xb4, 0x93, 0x71, 0xe9, 0xb4,
+			0xc2, 0x87,
+		},
+		.len = 16,
+	},
+	{
+		.e1 = {
+			0x01,0x00,0x01,
+		},
+		.e2 = {
+			0x57, 0xc9, 0x23, 0x38, 0xdb, 0x16, 0xc0, 0xb1,
+		},
+		.n = {
+			0x57, 0xc9, 0x23, 0x38, 0xdb, 0x16, 0xc0, 0xb1,
+		},
+		.len = 8,
+	},
+
+	{
+		.e2 = {
+			0x01,0x00,0x01,
+		},
+		.e1 = {
+			0x57, 0xc9, 0x23, 0x38, 0xdb, 0x16, 0xc0, 0xb1,
+		},
+		.n = {
+			0x57, 0xc9, 0x23, 0x38, 0xdb, 0x16, 0xc0, 0xb1,
+		},
+		.len = 8,
+	},
+#endif
+
+};
+
+
+/*c = m^e % n */
+#if 1
+char g_base[2048/8] = { 0xcd, 0xab, 0x23, 0x31, 0x02 };
+char g_exp[2048/8] = { 0x01, 0x00, 0x01 };
+char g_mode[] = { 0x4b, 0x86, 0xf8, 0x84, 0xfc, 0x68, 0xcc, 0xd2, 0x01, 0x14, 0xc7,
+			 0xcb, 0x34, 0x48, 0xf0, 0xce, 0x9e, 0xd9, 0xae, 0x02, 0x19, 0xee,
+			 0xe9, 0xaf, 0xb5, 0xcf, 0xcf, 0xba, 0xec, 0x39, 0x40, 0x03, 0xd2,
+			 0x61, 0x50, 0x1f, 0x25, 0x04, 0x82, 0x44, 0x98, 0x45, 0xef, 0xed,
+			 0xf5, 0xcd, 0x9d, 0x61, 0xa1, 0x30, 0x3e, 0xf6, 0x47, 0x37, 0x27,
+			 0x2d, 0x56, 0xed, 0x3a, 0xe0, 0x6a, 0x69, 0x8a, 0xe2, 0x00, 0x06,
+			 0x8d, 0x81, 0x07, 0x5e, 0xb0, 0xe9, 0xa1, 0x75, 0xf4, 0x62, 0x2f,
+			 0xfe, 0x84, 0xce, 0x29, 0x8f, 0x6a, 0xe2, 0x9b, 0x4a, 0x3a, 0x62,
+			 0xfc, 0x58, 0xb9, 0x6c, 0x0d, 0xd0, 0x18, 0x5d, 0x00, 0x13, 0xd4,
+			 0x8a, 0x80, 0xda, 0xe1, 0xfa, 0x04, 0x3e, 0xd7, 0x49, 0x17, 0x3d,
+			 0xdd, 0x2b, 0xa2, 0x22, 0x67, 0xf1, 0x8b, 0x5c, 0x79, 0x4d, 0x8e,
+			 0xc4, 0x21, 0x95, 0x79, 0x7a, 0x8c, 0xfd, 0xaa, 0x21, 0xa8, 0x70,
+			 0x6b, 0x67, 0x9a, 0x28, 0xf5, 0xda, 0x60, 0xa3, 0x5b, 0xcb, 0x75,
+			 0x10, 0xc6, 0x00, 0xae, 0x06, 0x5a, 0xf5, 0x0d, 0x62, 0x2e, 0x6b,
+			 0x29, 0xac, 0x28, 0x9a, 0x1e, 0x65, 0x55, 0xab, 0x52, 0x52, 0x9d,
+			 0xe1, 0xa7, 0xbd, 0xc2, 0x39, 0x7a, 0xab, 0x0e, 0xec, 0x5c, 0xe2,
+			 0xc5, 0xf2, 0x63, 0x3c, 0x05, 0x34, 0xd8, 0xa9, 0xec, 0xaf, 0xf1,
+			 0x8c, 0x14, 0xf7, 0xea, 0x89, 0x86, 0x8f, 0x50, 0x9f, 0xdc, 0x7b,
+			 0x21, 0x0c, 0x7f, 0x2a, 0xa4, 0x8f, 0x78, 0xcb, 0x07, 0x15, 0xb7,
+			 0x0f, 0xff, 0xd6, 0x61, 0x0c, 0x5e, 0xa8, 0x19, 0x46, 0x7b, 0xb9,
+			 0xa2, 0xea, 0x3d, 0xdb, 0xc7, 0x9f, 0x28, 0x86, 0x7e, 0x69, 0x6c,
+			 0xb3, 0x21, 0xa6, 0x59, 0x4a, 0x8a, 0x73, 0x4f, 0xab, 0xd6, 0x87,
+			 0x10, 0x0b, 0x7c, 0xa1, 0x2a, 0x70, 0xdd, 0xa6, 0xfc, 0x75, 0x09,
+			 0x97, 0x87, 0xc5 };
+#else
+char g_base[2048/8] = {
+	0x93, 0x8c, 0x57, 0x1c, 0xd9, 0x2c, 0xdd, 0x35, 0xd4, 0x3c, 0xec, 0x3e, 0x9e, 0x97, 0xd6, 0x44,
+	0x45, 0x83, 0x0d, 0xaf, 0x02, 0xbc, 0xc7, 0xd4, 0x03, 0x9b, 0x0c, 0x2c, 0x87, 0x0b, 0xea, 0xe3,
+	0xfd, 0x5b, 0x6d, 0x4c, 0x9d, 0xed, 0xde, 0x5d, 0x52, 0x9f, 0xb7, 0x0c, 0xdf, 0x53, 0xf7, 0xcf,
+	0x80, 0x8c, 0x88, 0xe7, 0xc1, 0x8c, 0x86, 0x18, 0xd2, 0xb0, 0x05, 0x62, 0xbe, 0xcf, 0xfa, 0x72,
+	0x92, 0xcf, 0x8a, 0x9d, 0x40, 0x5d, 0xf5, 0xcc, 0x37, 0xf0, 0x86, 0xb6, 0x91, 0x30, 0xb5, 0x3d,
+	0x25, 0x1a, 0xb6, 0x76, 0xe2, 0x6d, 0x7a, 0xf3, 0xb1, 0x71, 0xfe, 0xa6, 0x2e, 0x8c, 0xf5, 0xe8,
+	0x87, 0x0e, 0x1d, 0x6f, 0x00, 0xde, 0xcd, 0x79, 0x5a, 0x14, 0x30, 0x8b, 0xf4, 0x4f, 0x1c, 0x86,
+	0xb3, 0x6a, 0x4e, 0xe6, 0x7e, 0x61, 0xe5, 0xff, 0x87, 0x55, 0x0d, 0x82, 0xec, 0x0f, 0x00, 0x01,
+	0x39, 0xc5, 0xd9, 0x2f, 0x3c, 0x9f, 0xbb, 0xdb, 0x20, 0xc6, 0x9d, 0xc2, 0x0c, 0x7a, 0x96, 0xfd,
+};
+char g_exp[2048/8] = {
+	0x93, 0x32, 0xa1, 0xc0, 0x9f, 0xda, 0x89, 0x28, 0x69, 0x30, 0x34, 0x8a, 0x5e, 0x1e,
+	0xed, 0x56, 0xf9, 0x1e, 0xbd, 0x50, 0xfd, 0x7a, 0x35, 0xa0, 0x70, 0x04, 0x18, 0xbc, 0x79,
+	0x71, 0xc1, 0xdb, 0x31, 0xca, 0x3b, 0x69, 0xe3, 0x31, 0xa0, 0x77, 0x75, 0xa8, 0xcc, 0x52,
+	0x2d, 0x76, 0x0f, 0xda, 0x27, 0xcd, 0x70, 0xeb, 0x60, 0x66, 0xae, 0x38, 0xf4, 0xac, 0xc7,
+	0x2c, 0x2d, 0x3d, 0xab, 0x08, 0x3a, 0xdc, 0x4c, 0xe7, 0x48, 0xc4, 0x81, 0xe9, 0xd4, 0xc6,
+	0xe2, 0x61, 0xce, 0x30, 0x4b, 0x88, 0x7c, 0xb2, 0xaa, 0x55, 0x6f, 0xef, 0xa0, 0x7d, 0x1e,
+	0x1e, 0x8a, 0x99, 0x84, 0x97, 0x8f, 0x27, 0xea, 0xb6, 0xba, 0x39, 0xd2, 0x59, 0x90, 0x65,
+	0xef, 0xb1, 0xcd, 0xa0, 0xae, 0x34, 0xf1, 0x64, 0xd2, 0x7b, 0xa9, 0xe8, 0x12, 0xc5, 0x47,
+	0x2f, 0xf6, 0x15, 0xff, 0xe9, 0x53, 0xbd, 0xa7, 0xe4, 0x5c, 0x65, 0x37, 0xea, 0xa8, 0xab,
+	0xb2, 0x38, 0x0b, 0x73, 0xbc, 0xb8, 0x13, 0xea, 0xb8, 0x50, 0x72, 0x9a, 0x68, 0x3a, 0x09,
+	0x3c, 0x79, 0x0e, 0x62, 0xef, 0xae, 0x95, 0xe7, 0x4e, 0xb3, 0x96, 0x9a, 0xe0, 0x90, 0xc0,
+	0xb5, 0xb5, 0xae, 0x24, 0x38, 0xf0, 0x8a, 0x6a, 0xbc, 0x50, 0xe0, 0x16, 0xcf, 0xfd, 0x9e,
+	0x63, 0xc7, 0xd2, 0x88, 0xd2, 0x49, 0xdf, 0x61, 0xdb, 0xea, 0xca, 0xac, 0x3a, 0x07, 0xbc,
+	0x20, 0xda, 0x69, 0xe8, 0x5a, 0x8b, 0xca, 0xf8, 0x5d, 0xf3, 0xab, 0xcd, 0x7b, 0x8c, 0xd9,
+	0x8c, 0x16, 0xa5, 0x0d, 0xfc, 0x0a, 0x81, 0x5e, 0x66, 0x50, 0x05, 0x27, 0xa4, 0x68, 0x9a,
+	0x19, 0xee, 0xa1, 0x2e, 0xc0, 0x61, 0x08, 0xec, 0x76, 0x60, 0x67, 0x15, 0x84, 0x03, 0x48,
+	0xfa, 0xcb, 0xc8, 0xf4, 0xef, 0x71, 0xff, 0x46, 0x49, 0x98, 0x87, 0x87, 0xa2, 0x0e, 0xda,
+	0xf4, 0xb9
+};
+char g_mode[]	= {
+	0xbb, 0x4c, 0xdf, 0x2f, 0xce, 0xe8, 0x82, 0x8e, 0x97, 0xa1, 0x3b, 0xb1, 0x38, 0xfb,
+	0x66, 0x53, 0x2f, 0xcf, 0x0b, 0x37, 0x82, 0x20, 0x36, 0xaf, 0xfd, 0x65, 0xee, 0x7a, 0x2c,
+	0x51, 0x31, 0x5d, 0x9d, 0x95, 0x59, 0xf0, 0x98, 0x45, 0x3e, 0xec, 0xf2, 0xf9, 0x50, 0x91,
+	0xe6, 0x58, 0x12, 0x69, 0x52, 0x24, 0xc6, 0x48, 0x6c, 0xd7, 0x87, 0x79, 0xe4, 0xb3, 0x87,
+	0x9f, 0x32, 0xdf, 0x05, 0xd6, 0xf6, 0xc3, 0x3e, 0xe8, 0x7e, 0x4e, 0x79, 0xd5, 0xfe, 0x62,
+	0x19, 0xf5, 0x74, 0xa6, 0x8e, 0x72, 0x03, 0x11, 0x46, 0xf9, 0x04, 0x97, 0xcc, 0x40, 0x82,
+	0x3e, 0x10, 0x5a, 0x56, 0x7a, 0xef, 0xb8, 0x28, 0x45, 0xf7, 0xc8, 0x1d, 0xa3, 0xee, 0xa4,
+	0x12, 0xb5, 0x0e, 0xdb, 0xe1, 0x1c, 0xb3, 0xb7, 0xde, 0x7b, 0x6a, 0xb0, 0x29, 0xfa, 0x09,
+	0x0a, 0xd6, 0x39, 0x42, 0x46, 0xdd, 0xb9, 0x5e, 0x72, 0xfe, 0x69, 0xf3, 0x27, 0xf0, 0x0f,
+	0x6d, 0x42, 0xef, 0x81, 0xa1, 0x15, 0xc9, 0xed, 0xa3, 0x30, 0x14, 0xef, 0x76, 0x5e, 0xdd,
+	0xb8, 0xa4, 0x5c, 0x71, 0x7a, 0xdf, 0x40, 0x66, 0x06, 0x3f, 0x80, 0x42, 0x2a, 0x4a, 0x90,
+	0xe2, 0xa8, 0xeb, 0x9a, 0x51, 0x50, 0x10, 0x69, 0x92, 0x37, 0xca, 0x90, 0xce, 0x62, 0xe1,
+	0x39, 0x27, 0x7a, 0xe2, 0x41, 0x66, 0x95, 0x16, 0xbc, 0x5e, 0x62, 0x69, 0x80, 0xc1, 0x80,
+	0x56, 0x8b, 0x12, 0x7d, 0x16, 0x85, 0xea, 0x93, 0x54, 0xe5, 0x63, 0xed, 0xac, 0x31, 0xe6,
+	0x57, 0x2e, 0xd1, 0x35, 0xd1, 0x4c, 0xed, 0x99, 0x38, 0x8f, 0xf5, 0x09, 0x92, 0x85, 0xe2,
+	0xd8, 0x67, 0x01, 0x23, 0x26, 0xae, 0x59, 0x35, 0x2b, 0x2c, 0x09, 0xef, 0xf8, 0xe3, 0x1f,
+	0xc7, 0x5f, 0x92, 0x19, 0x6e, 0x21, 0x87, 0x38, 0x40, 0x43, 0x0b, 0x02, 0x6c, 0x72, 0x6e,
+	0xcc, 0xb3
+};
+#endif
+#if 0
+char g_p2[]= { 0x98, 0xe3, 0xf6, 0x3d, 0xa4, 0x56, 0xc2, 0xe3, 0xed, 0xf0,
+			   0x66, 0xdc, 0xc7, 0xf3, 0x60, 0x77, 0x1a, 0x57, 0x70, 0x85,
+			   0xc9, 0xcb, 0x79, 0x8b, 0x71, 0xcd, 0xcb, 0xc1, 0xba, 0xf2,
+			   0xb8, 0x1a, 0x2e, 0x8c, 0x3b, 0xf6, 0x6d, 0x6b, 0x92, 0x0d,
+			   0x8a, 0xed, 0x64, 0x2d, 0x8a, 0xe3, 0x23, 0x63, 0x68, 0xc0,
+			   0x58, 0xa6, 0xcd, 0xe2, 0x5c, 0xeb, 0xb3, 0xbd, 0xea, 0xd8,
+			   0x8a, 0x8f, 0x53, 0x66, 0xa8, 0x9b, 0x92, 0x7a, 0xc0, 0xd3,
+			   0x89, 0x28, 0xdd, 0x25, 0x81, 0xba, 0xb4, 0xd1, 0xbe, 0xd2,
+			   0xd0, 0xf0, 0x6e, 0x30, 0x25, 0x33, 0x3c, 0x13, 0x79, 0xc9,
+			   0xbb, 0x88, 0x81, 0x4b, 0x31, 0x17, 0x39, 0xb1, 0x43, 0xcb,
+			   0x28, 0x88, 0x08, 0xd8, 0x88, 0xcd, 0x71, 0x84, 0x1c, 0x1d,
+			   0x78, 0xf3, 0xe2, 0x43, 0x87, 0xff, 0x2e, 0x46, 0x01, 0x8e,
+			   0xc6, 0x24, 0xbc, 0x46, 0x0e, 0x9f, 0x50, 0x5e, 0x9b, 0xba,
+			   0xd7, 0x81, 0x17, 0x7f, 0xfd, 0x0f, 0x03, 0xb0, 0xd6, 0xf8,
+			   0x5a, 0x23, 0xf9, 0x7b, 0x58, 0x69, 0x8b, 0x60, 0x5c, 0x13,
+			   0x97, 0xdb, 0x21, 0x1c, 0xe8, 0x1e, 0x8d, 0x58, 0xba, 0x16,
+			   0x49, 0x15, 0x42, 0x1b, 0x6e, 0x1c, 0x38, 0x99, 0x72, 0xbc,
+			   0x93, 0xdb, 0x9b, 0x63, 0x69, 0x91, 0xbc, 0xd7, 0x61, 0x0a,
+			   0x18, 0x2f, 0xdc, 0xcf, 0xb4, 0x01, 0x71, 0xc4, 0xb2, 0x90,
+			   0x41, 0x31, 0x3e, 0xbb, 0x4d, 0xf5, 0x62, 0xb2, 0x90, 0x67,
+			   0xf3, 0x76, 0x55, 0x6e, 0x36, 0xa1, 0xcc, 0xc0, 0x2a, 0x07,
+			   0xc4, 0x43, 0x51, 0x74, 0xc9, 0x71, 0x6b, 0x26, 0xfa, 0x49,
+			   0x66, 0x95, 0xdb, 0xdd, 0xb8, 0x9c, 0xc6, 0x52, 0x63, 0xc5,
+			   0x9c, 0x17, 0x31, 0x06, 0xa2, 0xfa, 0x7a, 0x44, 0x69, 0xd7,
+			   0xd7, 0x6e, 0x9a, 0xa7, 0xb6, 0xd5, 0x43, 0xec, 0x93, 0x5f,
+			   0x28, 0x87, 0xff, 0xac, 0x74, 0xaa };
+char g_res[] = { 0x6c, 0x1d, 0xac, 0x7d, 0x82, 0xbb, 0x92, 0x67, 0xf8, 0x06,
+			 	 0xbd, 0x10, 0x6b, 0x37, 0x6a, 0x13, 0x26, 0xb5, 0x6e, 0x57,
+			 	 0x5c, 0x1f, 0x3f, 0x02, 0x39, 0xc3, 0xbd, 0x0c, 0x33, 0x23,
+			 	 0x83, 0xcf, 0x4b, 0x37, 0xd0, 0x1d, 0x24, 0x87, 0x4b, 0x0f,
+			 	 0x21, 0x02, 0xc1, 0x1e, 0xb7, 0x34, 0xb8, 0x81, 0x9c, 0x93,
+			 	 0xfb, 0x00, 0x22, 0x1a, 0x24, 0x8f, 0x3a, 0xae, 0x51, 0x60,
+			 	 0x13, 0x0b, 0xee, 0x3c, 0x9b, 0x61, 0xeb, 0x7f, 0xe5, 0xeb,
+			 	 0xc6, 0x1c, 0x5c, 0xd9, 0x0c, 0xe2, 0x57, 0x2b, 0x42, 0xc4,
+			 	 0x22, 0x41, 0xb4, 0x79, 0x9b, 0x56, 0x18, 0xc7, 0x07, 0xcd,
+			 	 0x27, 0xe7, 0xcf, 0x0e, 0x30, 0xf4, 0x91, 0xd8, 0xa8, 0x9d,
+			 	 0x72, 0x9e, 0x6f, 0x0f, 0xa1, 0x73, 0xfc, 0x82, 0x27, 0x2c,
+			 	 0x98, 0xb4, 0x96, 0x24, 0xa5, 0xaa, 0x4c, 0x5b, 0x01, 0xa8,
+			 	 0x75, 0x16, 0xb2, 0x16, 0x91, 0x7f, 0x16, 0xb8, 0x01, 0xa2,
+			 	 0x64, 0xd4, 0x7e, 0xa4, 0x9f, 0xcb, 0xea, 0x7a, 0x33, 0x82,
+			 	 0x45, 0x49, 0xa4, 0x13, 0xf7, 0x4c, 0xd9, 0x1c, 0x2a, 0x58,
+			 	 0xd2, 0xfa, 0x5c, 0xfd, 0x4c, 0xed, 0xe3, 0xdf, 0xd6, 0x8f,
+			 	 0x68, 0x6c, 0xb8, 0x0b, 0xa0, 0x26, 0xa2, 0x43, 0x6b, 0x9f,
+			 	 0x31, 0x58, 0x05, 0xde, 0x6b, 0x0a, 0x63, 0x14, 0xfb, 0xba,
+			 	 0x64, 0x59, 0xf2, 0x95, 0xe1, 0xba, 0x52, 0x4b, 0x9a, 0xb0,
+			 	 0x36, 0x09, 0x48, 0x84, 0xea, 0x2d, 0x25, 0x13, 0xce, 0x09,
+			 	 0x70, 0x6a, 0x27, 0xab, 0xf0, 0xc1, 0x8e, 0x44, 0x0b, 0x64,
+			 	 0x0a, 0x58, 0x6b, 0x82, 0x3c, 0xe8, 0xd1, 0x18, 0xbb, 0xcc,
+			 	 0x2e, 0x41, 0x90, 0xf9, 0xce, 0x32, 0x8a, 0x3b, 0x8b, 0xe7,
+			 	 0x0a, 0x37, 0x25, 0x79, 0x60, 0x2b, 0xc9, 0x0d, 0x55, 0x88,
+			 	 0xf1, 0x2c, 0x40, 0xa5, 0x09, 0x1c, 0x3b, 0xe4, 0x0f, 0xcf,
+			 	 0x7d, 0x5e, 0xe1, 0x66, 0x08, 0x63 };
+#endif
+rsabase_t g_w = 0x5BA26673940A6C9D;
+
+static void swap_buf(char *buf, u32 len)
+{
+	int i;
+	char temp;
+
+	for (i = 0; i < len/2; ++i) {
+		temp = buf[i];
+		buf[i] = buf[len - 1 - i];
+		buf[len - 1 - i] = temp;
+	}
+}
+
+static int rsa_pow_sw(char *cbase, int baselen,
+						char *cexp, int explen,
+						char *cmode, int modelen,
+						char **cres,  int *reslen)
+{
+	int ret, bytes, sign;
+	char *buf;
+	MPI  base,  exp, mod, res;
+	u64 t0, t1;
+
+	base = mpi_read_raw_data(cbase, baselen);
+	exp = mpi_read_raw_data(cexp, explen);
+	mod = mpi_read_raw_data(cmode, modelen);
+	res = mpi_alloc(modelen);
+
+	t0 = ktime_get_ns();
+	mpi_powm(res, base, exp, mod);
+	t1 = ktime_get_ns();
+	ret = t1 - t0;
+
+	buf = mpi_get_buffer(res, &bytes, &sign);
+#if 1
+	if (bytes & 7) { // big-endian padding zero
+		int i = 8 - (bytes & 7);
+		memmove(buf + i, buf, bytes);
+		memset(buf, 0, i);
+		bytes += i;
+	}
+#endif
+	*reslen = bytes;
+	*cres = buf;
+
+	mpi_free(base);
+	mpi_free(exp);
+	mpi_free(mod);
+	mpi_free(res);
+
+	return ret;
+}
+
+#if 0
+static int rsa_test_case(void *para)
+{
+	/*c = m^e % n */
+	int ret =0;
+	rsa_para base, exp, mode, res, p2_para;
+
+	base.crp_p = g_base;
+	base.crp_bytes = sizeof(g_base);
+
+	exp.crp_p = g_exp;
+	exp.crp_bytes = sizeof(g_exp);
+
+	mode.crp_p = g_mode;
+	mode.crp_bytes = sizeof(g_mode);
+
+	p2_para.crp_bytes = mode.crp_bytes;
+	p2_para.crp_p = kzalloc(mode.crp_bytes, GFP_KERNEL);
+
+	res.crp_p = kzalloc(BITS2BYTES(2048), GFP_KERNEL);
+	res.crp_bytes = 0;
+
+	ret = mont_p2(&mode, &p2_para);
+	if (ret) {
+		printk("mont_p2 fail ret = %d\n", ret);
+		goto out;
+	}
+	swap_buf(p2_para.crp_p, p2_para.crp_bytes);
+	if(memcmp(g_p2, p2_para.crp_p, sizeof(g_p2))) {
+		printk("p2 calculate fail\n");
+		printk("right:");
+		dump_buf(g_p2,  sizeof(g_p2));
+		printk("false:");
+		dump_buf(p2_para.crp_p, p2_para.crp_bytes);
+		ret = 1;
+		goto out;
+	}
+
+out:
+	kfree(p2_para.crp_p );
+	return ret;
+}
+#endif
+
+static int rsa_test_case_montw(void *para)
+{
+
+	rsa_para mode;
+	rsabase_t w1;
+	u64 t0, t1;
+
+	mode.crp_p = g_mode;
+	mode.crp_bytes = sizeof(g_mode);
+
+	t0 = ktime_get_ns();
+	w1 = mont_w(&mode);
+	t1 = ktime_get_ns();
+	printk("montw,%lld ns\n", (t1 - t0));
+
+	if (w1 != g_w) {
+		printk("mont_w fail,w:0x%llx, mont_w:0x%llx\n", g_w, w1);
+		return 1;
+	}
+	return 0;
+}
+
+
+
+static int rsa_pow_hw(char *cbase, int baselen,
+						char *cexp, int explen,
+						char *cmode, int modelen,
+						char **cres,  int *reslen)
+{
+
+	rsa_para base, exp, mode, res;
+	int ret = 0;
+	u64 t0, t1;
+
+	base.crp_p = cbase;
+	base.crp_bytes = baselen;
+
+	exp.crp_p = cexp;
+	exp.crp_bytes = explen;
+
+	mode.crp_p = cmode;
+	mode.crp_bytes = modelen;
+
+	res.crp_p = kmalloc(modelen, GFP_KERNEL);
+	if (IS_ERR_OR_NULL(res.crp_p))
+	{
+		printk("kmalloc res buf fail\n");
+		return -ENOMEM;
+	}
+	res.crp_bytes = modelen;
+	t0 = ktime_get_ns();
+	ret = sp_powm(&res, &base, &exp, &mode);
+	if (ret)  {
+		printk("sp_powm fail: %d\n", ret);
+		goto out;
+	}
+	t1 = ktime_get_ns();
+	ret = t1 - t0;
+
+	*cres = res.crp_p;
+	*reslen = res.crp_bytes;
+out:
+	return ret;
+}
+
+static int rsa_hw_test_case(void *para)
+{
+	char *swres;
+	int swlen;
+	int ret;
+	rsa_para base, exp, mode, res;
+
+	base.crp_p = kmalloc(256, GFP_KERNEL);
+	exp.crp_p = kmalloc(256, GFP_KERNEL);
+	mode.crp_p = kmalloc(256, GFP_KERNEL);
+	res.crp_p = kmalloc(256, GFP_KERNEL);
+#if 0
+	swap_buf(g_exp, sizeof(g_exp));
+	swap_buf(g_mode, sizeof(g_mode));
+#endif
+	memcpy(base.crp_p, g_base, sizeof(g_base));
+	base.crp_bytes = sizeof(g_base);
+
+	memcpy(exp.crp_p,g_exp, sizeof(g_exp));
+	exp.crp_bytes = sizeof(g_exp);
+
+	memcpy(mode.crp_p,g_mode, sizeof(g_mode));
+	mode.crp_bytes = sizeof(g_mode);
+
+	ret = sp_powm(&res, &base, &exp, &mode);
+	if (ret)  {
+		printk("sp_powm fail: %d\n", ret);
+		goto out;
+	}
+
+	swap_buf(g_base, sizeof(g_base));
+	swap_buf(g_exp, sizeof(g_exp));
+	swap_buf(g_mode, sizeof(g_mode));
+	rsa_pow_sw(g_base, sizeof(g_base),
+				g_exp, sizeof(g_exp),
+				g_mode, sizeof(g_mode),
+				&swres, &swlen);
+	swap_buf(g_base, sizeof(g_base));
+	swap_buf(g_exp, sizeof(g_exp));
+	swap_buf(g_mode, sizeof(g_mode));
+
+	swap_buf(swres, swlen);
+	ret = -((swlen != res.crp_bytes) || memcmp(swres, res.crp_p, swlen));
+	if (ret) {
+		printk("HW enc & SW enc result diff\n");
+	}
+	printk("SW result ");
+	dump_buf(swres, swlen);
+	printk("HW result ");
+	dump_buf(res.crp_p, res.crp_bytes);
+
+	kfree(swres);
+
+out:
+#if 0
+	swap_buf(g_exp, sizeof(g_exp));
+	swap_buf(g_mode, sizeof(g_mode));
+#endif
+	kfree(base.crp_p);
+	kfree(exp.crp_p);
+	kfree(mode.crp_p);
+	kfree(res.crp_p);
+
+	return ret;
+}
+
+static volatile int rsa_tt_stop = 0;
+
+static int rsa_random_test_case(void *para)
+{
+	int i, j;
+	char *base, *exp1, *exp2, *mode;
+	int baselen, exp1len, exp2len, modelen;
+	int ret = 0;
+	u32 pid = current->tgid;
+
+	base = kmalloc(256, GFP_KERNEL);
+	exp1 = kmalloc(256, GFP_KERNEL);
+	exp2 = kmalloc(256, GFP_KERNEL);
+	mode = kmalloc(256, GFP_KERNEL);
+
+	printk("[%d]\tkeypair\te1bits\te2bits\tnbits\tA(bits)\t     hw_enc     hw_dec     sw_enc     sw_dec\n", pid);
+	i = para ? (int)para : ARRAY_SIZE(rsa_keyparit);
+	j = 0;
+	while (i-- && !rsa_tt_stop) {
+		u32 e1_pure_len, e2_pure_len;
+
+		exp1len = rsa_keyparit[j].len;
+		memcpy(exp1, rsa_keyparit[j].e1, exp1len);
+
+		exp2len = rsa_keyparit[j].len;
+		memcpy(exp2, rsa_keyparit[j].e2, exp2len);
+
+		modelen = rsa_keyparit[j].len;
+		memcpy(mode, rsa_keyparit[j].n, modelen);
+
+		e1_pure_len = exp1len;
+		e2_pure_len = exp2len;
+		while (!exp1[e1_pure_len - 1]) {
+			e1_pure_len--;
+		}
+
+		while (!exp2[e2_pure_len - 1]) {
+			e2_pure_len--;
+		}
+
+		if (j >= 2) {
+			if (j & 1) {
+				swap_buf(exp1, exp1len);
+			} else {
+				swap_buf(exp2, exp2len);
+			}
+			swap_buf(mode, modelen);
+		}
+
+		for (baselen = 8; baselen <= modelen && !rsa_tt_stop; baselen += 8)
+		//for (baselen = modelen; baselen > 0; baselen -= 8)
+		{
+			char *swres1, *swres2, *hwres1, *hwres2;
+			int swlen1, swlen2, hwlen1, hwlen2;
+			int t_hwe, t_hwd, t_swe, t_swd;
+
+			swres1 = swres2 = hwres1 = hwres2 = NULL;
+
+			//baselen = modelen;
+			get_random_bytes(base, baselen);
+			if (baselen == modelen)
+				base[baselen - 1] = mode[modelen - 1] - 1;
+			else
+				memset(base + baselen, 0, modelen - baselen);
+
+			//printk("%d\n", baselen * 8);
+			t_hwe = rsa_pow_hw(base, modelen,
+								exp1, exp1len,
+								mode, modelen,
+								&hwres1, &hwlen1);
+			if (t_hwe < 0) {
+				printk("[%d] HW enc fail\n", pid);
+				ret = t_hwe;
+				goto next;
+			}
+
+			t_hwd = rsa_pow_hw(hwres1, hwlen1,
+								exp2, exp2len,
+								mode, modelen,
+								&hwres2, &hwlen2);
+			if (t_hwd < 0) {
+				printk("HW dec fail\n");
+				ret = t_hwd;
+				goto next;
+			}
+
+			if (memcmp(base, hwres2, baselen)) {
+				printk("HW enc+dec result error\n");
+				printk("base ");
+				dump_buf(base, baselen);
+				printk("HW enc+dec result ");
+				dump_buf(hwres2, hwlen2);
+				ret = -1;
+				goto next;
+			}
+
+			swap_buf(hwres1, hwlen1);
+			swap_buf(base, baselen);
+			swap_buf(exp1, exp1len);
+			swap_buf(exp2, exp2len);
+			swap_buf(mode, modelen);
+
+			t_swe = rsa_pow_sw(base, baselen,
+								exp1, exp1len,
+								mode, modelen,
+								&swres1, &swlen1);
+			if (memcmp(swres1, hwres1, swlen1)) {
+				printk("HW enc & SW enc result diff\n");
+				printk("SW enc result ");
+				dump_buf(swres1, swlen1);
+				printk("HW enc result ");
+				dump_buf(hwres1, hwlen1);
+#if 0
+				printk("base ");
+				swap_buf(base, baselen);
+				dump_buf(base, baselen);
+				printk("exp1 ");
+				swap_buf(exp1, exp1len);
+				dump_buf(exp1, exp1len);
+				printk("mode ");
+				swap_buf(mode, modelen);
+				dump_buf(mode, modelen);
+#endif
+				ret = -1;
+				goto next;
+			}
+
+			t_swd = rsa_pow_sw(swres1, swlen1,
+								exp2, exp2len,
+								mode, modelen,
+								&swres2, &swlen2);
+			if (memcmp(swres2, base, swlen2)) {
+				printk("SW enc+dec result error\n");
+				printk("base ");
+				dump_buf(base,  baselen);
+				printk("SW enc+dec result ");
+				dump_buf(swres2, swlen2);
+				ret = -1;
+			}
+
+			swap_buf(base, baselen);
+			swap_buf(exp1, exp1len);
+			swap_buf(exp2, exp2len);
+			swap_buf(mode, modelen);
+next:
+			if (swres1) kfree(swres1);
+			if (swres2) kfree(swres2);
+			if (hwres1) kfree(hwres1);
+			if (hwres2) kfree(hwres2);
+			if (ret) goto out;
+
+			printk("[%d]\t%d\t%d\t%d\t%d\t%d\t%11d%11d%11d%11d\n", pid, j, e1_pure_len * 8, e2_pure_len * 8, modelen * 8, baselen * 8, t_hwe, t_hwd, t_swe, t_swd);
+		}
+
+		j = (j + 1) % ARRAY_SIZE(rsa_keyparit);
+	} 
+out:
+	kfree(base);
+	kfree(exp1);
+	kfree(exp2);
+	kfree(mode);
+
+	return ret;
+}
+
+struct test_case test_case[] = {
+	{
+		.fun = rsa_test_case_montw,
+		.name = "rsa_test_case_montw",
+	},
+	{
+		.fun = rsa_hw_test_case,
+		.name = "rsa_hw_test_case",
+	},
+	{
+		.fun = rsa_random_test_case,
+		.name = "rsa_random_test_case",
+	},
+};
+
+static void testcase(int i)
+{
+	printk("TEST_CASE_#%02d: %s\n", i + 1, test_case[i].name);
+	printk("%s\n\n", test_case[i].fun(NULL) ? "FAIL" : "SUCCESS");
+}
+
+static void rsa_mt_test(int t)
+{
+	int i;
+
+	for (i = 0; i < t; i++) {
+		kthread_run(rsa_random_test_case, (void *)-1, "rsa_tt%d", i);
+	}
+
+	rsa_random_test_case((void *)-1);
+
+	rsa_tt_stop = 1;
+}
+
+static int test(const char *val, const struct kernel_param *kp)
+{
+	int i = *val - '0';
+
+	rsa_tt_stop = 0;
+	if (*val == 'x') // MT
+		rsa_mt_test(*(val+1) - '0');
+	else if (i <= ARRAY_SIZE(test_case)) {
+		if (i)
+			testcase(i - 1);
+		else
+			while (i < ARRAY_SIZE(test_case)) {
+				testcase(i);
+				i++;
+			}
+	}
+
+	return 0;
+}
+
+static const struct kernel_param_ops test_ops = {
+	.set = test,
+};
+module_param_cb(test, &test_ops, NULL, 0600);
--- a/drivers/crypto/sp/sp-hash.c	1970-01-01 03:00:00.000000000 +0300
+++ a/drivers/crypto/sp/sp-hash.c	2018-11-12 06:42:52.000000000 +0300
@@ -0,0 +1,516 @@
+#include <crypto/algapi.h>
+#include <linux/cryptohash.h>
+#include <crypto/internal/hash.h>
+#include <crypto/hash.h>
+#include <crypto/md5.h>
+#include <crypto/scatterwalk.h>
+#include <crypto/sha.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/crypto.h>
+#include <linux/kfifo.h>
+#include <linux/delay.h>
+
+#include "sp-crypto.h"
+#include "sp-hash.h"
+
+#define SHA3_224_DIGEST_SIZE	(224 / 8)
+#define SHA3_224_BLOCK_SIZE		(200 - 2 * SHA3_224_DIGEST_SIZE)
+#define SHA3_256_DIGEST_SIZE	(256 / 8)
+#define SHA3_256_BLOCK_SIZE		(200 - 2 * SHA3_256_DIGEST_SIZE)
+#define SHA3_384_DIGEST_SIZE	(384 / 8)
+#define SHA3_384_BLOCK_SIZE		(200 - 2 * SHA3_384_DIGEST_SIZE)
+#define SHA3_512_DIGEST_SIZE	(512 / 8)
+#define SHA3_512_BLOCK_SIZE		(200 - 2 * SHA3_512_DIGEST_SIZE)
+
+#define SHA3_BUF_SIZE			(200)
+
+#define GHASH_BLOCK_SIZE		(16)
+#define GHASH_DIGEST_SIZE		(16)
+#define GHASH_KEY_SIZE			(16)
+
+#define WORKBUF_SIZE			(65536)
+
+struct sp_hash_ctx {
+	crypto_ctx_t base;
+
+	// working buffer: blocks(src) + key(ghash only) + buf(digest)
+
+	u8 *blocks;
+	dma_addr_t blocks_phy;
+	u32 blocks_size;
+	u32 bytes; // bytes in blocks
+
+	// ghash only
+	u8 *key;
+	dma_addr_t key_phy;
+
+	u8 *buf;
+	dma_addr_t buf_phy;
+
+	u32 alg_type;
+	u32 digest_len;
+	u32 block_size;
+
+	u64 byte_count;	// for MD5 padding
+};
+
+static int do_blocks(struct sp_hash_ctx *ctx, u32 len)
+{
+	int ret = 0;
+	crypto_ctx_t *ctx0 = &ctx->base;
+	trb_t *trb;
+
+	SP_CRYPTO_TRACE();
+	//dump_buf(ctx->blocks, len);
+
+	trb = crypto_ctx_queue(ctx0,
+		ctx->blocks_phy,	// src
+		ctx->buf_phy,		// dst
+		ctx->buf_phy,		// iv
+		ctx->key_phy,		// key
+		len, ctx0->mode, true);
+	if (!trb) return -EINTR;
+
+	SP_CRYPTO_TRACE();
+	ret = crypto_ctx_exec(ctx0);
+	//if (ret == -ERESTARTSYS) ret = 0;
+
+	return ret;
+}
+
+static int sp_cra_init(struct crypto_tfm *tfm, u32 mode)
+{
+	struct sp_hash_ctx *ctx = crypto_tfm_ctx(tfm);
+	u32 bsize, len1, len2;
+
+	SP_CRYPTO_TRACE();
+
+	ctx->blocks = dma_alloc_coherent(NULL, WORKBUF_SIZE, &ctx->blocks_phy, GFP_KERNEL);
+	if (!ctx->blocks)
+		return -ENOMEM;
+
+	ctx->base.mode = mode;
+	ctx->alg_type = crypto_tfm_alg_type(tfm);
+	ctx->block_size = bsize = crypto_tfm_alg_blocksize(tfm);
+
+	switch (mode) {
+	case M_MD5:
+		len1 = MD5_DIGEST_SIZE;
+		len2 = bsize;
+		break;
+	case M_GHASH:
+		len1 = GHASH_DIGEST_SIZE;
+		len2 = GHASH_KEY_SIZE;
+		break;
+	default: // M_SHA3
+		len1 = SHA3_BUF_SIZE;
+		len2 = bsize;
+		break;
+	}
+	len1 = WORKBUF_SIZE - len1;
+	len2 = len1 - len2;
+	ctx->blocks_size = len2 / bsize * bsize;
+
+	ctx->buf = ctx->blocks + len1;
+	ctx->buf_phy = ctx->blocks_phy + len1;
+	ctx->key = ctx->blocks + len2;
+	ctx->key_phy = ctx->blocks_phy + len2;
+
+	return crypto_ctx_init(&ctx->base, SP_CRYPTO_HASH);
+}
+
+static int sp_cra_md5_init(struct crypto_tfm *tfm)
+{
+	return sp_cra_init(tfm, M_MD5);
+}
+
+static int sp_cra_ghash_init(struct crypto_tfm *tfm)
+{
+	return sp_cra_init(tfm, M_GHASH);
+}
+
+static int sp_cra_sha3_224_init(struct crypto_tfm *tfm)
+{
+	return sp_cra_init(tfm, M_SHA3_224);
+}
+
+static int sp_cra_sha3_256_init(struct crypto_tfm *tfm)
+{
+	return sp_cra_init(tfm, M_SHA3_256);
+}
+
+static int sp_cra_sha3_384_init(struct crypto_tfm *tfm)
+{
+	return sp_cra_init(tfm, M_SHA3_384);
+}
+
+static int sp_cra_sha3_512_init(struct crypto_tfm *tfm)
+{
+	return sp_cra_init(tfm, M_SHA3_512);
+}
+
+static void sp_cra_exit(struct crypto_tfm *tfm)
+{
+	struct sp_hash_ctx *ctx = crypto_tfm_ctx(tfm);
+
+	SP_CRYPTO_TRACE();
+	dma_free_coherent(NULL, WORKBUF_SIZE, ctx->blocks, ctx->blocks_phy);
+	crypto_ctx_exit(&ctx->base);
+}
+
+static int sp_shash_export(struct shash_desc *desc, void *out)
+{
+	struct sp_hash_ctx *ctx = crypto_tfm_ctx(&desc->tfm->base);
+
+	memcpy(out, ctx->buf, ctx->digest_len);
+	//printk("%s: ", __FUNCTION__); dump_buf(out, ctx->digest_len);
+
+	return 0;
+}
+
+static int sp_shash_import(struct shash_desc *desc, const void *in)
+{
+	struct sp_hash_ctx *ctx = crypto_tfm_ctx(&desc->tfm->base);
+
+	memcpy(ctx->buf, in, ctx->digest_len);
+
+    return 0;
+}
+
+static int sp_shash_update(struct shash_desc *desc, const u8 *data,
+		  u32 len)
+{
+	struct sp_hash_ctx *ctx = crypto_tfm_ctx(&desc->tfm->base);
+	const u32 bsize = ctx->blocks_size;
+	u32 avail = bsize - ctx->bytes; // free bytes in blocks
+	int ret = 0;
+
+	//SP_CRYPTO_TRACE();
+
+	ctx->byte_count += len;
+
+	if (avail >= len) {
+		memcpy(ctx->blocks + ctx->bytes, data, len); // append to blocks
+	} else {
+		do {
+			memcpy(ctx->blocks + ctx->bytes, data, avail); // fill blocks
+			ret = do_blocks(ctx, bsize);
+			if (ret) goto out;
+			
+			data += avail;
+			len -= avail;
+
+			ctx->bytes = 0;
+			avail = bsize;
+		} while (len > bsize);
+
+		memcpy(ctx->blocks, data, len); // saved to blocks
+	}
+	ctx->bytes += len;
+
+out:
+	return ret;
+}
+
+static int sp_shash_final(struct shash_desc *desc, u8 *out)
+{
+	struct sp_hash_ctx *ctx = crypto_tfm_ctx(&desc->tfm->base);
+	const u32 bsize = ctx->block_size;
+	u32 t = ctx->bytes % bsize;
+	u8 *p = ctx->blocks + ctx->bytes;
+	int padding; // padding zero bytes
+	int ret = 0;
+
+	SP_CRYPTO_TRACE();
+
+	// padding
+	switch (ctx->base.mode) {
+	case M_MD5:
+		padding = (bsize * 2 - t - 1 - sizeof(u64)) % bsize;
+		*p++ = 0x80;
+		break;
+	case M_GHASH:
+		padding = t ? (bsize - t) : 0;
+		break;
+	default: // SHA3
+		padding = bsize - t - 1;
+		*p++ = 0x06;
+		break;
+	}
+
+	memset(p, 0, padding); // padding zero
+	p += padding;
+
+	switch (ctx->base.mode) {
+	case M_MD5:
+		((u32 *)p)[0] = ctx->byte_count << 3;
+		((u32 *)p)[1] = ctx->byte_count >> 29;
+		p += sizeof(u64);
+		break;
+	case M_GHASH:
+		break;
+	default: // SHA3
+		*(p - 1) |= 0x80;
+		break;
+	}
+
+	// process blocks
+	//printk("%s: ", __FUNCTION__); dump_buf(ctx->block, p - ctx->block);
+	ctx->base.mode |= M_FINAL;
+	ret = do_blocks(ctx, p - ctx->blocks);
+	ctx->base.mode &= ~M_FINAL;
+
+	mutex_unlock(&HASH_RING(ctx->base.dd)->lock);
+	if (!ret) {
+		sp_shash_export(desc, out);
+	}
+
+	return ret;
+}
+
+static int sp_shash_ghash_setkey(struct crypto_shash *tfm,
+			const u8 *key, unsigned int keylen)
+{
+
+	struct sp_hash_ctx *ctx = crypto_tfm_ctx(&tfm->base);
+
+	SP_CRYPTO_TRACE();
+#if 1 // TODO: dirty hack code, fix me
+	if (keylen & 1) {
+		// called from crypto_gcm_setkey (gcm.c)
+		keylen &= ~1;
+		ctx->digest_len = GHASH_DIGEST_SIZE;
+	}
+#endif
+	//dump_stack();
+	//dump_buf(key, keylen);
+	if (keylen != GHASH_KEY_SIZE) {
+		crypto_shash_set_flags(tfm, CRYPTO_TFM_RES_BAD_KEY_LEN);
+		SP_CRYPTO_ERR("unsupported GHASH key length: %d\n", keylen);
+		return -EINVAL;
+	}
+
+	memcpy(ctx->key, key, keylen);
+
+	return 0;
+}
+
+static int sp_shash_init(struct shash_desc *desc)
+{
+	struct sp_hash_ctx *ctx = crypto_tfm_ctx(&desc->tfm->base);
+	crypto_ctx_t *ctx0 = &ctx->base;
+
+	SP_CRYPTO_TRACE();
+	//printk("!!! %s: %d\n", __FUNCTION__, ctx->digest_len);
+	//dump_stack();
+	if (!ctx->digest_len) {
+		// called from crypto_create_session (CIOCGSESSION)
+		ctx->digest_len = crypto_shash_alg(desc->tfm)->digestsize;
+	} else	{
+		// called from crypto_run (CIOCCRYPT) or gcm_hash (gcm.c)
+		u32 l = (ctx0->mode & M_SHA3) ? SHA3_BUF_SIZE : ctx->digest_len;
+
+		ctx->byte_count = 0;
+		ctx->bytes = 0;
+
+		if (ctx0->mode == M_MD5) {
+			((u32 *)ctx->buf)[0] = 0x67452301;
+			((u32 *)ctx->buf)[1] = 0xefcdab89;
+			((u32 *)ctx->buf)[2] = 0x98badcfe;
+			((u32 *)ctx->buf)[3] = 0x10325476;
+		} else {
+			memset(ctx->buf, 0, l);
+		}
+
+		// can't do mutex_lock in hash_update, we must lock it @ here
+		SP_CRYPTO_TRACE();
+		mutex_lock(&HASH_RING(ctx0->dd)->lock);
+	}
+
+	//SP_CRYPTO_INF("sp_shash_init: %08x %d %d --- %p %p %p\n", ctx->base.mode, ctx->digest_len, ctx->block_size, ctx->buf, ctx->block, ctx->base.mode == M_GHASH ? ctx->key : NULL);
+
+	return 0;
+}
+
+static struct shash_alg sp_shash_alg[] =
+{
+	{
+		.digestsize	=	MD5_DIGEST_SIZE,
+		.init		=	sp_shash_init,
+		.update		=	sp_shash_update,
+		.final		=	sp_shash_final,
+		.export		=	sp_shash_export,
+		.import		=	sp_shash_import,
+		.base		=	{
+			.cra_name		=	"md5",
+			.cra_driver_name = 	"sp-md5",
+			.cra_flags		=	CRYPTO_ALG_TYPE_SHASH,
+			.cra_blocksize	=	MD5_HMAC_BLOCK_SIZE,
+			.cra_module		=	THIS_MODULE,
+			.cra_priority	= 	300,
+			.cra_ctxsize	= 	sizeof(struct sp_hash_ctx),
+			.cra_alignmask	= 	0,
+			.cra_init		= 	sp_cra_md5_init,
+			.cra_exit		= 	sp_cra_exit,
+		},
+	},
+	{
+		.digestsize =	GHASH_DIGEST_SIZE,
+		.init		=	sp_shash_init,
+		.setkey 	=	sp_shash_ghash_setkey,
+		.update 	=	sp_shash_update,
+		.final		=	sp_shash_final,
+		.base		=	{
+			.cra_name		=	"ghash",
+			.cra_driver_name =  "sp-ghash",
+			.cra_flags		=	CRYPTO_ALG_TYPE_SHASH,
+			.cra_blocksize	=	GHASH_BLOCK_SIZE,
+			.cra_module 	=	THIS_MODULE,
+			.cra_priority	= 	300,
+			.cra_ctxsize	=	sizeof(struct sp_hash_ctx),
+			.cra_alignmask	=	0,
+			.cra_init		=	sp_cra_ghash_init,
+			.cra_exit		=	sp_cra_exit,
+		},
+	},
+	{
+		.digestsize =	SHA3_224_DIGEST_SIZE,
+		.init		=	sp_shash_init,
+		.update 	=	sp_shash_update,
+		.final		=	sp_shash_final,
+		.export 	=	sp_shash_export,
+		.import 	=	sp_shash_import,
+		.base		=	{
+			.cra_name		=	"sha3-224",
+			.cra_driver_name =  "sp-sha3-224",
+			.cra_flags		=	CRYPTO_ALG_TYPE_SHASH,
+			.cra_blocksize	=	SHA3_224_BLOCK_SIZE,
+			.cra_module 	=	THIS_MODULE,
+			.cra_priority	=	300,
+			.cra_ctxsize	=	sizeof(struct sp_hash_ctx),
+			.cra_alignmask	=	0,
+			.cra_init		=	sp_cra_sha3_224_init,
+			.cra_exit		=	sp_cra_exit,
+		},
+	},
+	{
+		.digestsize =	SHA3_256_DIGEST_SIZE,
+		.init		=	sp_shash_init,
+		.update 	=	sp_shash_update,
+		.final		=	sp_shash_final,
+		.export		=	sp_shash_export,
+		.import		=	sp_shash_import,
+		.base		=	{
+			.cra_name		=	"sha3-256",
+			.cra_driver_name =  "sp-sha3-256",
+			.cra_flags		=	CRYPTO_ALG_TYPE_SHASH,
+			.cra_blocksize	=	SHA3_256_BLOCK_SIZE,
+			.cra_module 	=	THIS_MODULE,
+			.cra_priority	=	300,
+			.cra_ctxsize	=	sizeof(struct sp_hash_ctx),
+			.cra_alignmask	=	0,
+			.cra_init		=	sp_cra_sha3_256_init,
+			.cra_exit		=	sp_cra_exit,
+		},
+	},
+	{
+		.digestsize =	SHA3_384_DIGEST_SIZE,
+		.init		=	sp_shash_init,
+		.update 	=	sp_shash_update,
+		.final		=	sp_shash_final,
+		.export		=	sp_shash_export,
+		.import		=	sp_shash_import,
+		.base		=	{
+			.cra_name		=	"sha3-384",
+			.cra_driver_name =  "sp-sha3-384",
+			.cra_flags		=	CRYPTO_ALG_TYPE_SHASH,
+			.cra_blocksize	=	SHA3_384_BLOCK_SIZE,
+			.cra_module 	=	THIS_MODULE,
+			.cra_priority	=	300,
+			.cra_ctxsize	=	sizeof(struct sp_hash_ctx),
+			.cra_alignmask	=	0,
+			.cra_init		=	sp_cra_sha3_384_init,
+			.cra_exit		=	sp_cra_exit,
+		},
+	},
+	{
+		.digestsize =	SHA3_512_DIGEST_SIZE,
+		.init		=	sp_shash_init,
+		.update 	=	sp_shash_update,
+		.final		=	sp_shash_final,
+		.export		=	sp_shash_export,
+		.import		=	sp_shash_import,
+		.base		=	{
+			.cra_name		=	"sha3-512",
+			.cra_driver_name =  "sp-sha3-512",
+			.cra_flags		=	CRYPTO_ALG_TYPE_SHASH,
+			.cra_blocksize	=	SHA3_512_BLOCK_SIZE,
+			.cra_module 	=	THIS_MODULE,
+			.cra_priority	=	300,
+			.cra_ctxsize	=	sizeof(struct sp_hash_ctx),
+			.cra_alignmask	=	0,
+			.cra_init		=	sp_cra_sha3_512_init,
+			.cra_exit		=	sp_cra_exit,
+		},
+	},
+};
+
+
+int sp_hash_finit(void)
+{
+	SP_CRYPTO_TRACE();
+	return crypto_unregister_shashes(sp_shash_alg, ARRAY_SIZE(sp_shash_alg));
+}
+EXPORT_SYMBOL(sp_hash_finit);
+
+
+int sp_hash_init(void)
+{
+	SP_CRYPTO_TRACE();
+	return crypto_register_shashes(sp_shash_alg, ARRAY_SIZE(sp_shash_alg));
+}
+EXPORT_SYMBOL(sp_hash_init);
+
+void sp_hash_irq(void *devid, u32 flag)
+{
+	struct sp_crypto_dev *dev = devid;
+	trb_ring_t *ring = HASH_RING(dev);
+
+#ifdef TRACE_WAIT_ORDER
+	SP_CRYPTO_INF(">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> %s:%08x %08x %08x %d\n", __FUNCTION__, flag, dev->reg->HASH_ER, dev->reg->HASHDMA_CRCR, kfifo_len(&ring->f));
+#else
+	SP_CRYPTO_INF(">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> %s:%08x %08x %08x\n", __FUNCTION__, flag, dev->reg->HASH_ER, dev->reg->HASHDMA_CRCR);
+#endif
+	if (flag & HASH_TRB_IF) { // autodma/trb done
+		trb_t *trb = ring->head;
+		ring->irq_count++;
+		if (!trb->cc) dump_trb(trb);
+		while (trb->cc) {
+			//dump_trb(trb);
+			if (trb->ioc) {
+				crypto_ctx_t *ctx = trb->priv;
+				if (ctx->type == SP_CRYPTO_HASH) {
+#ifdef TRACE_WAIT_ORDER
+					wait_queue_head_t *w;
+					BUG_ON(!kfifo_get(&ring->f, &w));
+					BUG_ON(w != &ctx->wait);
+#endif
+					ctx->done = true;
+					if (ctx->mode & M_FINAL) wake_up(&ctx->wait);
+				}
+				else printk("HASH_SKIP\n");
+			}
+			trb = trb_put(ring);
+		}
+	}
+#ifdef USE_ERF
+	if (flag & HASH_ERF_IF) { // event ring full
+		SP_CRYPTO_ERR("\n!!! %08x %08x\n", dev->reg->HASHDMA_ERBAR, dev->reg->HASHDMA_ERDPR);
+		dev->reg->HASHDMA_RCSR |= AUTODMA_RCSR_ERF; // clear event ring full
+	}
+#endif
+	SP_CRYPTO_INF("\n");
+}
+EXPORT_SYMBOL(sp_hash_irq);
+
--- a/drivers/crypto/sp/sp-hash.h	1970-01-01 03:00:00.000000000 +0300
+++ a/drivers/crypto/sp/sp-hash.h	2018-11-12 06:42:52.000000000 +0300
@@ -0,0 +1,8 @@
+#ifndef __SP_HASH_H__
+#define __SP_HASH_H__
+
+int sp_hash_finit(void);
+int sp_hash_init(void);
+void sp_hash_irq(void *devid, u32 flag);
+
+#endif //__SP_HASH_H__
--- a/drivers/crypto/sp/sp-rsa.c	1970-01-01 03:00:00.000000000 +0300
+++ a/drivers/crypto/sp/sp-rsa.c	2018-11-12 06:42:52.000000000 +0300
@@ -0,0 +1,245 @@
+#include <linux/module.h>
+#include <linux/mpi.h>
+#include <linux/slab.h>
+#include <linux/dma-mapping.h>
+#include <linux/semaphore.h>
+#include <linux/wait.h>
+#include <linux/string.h>
+#include <linux/delay.h>
+#include "sp-crypto.h"
+#include "sp-rsa.h"
+
+/*	preprocessing p^2 mode mod	*/
+#define MAX_RSA_BITS	(2048)
+#define MAX_RSA_BYTES	(MAX_RSA_BITS / BITS_PER_BYTE)
+
+#define RSA_BYTES_MASK	(7)
+
+//#define TEST_RSA_SPEED
+
+struct rsa_priv_data{
+	struct rsa_para p2;
+	struct rsa_para mode;
+
+	struct mutex lock;
+	wait_queue_head_t wait;
+	u32 wait_flag;
+
+	struct sp_crypto_dev *dev;
+};
+
+static struct rsa_priv_data rsa_priv = {};
+
+/*	preprocessing p^2 MODE mod  */
+int mont_p2(rsa_para *mod,  rsa_para *p2)
+{
+	int ret;
+	MPI base, exp, mod1, p21;
+	u8 base_buf[1] = {2};
+	u16 exp_buf = mod->crp_bytes * BITS_PER_BYTE * 2; /* 2N.  2 *2048 = 4096 */
+	u32 nlimbs = BITS2LONGS(mod->crp_bytes * BITS_PER_BYTE);
+	int sign = 0, nbytes = 0;
+	char *result;
+
+	mod1 = mpi_read_raw_data(mod->crp_p, mod->crp_bytes);
+	if (IS_ERR_OR_NULL(mod1)){
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	base = mpi_read_raw_data(base_buf, sizeof(base_buf));
+	if (IS_ERR_OR_NULL(base)){
+		ret = -ENOMEM;
+		goto out_base;
+	}
+
+	p21 = mpi_alloc(nlimbs);
+	if (IS_ERR_OR_NULL(p21)){
+		ret = -ENOMEM;
+		goto out_p21;
+	}
+
+	exp_buf = cpu_to_be16(exp_buf);
+	exp = mpi_read_raw_data(&exp_buf, sizeof(exp_buf));
+	if (IS_ERR_OR_NULL(exp)){
+		ret = -ENOMEM;
+		goto out_exp;
+	}
+
+	ret = mpi_powm(p21, base, exp, mod1);
+	if (unlikely(ret)){
+		ret = -EIO;
+		goto out_powm;
+	}
+	result = mpi_get_buffer(p21, &nbytes, &sign);
+	if (IS_ERR_OR_NULL(result)) {
+		ret = -ENOMEM;
+		goto out_powm;
+	}
+	memcpy(p2->crp_p, result,  nbytes);
+	p2->crp_bytes = nbytes;
+	kfree(result);
+
+out_powm:
+	mpi_free(exp);
+out_exp:
+	mpi_free(p21);
+out_p21:
+	mpi_free(base);;
+out_base:
+	mpi_free(mod1);
+out:
+	return ret;
+}
+EXPORT_SYMBOL(mont_p2);
+
+rsabase_t mont_w(rsa_para *mod)
+{
+	rsabase_t t = 1;
+	rsabase_t mode;
+	int i;
+	int lb = RSA_BASE;
+
+#ifdef RSA_DATA_BIGENDBIAN
+	u32 pos = mod->crp_bytes - sizeof(mode);
+	mode = *(rsabase_t *) (mod->crp_p + pos);
+	mode = sp_rsabase_be_to_cpu(mode);
+#else
+	memcpy(&mode, mod->crp_p, sizeof(mode));
+	//mode = *(rsabase_t *) mod->crp_p;
+	mode = sp_rsabase_le_to_cpu(mode);
+#endif
+	for (i = 1 ; i < lb - 1; i++) {
+		t = (t * t * mode);
+	}
+	t = -t;
+
+	return t;
+}
+EXPORT_SYMBOL(mont_w);
+
+int sp_rsa_init(void)
+{
+	memset(&rsa_priv, 0, sizeof(rsa_priv));
+	rsa_priv.p2.crp_p = kmalloc(MAX_RSA_BYTES, GFP_KERNEL);
+	if(IS_ERR_OR_NULL(rsa_priv.p2.crp_p))
+		return  -ENOMEM;
+	rsa_priv.mode.crp_p = kzalloc(MAX_RSA_BYTES, GFP_KERNEL);
+	if(IS_ERR_OR_NULL(rsa_priv.mode.crp_p))
+		return  -ENOMEM;
+	init_waitqueue_head(&rsa_priv.wait);
+	mutex_init(&rsa_priv.lock);
+
+	rsa_priv.dev = sp_crypto_alloc_dev(SP_CRYPTO_RSA);
+	rsa_priv.dev->reg->RSAP2PTR = __pa(rsa_priv.p2.crp_p);
+
+	return 0;
+}
+EXPORT_SYMBOL(sp_rsa_init);
+
+void sp_rsa_finit(void)
+{
+	kfree(rsa_priv.p2.crp_p);
+	kfree(rsa_priv.mode.crp_p);
+
+	sp_crypto_free_dev(rsa_priv.dev, SP_CRYPTO_RSA);
+}
+EXPORT_SYMBOL(sp_rsa_finit);
+
+void sp_rsa_irq(void *devid, u32 flag)
+{
+	//SP_CRYPTO_INF(">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> %s:%08x\n", __FUNCTION__, flag);
+   	rsa_priv.wait_flag = SP_CRYPTO_TRUE;
+   	wake_up(&rsa_priv.wait);
+}
+EXPORT_SYMBOL(sp_rsa_irq);
+
+static int sp_rsa_cmp(rsa_para *a, rsa_para *b)
+{
+#if 1
+	if (a->crp_bytes != b->crp_bytes)
+		return 1;
+	return memcmp(a->crp_p, b->crp_p, a->crp_bytes);
+#else
+	return 1;
+#endif
+}
+
+/*
+* res.crp_p base.crp_p exp.crp_p mod.crp_p must physical continuity
+*/
+int sp_powm(rsa_para *res, rsa_para *base,
+				 rsa_para *exp, rsa_para *mod)
+{
+	int ret;
+	u32 rsa_bytes;
+	volatile struct sp_crypto_reg *reg = rsa_priv.dev->reg;
+	dma_addr_t a1, a2, a3, a4;
+
+	if (unlikely((base->crp_bytes & RSA_BYTES_MASK) ||
+		(exp->crp_bytes & RSA_BYTES_MASK) ||
+		(mod->crp_bytes & RSA_BYTES_MASK))) {
+		printk("invalid arg: base->crp_bytes = 0x%x, exp->crp_bytes = 0x%x, mod->crp_bytes = 0x%x",
+				base->crp_bytes, exp->crp_bytes, mod->crp_bytes);
+		return -EINVAL;
+	}
+
+	rsa_bytes = max(base->crp_bytes, exp->crp_bytes);
+	rsa_bytes = max(rsa_bytes, mod->crp_bytes);
+	res->crp_bytes = mod->crp_bytes;
+
+	mutex_lock(&rsa_priv.lock);
+	if (sp_rsa_cmp(mod, &rsa_priv.mode)) {
+		rsabase_t w = mont_w(mod);
+		reg->RSAWPTRL = (u32)w;
+		reg->RSAWPTRH = (u32)(w >> BITS_PER_REG);
+		rsa_priv.mode.crp_bytes = mod->crp_bytes;
+		memcpy(rsa_priv.mode.crp_p, mod->crp_p, mod->crp_bytes);
+		reg->RSAPAR0 = RSA_SET_PARA_D(rsa_bytes * BITS_PER_BYTE) | RSA_PARA_PRECAL_P2;
+		//printk("!!!!!!!!!!!!!!!! %08x %08x\n", reg->RSAWPTRH, reg->RSAWPTRL);
+	} else {
+		reg->RSAPAR0 = RSA_SET_PARA_D(rsa_bytes * BITS_PER_BYTE) | RSA_PARA_FETCH_P2;
+	}
+
+	reg->RSASPTR = a1 = dma_map_single(NULL, base->crp_p, base->crp_bytes, DMA_TO_DEVICE);
+	reg->RSAYPTR = a2 = dma_map_single(NULL, exp->crp_p, exp->crp_bytes, DMA_TO_DEVICE);
+	reg->RSANPTR = a3 = dma_map_single(NULL, mod->crp_p, mod->crp_bytes, DMA_TO_DEVICE);
+	reg->RSADPTR = a4 = dma_map_single(NULL, res->crp_p, res->crp_bytes, DMA_FROM_DEVICE);
+
+    rsa_priv.wait_flag = SP_CRYPTO_FALSE;
+	smp_wmb();
+
+#ifdef RSA_DATA_BIGENDBIAN
+	reg->RSADMACS = RSA_DMA_SIZE(rsa_bytes) | RSA_DATA_BE | RSA_DMA_ENABLE;
+#else
+	reg->RSADMACS = RSA_DMA_SIZE(rsa_bytes) | RSA_DATA_LE | RSA_DMA_ENABLE;
+#endif
+	ret = wait_event_interruptible_timeout(rsa_priv.wait, rsa_priv.wait_flag, 30*HZ);
+	mutex_unlock(&rsa_priv.lock);
+	if (!ret) {
+		SP_CRYPTO_ERR("wait RSA timeout\n");
+		ret = -ETIMEDOUT;
+	}
+#if 1 // TODO: unmark this to find the break-fail root cause
+	else if (ret > 0) {
+		ret = 0;
+	}
+	else { // < 0, ERROR
+		SP_CRYPTO_ERR("wait RSA error: %d\n", ret);
+		//rsa_priv.mode.crp_bytes = 0; // reset
+	}
+#else
+	else ret = 0;
+#endif
+
+	dma_unmap_single(NULL, a1, base->crp_bytes, DMA_TO_DEVICE);
+	dma_unmap_single(NULL, a2, exp->crp_bytes, DMA_TO_DEVICE);
+	dma_unmap_single(NULL, a3, mod->crp_bytes, DMA_TO_DEVICE);
+	dma_unmap_single(NULL, a4, res->crp_bytes, DMA_FROM_DEVICE);
+
+	return ret;
+}
+EXPORT_SYMBOL(sp_powm);
+
+MODULE_LICENSE("GPL v2");
+
--- a/drivers/crypto/sp/sp-rsa.h	1970-01-01 03:00:00.000000000 +0300
+++ a/drivers/crypto/sp/sp-rsa.h	2018-11-12 06:42:52.000000000 +0300
@@ -0,0 +1,42 @@
+#ifndef __SP_RSA_H__
+#define __SP_RSA_H__
+#include <linux/mpi.h>
+
+
+//#define RSA_DATA_BIGENDBIAN
+
+
+#define RSA_BASE   64
+#define RSA_BASE_MASK ((1 << (RSA_BASE - 2)) - 1)
+
+#if (RSA_BASE == 32)
+#define SP_RSA_LB   5
+typedef s32   rsabase_t;
+
+#define sp_rsabase_le_to_cpu __le32_to_cpu
+#define sp_rsabase_be_to_cpu __be32_to_cpu
+
+#elif (RSA_BASE == 64)
+#define SP_RSA_LB   6
+typedef s64   rsabase_t;
+
+#define sp_rsabase_le_to_cpu __le64_to_cpu
+#define sp_rsabase_be_to_cpu __be64_to_cpu
+#endif
+
+typedef struct rsa_para {
+	__u8	*crp_p;
+	__u32	crp_bytes;
+}rsa_para;
+
+#define BITS2BYTES(bits)	((bits)/(BITS_PER_BYTE))
+#define BITS2LONGS(bits)	((bits)/(BITS_PER_LONG))
+
+int sp_powm(rsa_para *res, rsa_para *base, rsa_para *exp, rsa_para *mod);
+void sp_rsa_finit(void);
+int sp_rsa_init(void);
+void sp_rsa_irq(void *devid, u32 flag);
+int mont_p2(rsa_para *mod,  rsa_para *p2);
+rsabase_t mont_w(rsa_para *mod);
+int sp_mpi_set_buffer(MPI a, const void *xbuffer, unsigned nbytes, int sign);
+#endif //__SP_RSA_H__
