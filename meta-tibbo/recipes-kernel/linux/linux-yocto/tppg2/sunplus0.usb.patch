--- a/drivers/usb/bc/Kconfig	1970-01-01 03:00:00.000000000 +0300
+++ a/drivers/usb/bc/Kconfig	2018-11-12 06:42:55.000000000 +0300
@@ -0,0 +1,4 @@
+config USB_BC
+	bool "Support Gemini USB Battery Charge"
+	depends on USB
+	default n
--- a/drivers/usb/bc/Makefile	1970-01-01 03:00:00.000000000 +0300
+++ a/drivers/usb/bc/Makefile	2018-11-12 06:42:55.000000000 +0300
@@ -0,0 +1 @@
+obj-$(CONFIG_USB_BC)	+= sp-bc.o
--- a/drivers/usb/bc/sp-bc.c	1970-01-01 03:00:00.000000000 +0300
+++ a/drivers/usb/bc/sp-bc.c	2018-11-12 06:42:55.000000000 +0300
@@ -0,0 +1,402 @@
+#include <linux/delay.h>
+#include <linux/module.h>
+#include <mach/io_map.h>
+#include <linux/kthread.h>
+#include <linux/semaphore.h>
+#include <linux/usb/sp_usb.h>
+
+struct bc_hcd {
+	int irq;
+	int port_num;
+	struct task_struct *bc_polling_thread;
+	wait_queue_head_t bc_polling_wq;
+	bool wake_up_condition;
+};
+
+#define BC_MODULE_NAME		"sp_bc"
+
+#define bc_debug(fmt, args...)
+
+#define CDP_OFFSET		0
+#define BC_NUM			(USB_PORT_NUM - 1)
+
+#define USB0_PORT_NUM		0
+#define USB1_PORT_NUM		1
+#define USB2_PORT_NUM		2
+#define	EHCI_STA_REG_PORT_0	0x9C102164
+#define	EHCI_STA_REG_PORT_1	0x9C103164
+#define EHCI_STA_REG_PORT_2	0x9C104164
+#define	EHCI_STA_REG_UDC_0	0x9C102B10
+#define	EHCI_STA_REG_UDC_1	0x9C103B10
+
+
+u32 bc_switch = 0;
+EXPORT_SYMBOL_GPL(bc_switch);
+
+static int cdp[USB_PORT_NUM] = { 1, 1, 1 };
+
+static struct bc_hcd sp_bc_hcd[USB_PORT_NUM];
+static u32 *hw_port_sta[USB_PORT_NUM];
+static u32 *udc_port_sta[USB_PORT_NUM];
+
+static bool bc_polling_enable = true;
+module_param(bc_polling_enable, bool, 0644);
+
+u32 cdp_cfg16_value = 0x19;
+u32 cdp_cfg17_value = 0x92;
+u32 dcp_cfg16_value = 0x00;
+u32 dcp_cfg17_value = 0x93;
+u32 sdp_cfg16_value = 0x00;
+u32 sdp_cfg17_value = 0x00;
+
+module_param(cdp_cfg16_value, uint, 0644);
+module_param(cdp_cfg17_value, uint, 0644);
+module_param(dcp_cfg16_value, uint, 0644);
+module_param(dcp_cfg17_value, uint, 0644);
+module_param(sdp_cfg16_value, uint, 0644);
+module_param(sdp_cfg17_value, uint, 0644);
+
+EXPORT_SYMBOL_GPL(cdp_cfg16_value);
+EXPORT_SYMBOL_GPL(cdp_cfg17_value);
+EXPORT_SYMBOL_GPL(dcp_cfg16_value);
+EXPORT_SYMBOL_GPL(dcp_cfg17_value);
+EXPORT_SYMBOL_GPL(sdp_cfg16_value);
+EXPORT_SYMBOL_GPL(sdp_cfg17_value);
+
+/*
+ * call the func when disconnect the port
+ */
+static void battery_charging_state_init(int port)
+{
+	void __iomem *reg_addr;
+	u32 val;
+
+	reg_addr = port ? uphy1_base_addr : uphy0_base_addr;
+
+	val = readl(reg_addr + CDP_REG_OFFSET);
+	val |= (3 << 3);
+	val &= ~(1u << CDP_OFFSET);
+	writel(val, reg_addr + CDP_REG_OFFSET);
+
+	val = readl(reg_addr + DCP_REG_OFFSET);
+	val = 0x92;
+	writel(val, reg_addr + DCP_REG_OFFSET);
+
+	writel(0x17, reg_addr + UPHY_INTER_SIGNAL_REG_OFFSET);
+}
+
+static void battery_charging_disinit(int port)
+{
+	void __iomem *reg_addr;
+	u32 val;
+
+	reg_addr = port ? uphy1_base_addr : uphy0_base_addr;
+
+	val = readl(reg_addr + CDP_REG_OFFSET);
+	val &= ~(1u << CDP_OFFSET);
+	writel(val, reg_addr + CDP_REG_OFFSET);
+}
+
+static int is_udc_connect(int port)
+{
+	u32 sta_val[2];
+
+	if (BC_NUM < port) {
+		printk(KERN_NOTICE "USB BC port from 0, max is %d\n", BC_NUM);
+		return 0;
+	}
+
+	if (USB2_PORT_NUM == port)
+		return 0;
+
+	sta_val[0] = readl(udc_port_sta[port]);
+	msleep(3);
+	sta_val[1] = readl(udc_port_sta[port]);
+
+	if (sta_val[1] == sta_val[0])
+		return 0;
+	else
+		return 1;
+}
+
+static int is_hw_connect(int port)
+{
+	u32 sta_val;
+
+	if (BC_NUM < port) {
+		printk(KERN_NOTICE "USB BC port from 0, max is %d\n", BC_NUM);
+		return 0;
+	}
+
+	sta_val = readl(hw_port_sta[port]);
+
+	return sta_val & 0x01;
+}
+
+/* Make sure BC status back to normal. Call the func every 100 ms */
+static void battery_charging_reset(int port)
+{
+	void __iomem *reg_addr;
+	u32 val;
+
+	if (BC_NUM < port) {
+		printk(KERN_NOTICE "USB BC port from 0, max is %d\n", BC_NUM);
+		return;
+	}
+
+	reg_addr = port ? uphy1_base_addr : uphy0_base_addr;
+
+	/* disable & enable CDP to reset BC status */
+	val = readl(reg_addr + CDP_REG_OFFSET);
+	val &= ~(0x01);
+	writel(val, reg_addr + CDP_REG_OFFSET);
+
+	msleep(1);
+
+	val |= (0x01);
+	writel(val, reg_addr + CDP_REG_OFFSET);
+}
+
+static int battery_charging_enable(int port, int enable)
+{
+	void __iomem *reg_addr;
+	u32 val;
+
+	if (BC_NUM < port) {
+		printk(KERN_NOTICE "USB BC port from 0, max is %d\n", BC_NUM);
+		return 0;
+	}
+
+	reg_addr = port ? uphy1_base_addr : uphy0_base_addr;
+	/* disable & enable CDP to reset BC status */
+	val = readl(reg_addr + CDP_REG_OFFSET);
+
+	if (enable)
+		val |= (0x01);
+	else
+		val &= ~(0x01);
+
+	writel(val, reg_addr + CDP_REG_OFFSET);
+
+	return 1;
+}
+
+/*
+ * 1:change 0:empty
+ */
+static int battery_charging_current_state(int port)
+{
+	void __iomem *reg_addr;
+	u32 val;
+
+	if (BC_NUM < port) {
+		printk(KERN_NOTICE "USB BC port from 0, max is %d\n", BC_NUM);
+		return 0;
+	}
+
+	reg_addr = port ? uphy1_base_addr : uphy0_base_addr;
+	val = readl(reg_addr + UPHY_DEBUG_SIGNAL_REG_OFFSET);
+
+	if (((val & 0x07) == 0x04)
+	    && (is_hw_connect(port) == 0)
+	    && (is_udc_connect(port) == 0)) {
+		battery_charging_reset(port);
+		val = readl(reg_addr + UPHY_DEBUG_SIGNAL_REG_OFFSET);
+	}
+
+	if ((val & 0x07) == 0x03) {
+		bc_debug("-- BC[%d] change 0x%x\n", port, val & 0x07);
+		return 1;
+	} else
+		return 0;
+}
+
+static int bc_reset_thread(void *arg)
+{
+	struct bc_hcd *bc_hcd = (struct bc_hcd *)arg;
+	int port;
+
+	port = bc_hcd->port_num;
+	printk(KERN_NOTICE "port %d BC reset thread start\n", port);
+
+	do {
+#ifdef CONFIG_USB_LOGO_TEST
+		wait_event_interruptible(bc_hcd->bc_polling_wq, bc_hcd->wake_up_condition);
+		bc_hcd->wake_up_condition = false;
+		if (cdp[port])
+			battery_charging_enable(port, 1);
+
+		while (bc_polling_enable) {
+			u32 ret;
+
+			ret = battery_charging_current_state(port);
+			if (cdp[port] && ret) {
+				msleep(100);
+				battery_charging_enable(port, 0);
+				break;
+			}
+
+			msleep(5);
+		}
+
+		msleep(150);
+		continue;
+#endif
+	} while (!kthread_should_stop());
+
+	return 0;
+}
+
+static ssize_t show_bc_switch(struct module_attribute *mattr,
+			      struct module_kobject *mk, char *buffer)
+{
+	return 0;
+}
+
+static ssize_t store_bc_switch(struct module_attribute *mattr,
+			       struct module_kobject *mk,
+			       const char *buffer, size_t count)
+{
+	/*
+	 * buffer[0] is port num,
+	 * buffer[1] is BC mode,
+	 * buffer[2] is certification mode.
+	 */
+	u8 bc_mode;
+	u8 certification_mode;
+	void __iomem *reg_addr;
+
+	if (kstrtouint(buffer, 0, &bc_switch) == 0) {
+		if (0 == ((sp_port_enabled >> (bc_switch & 0x03)) & 0x01)) {
+			printk(KERN_NOTICE "%s,port %d not support\n",
+			       __FUNCTION__, bc_switch & 0x03);
+			return count;
+		}
+
+		bc_mode = (bc_switch >> 8) & 0xFF;
+		certification_mode = (bc_switch >> 16) & 0xFF;
+
+		printk(KERN_NOTICE "BC switch %x %x\n", bc_switch, bc_mode);
+		reg_addr = (bc_switch & 0x03) ? uphy1_base_addr : uphy0_base_addr;
+
+		switch ((bc_switch >> 8) & 0xFF) {
+		case 0:
+			printk(KERN_NOTICE "Enable port %d CDP\n",
+			       bc_switch & 0x03);
+			cdp[bc_switch & 0x03] = 1;
+			writel(cdp_cfg16_value, reg_addr + CDP_REG_OFFSET);
+			writel(cdp_cfg17_value, reg_addr + DCP_REG_OFFSET);
+
+			/* 0x4F is 'O', 0x6F is 'o', Both said general mode. */
+			if ((0x4F != certification_mode)
+			    && (0x6F != certification_mode)) {
+				printk(KERN_NOTICE "wake up BC reset thread");
+				sp_bc_hcd[bc_switch & 0x03].wake_up_condition = true;
+				wake_up_interruptible(&sp_bc_hcd[bc_switch & 0x03].bc_polling_wq);
+			}
+			break;
+		case 1:
+			printk(KERN_NOTICE "Enable port %d DCP\n",
+			       bc_switch & 0x03);
+			cdp[bc_switch & 0x03] = 0;
+			writel(dcp_cfg16_value, reg_addr + CDP_REG_OFFSET);
+			writel(dcp_cfg17_value, reg_addr + DCP_REG_OFFSET);
+			break;
+		case 2:
+			cdp[bc_switch & 0x03] = 0;
+			printk(KERN_NOTICE "Enable port %d SDP\n",
+			       bc_switch & 0x03);
+			writel(sdp_cfg16_value, reg_addr + CDP_REG_OFFSET);
+			writel(sdp_cfg17_value, reg_addr + DCP_REG_OFFSET);
+			break;
+		default:
+			break;
+		}
+	}
+
+	return count;
+}
+
+static struct module_attribute bc_switch_enable =
+	__ATTR(bc_switch, 0644, show_bc_switch, store_bc_switch);
+
+static int __init sp_bc_init(void)
+{
+	struct bc_hcd *bc_hcd = NULL;
+	struct kobject *kobj;
+	size_t remap_size = 1;
+	int retval;
+	int i;
+
+	for (i = 0; i < USB_PORT_NUM; i++) {
+		if (0 == ((sp_port_enabled >> i) & 0x01)) {
+			continue;
+		}
+
+		if (USB2_PORT_NUM == i) {
+			hw_port_sta[i] =
+				ioremap_nocache(EHCI_STA_REG_PORT_2, remap_size);
+		} else if (USB1_PORT_NUM == i) {
+			hw_port_sta[i] =
+				ioremap_nocache(EHCI_STA_REG_PORT_1, remap_size);
+			udc_port_sta[i] =
+				ioremap_nocache(EHCI_STA_REG_UDC_1, remap_size);
+		} else {
+			hw_port_sta[i] =
+				ioremap_nocache(EHCI_STA_REG_PORT_0, remap_size);
+			udc_port_sta[i] =
+				ioremap_nocache(EHCI_STA_REG_UDC_0, remap_size);
+		}
+
+		printk(KERN_NOTICE "Init BC controller %d\n", i);
+		bc_hcd = &sp_bc_hcd[i];
+		bc_hcd->port_num = i;
+
+		bc_hcd->wake_up_condition = false;
+		init_waitqueue_head(&bc_hcd->bc_polling_wq);
+		bc_hcd->bc_polling_thread =
+			kthread_create(bc_reset_thread, bc_hcd, "bc_kthread");
+		if (IS_ERR(bc_hcd->bc_polling_thread)) {
+			pr_err("Create BC(%d) thread fail!\n", i);
+		}
+
+		battery_charging_state_init(i);
+		wake_up_process(bc_hcd->bc_polling_thread);
+	}
+
+	kobj = kset_find_obj(module_kset, BC_MODULE_NAME);
+	retval = sysfs_create_file(kobj, &bc_switch_enable.attr);
+	if (retval) {
+		printk(KERN_NOTICE "warn, create bc_switch sysfs file fail(%d)\n", retval);
+	}
+
+	return 0;
+}
+
+static void __exit sp_bc_cleanup(void)
+{
+	int i;
+	int retval;
+	struct bc_hcd *bc_hcd = NULL;
+
+	for (i = 0; i < USB_PORT_NUM; i++) {
+		if (0 == ((sp_port_enabled >> i) & 0x01)) {
+			continue;
+		}
+
+		if (i != USB2_PORT_NUM) {
+			iounmap(hw_port_sta[i]);
+			iounmap(udc_port_sta[i]);
+		} else {
+			iounmap(hw_port_sta[i]);
+		}
+
+		bc_hcd = &sp_bc_hcd[i];
+		battery_charging_disinit(i);
+		retval = kthread_stop(bc_hcd->bc_polling_thread);
+		printk(KERN_DEBUG "port %d BC polling thread exit status %d\n", i, retval);
+	}
+}
+
+module_init(sp_bc_init);
+module_exit(sp_bc_cleanup);
--- a/drivers/usb/core/config.c	2018-11-23 10:16:15.954819340 +0300
+++ a/drivers/usb/core/config.c	2018-11-23 10:31:03.784051823 +0300
@@ -802,6 +802,7 @@
 	unsigned int cfgno, length;
 	unsigned char *bigbuffer;
 	struct usb_config_descriptor *desc;
+	struct usb_hcd *hcd = bus_to_hcd(dev->bus);
 
 	cfgno = 0;
 	result = -ENOMEM;
@@ -834,9 +835,18 @@
 	for (; cfgno < ncfg; cfgno++) {
 		/* We grab just the first descriptor so we know how long
 		 * the whole configuration is */
+		hcd->enum_msg_flag = true;
 		result = usb_get_descriptor(dev, USB_DT_CONFIG, cfgno,
 		    desc, USB_DT_CONFIG_SIZE);
+		hcd->enum_msg_flag = false;
 		if (result < 0) {
+#ifdef WORKAROUND_HW_NOT_FINISH_QTD_WHEN_DISC
+			if (result == -ENOTCONN) {
+				printk(KERN_NOTICE
+				       "warn,dev disc when get configuration\n");
+				goto err;
+			}
+#endif
 			dev_err(ddev, "unable to read config index %d "
 			    "descriptor/%s: %d\n", cfgno, "start", result);
 			if (result != -EPIPE)
@@ -864,8 +874,10 @@
 		if (dev->quirks & USB_QUIRK_DELAY_INIT)
 			msleep(200);
 
+		hcd->enum_msg_flag = true;
 		result = usb_get_descriptor(dev, USB_DT_CONFIG, cfgno,
 		    bigbuffer, length);
+		hcd->enum_msg_flag = false;
 		if (result < 0) {
 			dev_err(ddev, "unable to read config index %d "
 			    "descriptor/%s\n", cfgno, "all");
--- a/drivers/usb/core/devices.c	2018-11-23 10:16:15.954819340 +0300
+++ a/drivers/usb/core/devices.c	2018-11-23 10:31:03.784051823 +0300
@@ -58,6 +58,7 @@
 #include <linux/usb/hcd.h>
 #include <linux/mutex.h>
 #include <linux/uaccess.h>
+#include <linux/usb/sp_usb.h>
 
 #include "usb.h"
 
@@ -496,7 +497,7 @@
 	if (*nbytes <= 0)
 		return 0;
 
-	if (level > MAX_TOPO_LEVEL)
+	if (level > max_topo_level)
 		return 0;
 	/* allocate 2^1 pages = 8K (on i386);
 	 * should be more than enough for one device */
--- a/drivers/usb/core/hcd.c	2018-11-23 10:16:15.955819280 +0300
+++ a/drivers/usb/core/hcd.c	2018-11-23 10:31:03.782051942 +0300
@@ -47,6 +47,7 @@
 #include <linux/usb/hcd.h>
 #include <linux/usb/phy.h>
 #include <linux/usb/otg.h>
+#include <linux/usb/sp_usb.h>
 
 #include "usb.h"
 
@@ -86,6 +87,36 @@
 
 /*-------------------------------------------------------------------------*/
 
+
+u8 sp_port_enabled = 0;
+EXPORT_SYMBOL_GPL(sp_port_enabled);
+
+bool enum_rx_active_flag[USB_PORT_NUM] = { false };
+EXPORT_SYMBOL(enum_rx_active_flag);
+
+struct semaphore enum_rx_active_reset_sem[USB_PORT_NUM];
+EXPORT_SYMBOL_GPL(enum_rx_active_reset_sem);
+
+uint accessory_port_id = USB_PORT0_ID;
+module_param(accessory_port_id, uint, 0644);
+EXPORT_SYMBOL_GPL(accessory_port_id);
+
+bool platform_device_mode_flag[USB_PORT_NUM] = { false };
+EXPORT_SYMBOL_GPL(platform_device_mode_flag);
+
+int uphy0_irq_num = -1;
+int uphy1_irq_num = -1;
+void __iomem *uphy0_base_addr = NULL;
+void __iomem *uphy1_base_addr = NULL;
+EXPORT_SYMBOL_GPL(uphy0_irq_num);
+EXPORT_SYMBOL_GPL(uphy1_irq_num);
+EXPORT_SYMBOL_GPL(uphy0_base_addr);
+EXPORT_SYMBOL_GPL(uphy1_base_addr);
+
+
+
+
+
 /* Keep track of which host controller drivers are loaded */
 unsigned long usb_hcds_loaded;
 EXPORT_SYMBOL_GPL(usb_hcds_loaded);
@@ -2232,6 +2263,65 @@
 	return hcd->driver->get_frame_number (hcd);
 }
 
+#ifdef CONFIG_USB_HOST_RESET_SP
+void Reset_usb_host_ctrler(struct usb_device *udev)
+{
+	struct usb_hcd *hcd;
+
+	hcd = bus_to_hcd(udev->bus);
+
+	if (hcd) {
+		printk(KERN_NOTICE "%s wake USB ctrl\n", __FUNCTION__);
+		*(hcd->ptr_flag) |= (RESET_HC_DEAD | RESET_UPHY_SIGN);
+		wake_up_interruptible(&hcd->reset_queue);
+	}
+}
+EXPORT_SYMBOL_GPL(Reset_usb_host_ctrler);
+
+void reset_usb_powerx(struct usb_hcd *hcd, int delayms)
+{
+	struct platform_device *pdev = to_platform_device(hcd->self.controller);
+	int port = pdev->id - 1;
+
+	if (port > USB_PORT1_ID) {		/*0 or 1 */
+		printk(KERN_NOTICE "power port=%d\n", port);
+		return;
+	}
+	printk(KERN_NOTICE "USB power ++ %d\n", delayms);
+	DISABLE_VBUS_POWER(port);
+	uphy_force_disc(1, port);
+	msleep(delayms);
+	printk(KERN_NOTICE "USB power -- %d\n", delayms);
+	uphy_force_disc(0, port);
+	ENABLE_VBUS_POWER(port);
+}
+EXPORT_SYMBOL_GPL(reset_usb_powerx);
+
+void Reset_Usb_PowerCtrl(int port, int on)
+{
+	if (port > USB_PORT1_ID)		/*0 or 1 */
+		return;
+		printk(KERN_NOTICE "USB power %d %s\n", port, on ? "on" : "off");
+	if (!on) {
+		DISABLE_VBUS_POWER(port);
+		uphy_force_disc(1, port);
+	} else {
+		uphy_force_disc(0, port);
+		ENABLE_VBUS_POWER(port);
+	}
+}
+EXPORT_SYMBOL_GPL(Reset_Usb_PowerCtrl);
+
+void Usb_dev_power_reset(struct usb_device *udev, int delayms)
+{
+	struct usb_hcd *hcd = bus_to_hcd(udev->bus);
+	if (hcd) {
+		reset_usb_powerx(hcd, delayms);
+	}
+}
+EXPORT_SYMBOL_GPL(Usb_dev_power_reset);
+#endif	/* CONFIG_USB_HOST_RESET_SP */
+
 /*-------------------------------------------------------------------------*/
 
 #ifdef	CONFIG_PM
@@ -2416,6 +2506,55 @@
 
 #endif
 
+#ifdef CONFIG_USB_PHY_RX_ACTIVE_QUESTION_WORKAROUND
+#define	UPHY_IRQ_OFFSET		19
+extern bool enum_rx_active_flag[USB_PORT_NUM];
+irqreturn_t usb_uphy_irq(int irq, void *__hcd)
+{
+	u32 uphy_val;
+	int port_num = -1;
+	volatile u32 *uphy_disc;
+	unsigned long flags;
+	struct usb_hcd *hcd = __hcd;
+	void __iomem *reg_addr;
+	struct platform_device *pdev = to_platform_device(hcd->self.controller);
+
+	local_irq_save(flags);
+
+	port_num = pdev->id - 1;
+	if(USB_PORT0_ID == port_num){
+		reg_addr = uphy0_base_addr;
+	} else if(USB_PORT1_ID == port_num){
+		reg_addr = uphy1_base_addr;
+	}
+
+	uphy_val = readl(reg_addr + UPHY_INTR_OFFSET);
+	uphy_val |= 0x02;
+	writel(uphy_val, reg_addr + UPHY_INTR_OFFSET);
+	uphy_val = readl(reg_addr + UPHY_INTR_OFFSET);
+	while (uphy_val & 0x80) {
+		printk(KERN_NOTICE "usb_uphy_irq,v:0x%x\n", uphy_val);
+		uphy_val = readl(reg_addr + UPHY_INTR_OFFSET);
+	}
+
+	uphy_val &= ~0x02;
+	writel(uphy_val, reg_addr + UPHY_INTR_OFFSET);
+
+	if (hcd->enum_flag[pdev->id - 1]) {
+		hcd->enum_flag[pdev->id - 1] = false;
+		enum_rx_active_flag[pdev->id - 1] = true;
+		printk(KERN_NOTICE "rx-active question happen during enum\n");
+	}
+#ifdef CONFIG_USB_HOST_RESET_SP
+	*(hcd->ptr_flag) |= (RESET_HC_DEAD | RESET_UPHY_SIGN);
+	wake_up_interruptible(&hcd->reset_queue);
+#endif
+
+	local_irq_restore(flags);
+	return IRQ_HANDLED;
+}
+#endif	/* WORKAROUND_HW_BUG_RX_ACTIVE_QUESTION */
+
 /*-------------------------------------------------------------------------*/
 
 /**
@@ -2505,6 +2644,7 @@
 		struct device *sysdev, struct device *dev, const char *bus_name,
 		struct usb_hcd *primary_hcd)
 {
+	int i;
 	struct usb_hcd *hcd;
 
 	hcd = kzalloc(sizeof(*hcd) + driver->hcd_priv_size, GFP_KERNEL);
@@ -2559,6 +2699,28 @@
 	hcd->speed = driver->flags & HCD_MASK;
 	hcd->product_desc = (driver->product_desc) ? driver->product_desc :
 			"USB Host Controller";
+	hcd->hub_thread = NULL;
+	hcd->current_active_urb = NULL;
+	hcd->enum_msg_flag = false;
+	hcd->enum_flag = (bool *) kmalloc(sizeof(*hcd->enum_flag)
+					  * USB_PORT_NUM, GFP_KERNEL);
+	if (!hcd->enum_flag) {
+		kfree(hcd);
+		dev_dbg(dev, "hcd enum_flag alloc failed\n");
+		return NULL;
+	}
+	hcd->uphy_disconnect_level =
+	    (u32 *)kmalloc(sizeof(*hcd->uphy_disconnect_level)
+			    * USB_PORT_NUM, GFP_KERNEL);
+	if (!hcd->uphy_disconnect_level) {
+		kfree(hcd);
+		dev_dbg(dev, "hcd uphy_disconnect_level alloc failed\n");
+		return NULL;
+	}
+	for (i = 0; i < USB_PORT_NUM; i++) {
+		hcd->enum_flag[i] = false;
+		hcd->uphy_disconnect_level[i] = 0;
+	}
 	return hcd;
 }
 EXPORT_SYMBOL_GPL(__usb_create_hcd);
@@ -2631,6 +2793,12 @@
 		kfree(hcd->address0_mutex);
 		kfree(hcd->bandwidth_mutex);
 	}
+	if (hcd->enum_flag)
+		kfree(hcd->enum_flag);
+
+	if (hcd->uphy_disconnect_level)
+		kfree(hcd->uphy_disconnect_level);
+
 	mutex_unlock(&usb_port_peer_mutex);
 	kfree(hcd);
 }
@@ -2729,6 +2897,13 @@
 {
 	int retval;
 	struct usb_device *rhdev;
+#ifdef CONFIG_USB_PHY_RX_ACTIVE_QUESTION_WORKAROUND
+	u32 uphy_val;
+	int uphy_irq_ret = -1;
+	volatile u32 *uphy_disc;
+	int port_num;
+	struct platform_device *pdev;
+#endif
 
 	if (IS_ENABLED(CONFIG_USB_PHY) && !hcd->usb_phy) {
 		struct usb_phy *phy = usb_get_phy_dev(hcd->self.sysdev, 0);
@@ -2900,6 +3075,42 @@
 	if (hcd->uses_new_polling && HCD_POLL_RH(hcd))
 		usb_hcd_poll_rh_status(hcd);
 
+#ifdef CONFIG_USB_PHY_RX_ACTIVE_QUESTION_WORKAROUND
+	pdev = to_platform_device(hcd->self.controller);
+	if (hcd->driver->relinquish_port && pdev) {
+		port_num = pdev->id - 1;
+		switch (port_num) {
+		case 0:
+			hcd->uphy_irq_num = uphy0_irq_num;
+			uphy_val = readl(uphy0_base_addr + UPHY_INTR_OFFSET);
+			uphy_val |= 0x01;
+			writel(uphy_val, uphy0_base_addr + UPHY_INTR_OFFSET);
+			break;
+		case 1:
+			hcd->uphy_irq_num = uphy1_irq_num;
+			uphy_val = readl(uphy1_base_addr + UPHY_INTR_OFFSET);
+			uphy_val |= 0x01;
+			writel(uphy_val, uphy1_base_addr + UPHY_INTR_OFFSET);
+			break;
+		}
+
+		uphy_irq_ret = request_irq(hcd->uphy_irq_num,
+					   &usb_uphy_irq, IRQF_SHARED,
+					   "uphy-irq", hcd);
+		if (uphy_irq_ret) {
+			printk(KERN_NOTICE
+			       "requeset uphy irq fail,v:%x,r:%x,pn:%x,num:%x\n",
+			       uphy_val, uphy_irq_ret, port_num,
+			       hcd->uphy_irq_num);
+		} else {
+			printk(KERN_NOTICE
+			       "requeset uphy irq sucess,v:%x,r:%x,pn:%x,num:%x\n",
+			       uphy_val, uphy_irq_ret, port_num,
+			       hcd->uphy_irq_num);
+		}
+	}
+#endif
+
 	return retval;
 
 error_create_attr_group:
@@ -3015,6 +3226,12 @@
 	if (usb_hcd_is_primary_hcd(hcd)) {
 		if (hcd->irq > 0)
 			free_irq(hcd->irq, hcd);
+#ifdef CONFIG_USB_PHY_RX_ACTIVE_QUESTION_WORKAROUND
+		if (hcd->uphy_irq_num > 0) {
+			free_irq(hcd->uphy_irq_num, hcd);
+			printk(KERN_DEBUG "free uphy irq\n");
+		}
+#endif
 	}
 
 	usb_deregister_bus(&hcd->self);
--- a/drivers/usb/core/hub.c	2018-11-23 10:16:15.956819221 +0300
+++ a/drivers/usb/core/hub.c	2018-11-23 10:31:03.786051704 +0300
@@ -28,13 +28,23 @@
 #include <linux/mutex.h>
 #include <linux/random.h>
 #include <linux/pm_qos.h>
+#include <linux/kthread.h>
+#include <linux/freezer.h>
+
 
 #include <linux/uaccess.h>
 #include <asm/byteorder.h>
+#include <linux/platform_device.h>
+#include <linux/usb/sp_usb.h>
 
 #include "hub.h"
 #include "otg_whitelist.h"
 
+#if defined SYSCONFIG_MIRROR_LINK && SYSCONFIG_MIRROR_LINK
+#define SUPPORT_MIRRORLINK	/*later maybe use kconfig, sjhuang */
+#endif
+
+#define POWER_RESET_TIME			500
 #define USB_VENDOR_GENESYS_LOGIC		0x05e3
 #define HUB_QUIRK_CHECK_PORT_AUTOSUSPEND	0x01
 
@@ -42,10 +52,13 @@
  * Note: Both are also protected by ->dev.sem, except that ->state can
  * change to USB_STATE_NOTATTACHED even when the semaphore isn't held. */
 static DEFINE_SPINLOCK(device_state_lock);
+static DEFINE_SPINLOCK(hub_event_lock);
+static LIST_HEAD(hub_event_list);	/* List of hubs needing servicing */
 
+static DECLARE_WAIT_QUEUE_HEAD(khubd_wait);
 /* workqueue to process hub events */
-static struct workqueue_struct *hub_wq;
-static void hub_event(struct work_struct *work);
+static struct task_struct *khubd_task;
+static void hub_events(void);
 
 /* synchronize hub-port add/remove and peering operations */
 DEFINE_MUTEX(usb_port_peer_mutex);
@@ -101,9 +114,371 @@
 #define HUB_DEBOUNCE_STEP	  25
 #define HUB_DEBOUNCE_STABLE	 100
 
+#ifdef CONFIG_USB_HOST_ENUM_RETRY
+enum enum_retry_state {
+	HS_FIRST_START = 0,
+	HS_FIRST_ENUM,
+	/* did not reset vbus power when at above state */
+	HS_SECOND_START,
+	HS_SECOND_ENUM,
+	FS_FIRST_START,
+	FS_FIRST_ENUM
+};
+
+enum enum_retry_event {
+	ENUM_START = 0,
+	ENUM_START_RX_ACTIVE_HANDLE,
+	ENUM_SUCCESS_RUN_TOP_SPEED,
+	ENUM_SUCCESS_NOT_RUN_TOP_SPEED,
+	ENUM_FAIL_NOT_RX_ACTIVE,
+	ENUM_FAIL_RX_ACTIVE
+};
+
+enum retry_event_result {
+	HANDLE_FAIL = -1,
+	HANDLE_SUCCESS
+};
+
+#define STRING_NUM		10
+#define STRING_MAX_LENGTH	30
+static char enum_retry_status_string[STRING_NUM][STRING_MAX_LENGTH] = {
+	"hs_first_start",
+	"hs_first_enum",
+	"hs_second_start",
+	"hs_second_enum",
+	"fs_first_start",
+	"fs_first_enum"
+};
+
+static bool rx_active_not_run_ehci_flag[USB_PORT_NUM] = { false };
+
+static int enum_retry_status[USB_PORT_NUM] = { HS_FIRST_START };
+static int enum_success_times[USB_PORT_NUM] = { 0 };
+
+static bool handle_power_reset_retry_enum = true;
+module_param(handle_power_reset_retry_enum, bool, S_IRUGO | S_IWUSR);
+#endif
+
+#ifdef CONFIG_USB_LOGO_TEST
+unsigned short usb_idVendor = 0;
+unsigned short usb_idProduct = 0;
+unsigned int user_id = 0;
+module_param_named(id_enable, user_id, uint, S_IRUGO | S_IWUSR);
+MODULE_PARM_DESC(id_enable, "Use user id");
+module_param_named(idVendor, usb_idVendor, ushort, S_IRUGO | S_IWUSR);
+MODULE_PARM_DESC(idVendor, "User idVendor");
+module_param_named(idProduct, usb_idProduct, ushort, S_IRUGO | S_IWUSR);
+MODULE_PARM_DESC(idProduct, "User idProduct");
+#endif
+
 static void hub_release(struct kref *kref);
 static int usb_reset_and_verify_device(struct usb_device *udev);
 static int hub_port_disable(struct usb_hub *hub, int port1, int set_state);
+#ifdef CONFIG_USB_HOST_RESET_SP
+extern void reset_usb_powerx(struct usb_hcd *hcd, int delayms);
+#endif
+
+/* Note that hdev or one of its children must be locked! */
+static struct usb_hub *hdev_to_hub(struct usb_device *hdev)
+{
+	if (!hdev || !hdev->actconfig)
+		return NULL;
+	return usb_get_intfdata(hdev->actconfig->interface[0]);
+}
+
+#ifdef CONFIG_USB_HOST_ENUM_RETRY
+static int get_enum_retry_status(int port_num)
+{
+	int string_id;
+
+	string_id = enum_retry_status[port_num];
+	printk(KERN_NOTICE "############# %s\n",
+	       enum_retry_status_string[string_id]);
+
+	return enum_retry_status[port_num];
+}
+
+static void set_enum_retry_status(int port_num, int new_enum_retry_status)
+{
+	int string_id;
+
+	enum_retry_status[port_num] = new_enum_retry_status;
+	string_id = enum_retry_status[port_num];
+
+	printk(KERN_NOTICE "************* %s\n",
+	       enum_retry_status_string[string_id]);
+}
+
+static int enum_start_rx_active_handle(struct usb_hub *hub)
+{
+	int port_num;
+	struct usb_device *hdev = hub->hdev;
+	struct usb_hcd *hcd = bus_to_hcd(hdev->bus);
+	struct platform_device *pdev;
+
+	pdev = to_platform_device(hcd->self.controller);
+	port_num = pdev->id - 1;
+
+	if (hcd->driver->relinquish_port
+	    && rx_active_not_run_ehci_flag[port_num]) {
+		rx_active_not_run_ehci_flag[port_num] = false;
+		if (hcd->enum_port_status & USB_PORT_STAT_ENABLE)
+			hub_port_disable(hub, hcd->hub_port_num, 1);
+
+		printk(KERN_NOTICE "rx-active,switch to fs,retry enum\n");
+		hcd->driver->relinquish_port(hcd, hcd->hub_port_num);
+
+		return -1;
+	}
+	rx_active_not_run_ehci_flag[port_num] = false;
+
+	return 0;
+}
+
+static void enum_start_retry_status_handle(struct usb_hub *hub)
+{
+	int port_num;
+	int retry_status;
+	struct usb_device *hdev = hub->hdev;
+	struct usb_hcd *hcd = bus_to_hcd(hdev->bus);
+	struct platform_device *pdev;
+
+	pdev = to_platform_device(hcd->self.controller);
+	port_num = pdev->id - 1;
+
+	retry_status = get_enum_retry_status(port_num);
+	switch (retry_status) {
+	case HS_FIRST_START:
+		set_enum_retry_status(port_num, HS_FIRST_ENUM);
+		break;
+	case HS_SECOND_START:
+		set_enum_retry_status(port_num, HS_SECOND_ENUM);
+		break;
+	case FS_FIRST_START:
+		set_enum_retry_status(port_num, FS_FIRST_ENUM);
+		break;
+	default:
+		printk(KERN_NOTICE
+		       "not expect enum retry status, port:%d, status:%x\n",
+		       port_num, retry_status);
+		break;
+	}
+
+	hcd->hub_thread = current;
+	hcd->enum_flag[port_num] = true;
+	enum_rx_active_flag[port_num] = false;
+}
+
+static void enum_success_run_top_speed_handle(struct usb_hub *hub)
+{
+	int port_num;
+	struct usb_device *hdev = hub->hdev;
+	struct usb_hcd *hcd = bus_to_hcd(hdev->bus);
+	struct platform_device *pdev;
+
+	pdev = to_platform_device(hcd->self.controller);
+	port_num = pdev->id - 1;
+
+	hcd->hub_thread = NULL;
+	hcd->hub_port_num = 0;
+	hcd->enum_flag[port_num] = false;
+	enum_rx_active_flag[port_num] = false;
+	set_enum_retry_status(port_num, HS_FIRST_START);
+}
+
+static void enum_success_not_run_top_speed_handle(struct usb_hub *hub)
+{
+	int port_num;
+	int retry_status;
+	struct usb_device *hdev = hub->hdev;
+	struct usb_hcd *hcd = bus_to_hcd(hdev->bus);
+	struct platform_device *pdev;
+
+	pdev = to_platform_device(hcd->self.controller);
+	port_num = pdev->id - 1;
+
+	retry_status = get_enum_retry_status(port_num);
+	if (handle_power_reset_retry_enum) {
+		if (test_bit(USB_EHCI_LOADED, &usb_hcds_loaded)) {
+			/* did not reset vbus power when at HS_FIRST_ENUM state */
+			if ((HS_FIRST_ENUM == retry_status) && (!tid_test_flag)){
+				printk(KERN_NOTICE
+				       "usb vbus power reset to retry enum\n");
+				set_enum_retry_status(port_num, HS_SECOND_START);
+				reset_usb_powerx(hcd, POWER_RESET_TIME);
+			} else {
+				set_enum_retry_status(port_num, HS_FIRST_START);
+			}
+		}
+	}
+
+	hcd->hub_port_num = 0;
+	hcd->hub_thread = NULL;
+	hcd->enum_flag[port_num] = false;
+	enum_rx_active_flag[port_num] = false;
+}
+
+static void enum_fail_not_rx_active_handle(struct usb_hub *hub)
+{
+	int port_num;
+	u32 port_status;
+	int retry_status;
+	bool has_switch_fs_flag = false;
+	struct usb_device *hdev = hub->hdev;
+	struct usb_hcd *hcd = bus_to_hcd(hdev->bus);
+	struct platform_device *pdev;
+
+	pdev = to_platform_device(hcd->self.controller);
+	port_num = pdev->id - 1;
+
+	if (hcd->driver->relinquish_port) {
+		if (hcd->driver->get_port_status_from_register) {
+			port_status =
+			    hcd->driver->get_port_status_from_register(hcd);
+			if (port_status & PORT_OWNERSHIP) {
+				has_switch_fs_flag = true;
+				printk(KERN_NOTICE
+				       "Warn, has switched to OHCI, ps:%x\n",
+				       port_status);
+			}
+		}
+	}
+
+	retry_status = get_enum_retry_status(port_num);
+	if (handle_power_reset_retry_enum) {
+		switch (retry_status) {
+		case HS_FIRST_ENUM:
+			if(!tid_test_flag) {
+				printk(KERN_NOTICE
+				       "USB vbus power reset to retry enum\n");
+				set_enum_retry_status(port_num, HS_SECOND_START);
+				reset_usb_powerx(hcd, POWER_RESET_TIME);
+			} else {
+				if (hcd->driver->relinquish_port) {
+					set_enum_retry_status(port_num,
+							      FS_FIRST_START);
+					printk(KERN_NOTICE
+					       "fall to fs, retry enum\n");
+					hcd->driver->relinquish_port(hcd,
+						             hcd->hub_port_num);
+				} else {
+					set_enum_retry_status(port_num,
+						              HS_FIRST_START);
+				}
+			}
+			break;
+		case HS_SECOND_ENUM:
+			if (hcd->driver->relinquish_port) {
+				set_enum_retry_status(port_num, FS_FIRST_START);
+				printk(KERN_NOTICE "fall to fs, retry enum\n");
+				hcd->driver->relinquish_port(hcd,
+						             hcd->hub_port_num);
+			} else {
+				set_enum_retry_status(port_num, HS_FIRST_START);
+			}
+			break;
+		case FS_FIRST_ENUM:
+			if (has_switch_fs_flag) {
+				set_enum_retry_status(port_num, FS_FIRST_START);
+			} else {
+				set_enum_retry_status(port_num, HS_FIRST_START);
+			}
+			break;
+		default:
+			printk(KERN_NOTICE
+			       "not expect enum retry status, port:%d, status:%x\n",
+			       port_num, retry_status);
+			break;
+		}
+	} else {
+		printk(KERN_NOTICE
+		       "kernel not handle power reset retry enum\n");
+		if (hcd->driver->relinquish_port) {
+			printk(KERN_NOTICE
+			       "Fall to fs, retry enumerate device\n");
+			hcd->driver->relinquish_port(hcd, hcd->hub_port_num);
+		}
+	}
+
+	hcd->hub_port_num = 0;
+	hcd->hub_thread = NULL;
+	hcd->enum_flag[port_num] = false;
+}
+
+static void enum_fail_rx_active_handle(struct usb_hub *hub)
+{
+	int port_num;
+	int retry_status;
+	struct usb_device *hdev = hub->hdev;
+	struct usb_hcd *hcd = bus_to_hcd(hdev->bus);
+	struct platform_device *pdev;
+
+	pdev = to_platform_device(hcd->self.controller);
+	port_num = pdev->id - 1;
+
+	if (enum_rx_active_flag[port_num]) {
+		rx_active_not_run_ehci_flag[port_num] = true;
+		printk(KERN_NOTICE
+		       "rx-active question, wait reset driver & hw finish\n");
+		down(&enum_rx_active_reset_sem[port_num]);
+		if (hcd->driver->relinquish_port) {
+			printk(KERN_NOTICE "rx-active, fall to fs, retry enum\n");
+			hcd->driver->relinquish_port(hcd, hcd->hub_port_num);
+		}
+
+		retry_status = get_enum_retry_status(port_num);
+		switch (retry_status) {
+		case HS_FIRST_ENUM:
+			/* for the case that run not top speed in next enum */
+			set_enum_retry_status(port_num, HS_FIRST_START);
+			break;
+		case HS_SECOND_ENUM:
+			set_enum_retry_status(port_num, FS_FIRST_START);
+			break;
+		default:
+			printk(KERN_NOTICE
+			       "not expect enum retry status, port:%d, status:%d\n",
+			       port_num, retry_status);
+			break;
+		}
+
+		hcd->hub_port_num = 0;
+		hcd->hub_thread = NULL;
+		hcd->enum_flag[port_num] = false;
+		enum_rx_active_flag[port_num] = false;
+	}
+}
+
+static int enum_event_handle(struct usb_hub *hub, int event)
+{
+	switch (event) {
+	case ENUM_START_RX_ACTIVE_HANDLE:
+		if (-1 == enum_start_rx_active_handle(hub))
+			return HANDLE_FAIL;
+		break;
+	case ENUM_START:
+		enum_start_retry_status_handle(hub);
+		break;
+	case ENUM_SUCCESS_RUN_TOP_SPEED:
+		enum_success_run_top_speed_handle(hub);
+		break;
+	case ENUM_SUCCESS_NOT_RUN_TOP_SPEED:
+		enum_success_not_run_top_speed_handle(hub);
+		break;
+	case ENUM_FAIL_NOT_RX_ACTIVE:
+		enum_fail_not_rx_active_handle(hub);
+		break;
+	case ENUM_FAIL_RX_ACTIVE:
+		enum_fail_rx_active_handle(hub);
+		break;
+	default:
+		printk(KERN_NOTICE "now, not support event %x\n", event);
+		break;
+	}
+
+	return HANDLE_SUCCESS;
+}
+#endif	/* USB_HOST_ENUM_RETRY */
 
 static inline char *portspeed(struct usb_hub *hub, int portstatus)
 {
@@ -119,6 +494,29 @@
 		return "12 Mb/s";
 }
 
+#ifdef	CONFIG_RETRY_TIMES
+static int is_usb_high_bus(struct usb_bus *bus)
+{
+	struct usb_hcd *hcd;
+	int high = 0;
+
+	hcd = bus_to_hcd(bus);
+
+	switch (hcd->irq) {
+	case SP_IRQ_EHCI_USB0:
+	case SP_IRQ_EHCI_USB1:
+	case SP_IRQ_EHCI_USB2:
+		high = 1;
+		break;
+	default:
+		high = 0;
+		break;
+	}
+
+	return high;
+}
+#endif
+
 /* Note that hdev or one of its children must be locked! */
 struct usb_hub *usb_hub_to_struct_hub(struct usb_device *hdev)
 {
@@ -603,6 +1001,7 @@
 				   status, change, NULL);
 }
 
+#if 0
 static void kick_hub_wq(struct usb_hub *hub)
 {
 	struct usb_interface *intf;
@@ -629,13 +1028,29 @@
 	usb_autopm_put_interface_async(intf);
 	kref_put(&hub->kref, hub_release);
 }
+#endif
+static void kick_khubd(struct usb_hub *hub)
+{
+	unsigned long	flags;
+
+	spin_lock_irqsave(&hub_event_lock, flags);
+	if (!hub->disconnected && list_empty(&hub->event_list)) {
+		list_add_tail(&hub->event_list, &hub_event_list);
+
+		/* Suppress autosuspend until khubd runs */
+		usb_autopm_get_interface_no_resume(
+				to_usb_interface(hub->intfdev));
+		wake_up(&khubd_wait);
+	}
+	spin_unlock_irqrestore(&hub_event_lock, flags);
+}
 
 void usb_kick_hub_wq(struct usb_device *hdev)
 {
 	struct usb_hub *hub = usb_hub_to_struct_hub(hdev);
 
 	if (hub)
-		kick_hub_wq(hub);
+		kick_khubd(hub);
 }
 
 /*
@@ -657,7 +1072,7 @@
 	hub = usb_hub_to_struct_hub(hdev);
 	if (hub) {
 		set_bit(portnum, hub->wakeup_bits);
-		kick_hub_wq(hub);
+		kick_khubd(hub);
 	}
 }
 EXPORT_SYMBOL_GPL(usb_wakeup_notification);
@@ -697,7 +1112,7 @@
 	hub->nerrors = 0;
 
 	/* Something happened, let hub_wq figure it out */
-	kick_hub_wq(hub);
+	kick_khubd(hub);
 
 resubmit:
 	if (hub->quiescing)
@@ -930,7 +1345,7 @@
 	 */
 
 	set_bit(port1, hub->change_bits);
-	kick_hub_wq(hub);
+	kick_khubd(hub);
 }
 
 /**
@@ -1209,7 +1624,7 @@
 				&hub->leds, LED_CYCLE_PERIOD);
 
 	/* Scan all ports that need attention */
-	kick_hub_wq(hub);
+	kick_khubd(hub);
  abort:
 	if (type == HUB_INIT2 || type == HUB_INIT3) {
 		/* Allow autosuspend if it was suppressed */
@@ -1628,7 +2043,14 @@
 	 * Stop adding new hub events. We do not want to block here and thus
 	 * will not try to remove any pending work item.
 	 */
+	/* Take the hub off the event list and don't let it be added again */
+	spin_lock_irq(&hub_event_lock);
+	if (!list_empty(&hub->event_list)) {
+		list_del_init(&hub->event_list);
+		usb_autopm_put_interface_no_suspend(intf);
+	}
 	hub->disconnected = 1;
+	spin_unlock_irq(&hub_event_lock);
 
 	/* Disconnect all children and quiesce the hub */
 	hub->error = 0;
@@ -1766,11 +2188,11 @@
 		return -ENOMEM;
 
 	kref_init(&hub->kref);
+	INIT_LIST_HEAD(&hub->event_list);
 	hub->intfdev = &intf->dev;
 	hub->hdev = hdev;
 	INIT_DELAYED_WORK(&hub->leds, led_work);
 	INIT_DELAYED_WORK(&hub->init_work, NULL);
-	INIT_WORK(&hub->events, hub_event);
 	usb_get_intf(intf);
 	usb_get_dev(hdev);
 
@@ -2040,6 +2462,28 @@
 	if (udev->devnum > 0) {
 		clear_bit(udev->devnum, udev->bus->devmap.devicemap);
 		udev->devnum = -1;
+#ifdef CONFIG_USB_HOST_RESET_SP_
+		struct usb_hcd *hcd = bus_to_hcd(udev->bus);
+		u32 *ptr;
+
+		if ((hcd->self.root_hub->speed == USB_SPEED_HIGH)
+		    && (hcd->self.root_hub->speed != udev->speed))
+			return;
+
+		/* point to the */
+		ptr = (u32 *)((u8 *)hcd->hcd_priv
+			      + hcd->driver->hcd_priv_size
+			      - sizeof(wait_queue_head_t) - sizeof(u32));
+		if (!ptr)
+			return;
+
+		if (udev->bus->devmap.devicemap[0] < 2)
+			*(ptr + sizeof(wait_queue_head_t) / 4) &= ~1;
+		else {
+			*(ptr + sizeof(wait_queue_head_t) / 4) |= 1;
+			wake_up_interruptible((wait_queue_head_t *)ptr);
+		}
+#endif
 	}
 }
 
@@ -2071,6 +2515,32 @@
 	}
 }
 
+#ifdef CONFIG_USB_HOST_RESET_SP
+void reset_usb_wake_up(struct usb_device *udev)
+{
+	struct usb_hcd *hcd = bus_to_hcd(udev->bus);
+	u32 *ptr_flag;
+
+	/* low & full speed both use OHCI */
+	if ((hcd->self.root_hub->speed == USB_SPEED_HIGH)
+	    && (hcd->self.root_hub->speed != udev->speed))
+		return;
+
+	ptr_flag = hcd->ptr_flag;
+	if (!ptr_flag)
+		return;
+
+	/* printk("<<<###*###>> %ld\n",udev->bus->devmap.devicemap[0]); */
+
+	if (udev->bus->devmap.devicemap[0] < 2)
+		*(ptr_flag) &= ~1;
+	else {
+		*(ptr_flag) |= 1;
+		wake_up_interruptible(&hcd->reset_queue);
+	}
+}
+#endif
+
 /**
  * usb_disconnect - disconnect a device (usbcore-internal)
  * @pdev: pointer to device being disconnected
@@ -2150,6 +2620,16 @@
 	 */
 	release_devnum(udev);
 
+#ifdef CONFIG_USB_HOST_RESET_SP
+#ifdef CONFIG_RETRY_TIMES
+	if (udev->reset_count != 0 || !is_usb_high_bus(udev->bus)) {
+		reset_usb_wake_up(udev);
+	}
+#else
+	reset_usb_wake_up(udev);
+#endif
+#endif
+
 	/* Avoid races with recursively_mark_NOTATTACHED() */
 	spin_lock_irq(&device_state_lock);
 	*pdev = NULL;
@@ -2262,6 +2742,95 @@
 	return err;
 }
 
+#ifdef SUPPORT_MIRRORLINK
+#define HOST_ID			0x4C05
+#define MIRROR_LINK_VER		0x0101
+#define MIRROR_LINK_DELAY_TIME_MS 1000
+
+enum mirror_link_cmd_state_e {
+	MIRRORLINK_CMD_IDLE = 0,
+	MIRRORLINK_CMD_SEND,
+	MIRRORLINK_CMD_WAIT,
+	MIRRORLINK_CMD_END,
+};
+
+enum mirror_link_cmd_state_e mirror_link_cmd_state;
+int usb_mirrorlink_configuration(struct usb_device *dev, int configuration)
+{
+	int i, ret;
+	struct usb_host_config *cp = NULL;
+	struct usb_interface_descriptor *intf_des;
+	int nintf;
+	int ncm_found = 0;
+
+	if (mirror_link_cmd_state != MIRRORLINK_CMD_IDLE)
+		return 0;
+
+	for (i = 0; i < dev->descriptor.bNumConfigurations; i++) {
+		cp = &dev->config[i];
+		if (!cp) {
+			printk("%s %d\n", __FUNCTION__, __LINE__);
+			return -EINVAL;
+		}
+		nintf = cp->desc.bNumInterfaces;
+		for (i = 0; i < nintf; ++i) {
+			if (NULL == cp->intf_cache[i]) {
+				break;
+			}
+			intf_des = &(cp->intf_cache[i]->altsetting[0].desc);
+
+			if (intf_des->bInterfaceClass == USB_CLASS_HUB) {	/* hub not send */
+				return 0;
+			} else if ((intf_des->bInterfaceClass == USB_CLASS_COMM)
+				   && (intf_des->bInterfaceSubClass == 0x0D)) {
+				ncm_found = 1;
+				break;
+			}
+		}
+	}
+
+	/*
+	 * ADATA udisk vid 0x125F pid 0x312B, will stall & reset.
+	 * Do not send MirrorLink cmd
+	 */
+	if ((dev->descriptor.idProduct == 0x312B)
+	    && (dev->descriptor.idVendor == 0x125F))
+		return 0;
+
+	ret = usb_control_msg(dev, usb_sndctrlpipe(dev, 0),
+			      0xF0, 0x40, cpu_to_be16(MIRROR_LINK_VER),
+			      cpu_to_be16(HOST_ID), NULL, 0, 1000);
+	printk("\tmirror_link cmd] ret =%d (0x%x)\n", ret, ret);
+	if ((!ncm_found) || (ret == -EPIPE)) {
+		printk("Try change to NCM mode ... reset port =%d\n",
+		       dev->portnum);
+		mirror_link_cmd_state = MIRRORLINK_CMD_WAIT;
+		return -1;
+	}
+
+	mirror_link_cmd_state = MIRRORLINK_CMD_SEND;
+	return 0;
+}
+
+static void wait_connect_change(struct usb_device *dev)
+{
+	u16 portstatus;
+	u16 portchange;
+	struct usb_hub *hub = hdev_to_hub(dev->parent);
+
+	if (mirror_link_cmd_state != MIRRORLINK_CMD_WAIT)
+		return;
+
+	printk("\twait +++++++++++\n");
+	msleep(MIRROR_LINK_DELAY_TIME_MS);
+	printk("\twait -----------\n");
+	hub_port_status(hub, dev->portnum, &portstatus, &portchange);
+	printk("\t%s portstatus=%x portchange=%x\n",
+	       __FUNCTION__, portstatus, portchange);
+	mirror_link_cmd_state = MIRRORLINK_CMD_END;
+}
+#endif	/* SUPPORT_MIRRORLINK */
+
 
 /**
  * usb_enumerate_device - Read device configs/intfs/otg (usbcore-internal)
@@ -2399,6 +2968,9 @@
 int usb_new_device(struct usb_device *udev)
 {
 	int err;
+#ifdef SUPPORT_MIRRORLINK
+	int c;
+#endif
 
 	if (udev->parent) {
 		/* Initialize non-root-hub device wakeup to disabled;
@@ -2419,9 +2991,35 @@
 	 */
 	usb_disable_autosuspend(udev);
 
+#ifdef CONFIG_USB_BAD_DEVICE_INFO
+	if (udev->descriptor.bDeviceClass != USB_CLASS_DEVICE_NOT_SUPPORT) {
+
+		err = usb_enumerate_device(udev);	/* Read descriptors */
+		if (err < 0)
+			goto fail;
+#ifdef SUPPORT_MIRRORLINK
+		if (mirror_link_cmd_state == MIRRORLINK_CMD_IDLE) {
+			c = usb_choose_configuration(udev);
+			err = usb_mirrorlink_configuration(udev, c);
+			if (err)
+				return err;
+		}
+#endif
+	}
+#else
+
 	err = usb_enumerate_device(udev);	/* Read descriptors */
 	if (err < 0)
 		goto fail;
+#ifdef SUPPORT_MIRRORLINK
+	if (mirror_link_cmd_state == MIRRORLINK_CMD_IDLE) {
+		c = usb_choose_configuration(udev);
+		err = usb_mirrorlink_configuration(udev, c);
+		if (err)
+			return err;
+	}
+#endif
+#endif	/* CONFIG_USB_BAD_DEVICE_INFO */
 	dev_dbg(&udev->dev, "udev %d, busnum %d, minor = %d\n",
 			udev->devnum, udev->bus->busnum,
 			(((udev->bus->busnum-1) * 128) + (udev->devnum-1)));
@@ -2703,8 +3301,10 @@
 		return -ENOTCONN;
 
 	/* Device went away? */
-	if (!(portstatus & USB_PORT_STAT_CONNECTION))
+	if (!(portstatus & USB_PORT_STAT_CONNECTION)){
+		printk(KERN_NOTICE "Warn,dev disc during wait reset finish\n");
 		return -ENOTCONN;
+	}
 
 	/* Retry if connect change is set but status is still connected.
 	 * A USB 3.0 connection may bounce if multiple warm resets were issued,
@@ -2714,6 +3314,7 @@
 	    (portchange & USB_PORT_STAT_C_CONNECTION)) {
 		usb_clear_port_feature(hub->hdev, port1,
 				       USB_PORT_FEAT_C_CONNECTION);
++		printk(KERN_NOTICE "Warning! Connection status change\n");
 		return -EAGAIN;
 	}
 
@@ -2782,6 +3383,9 @@
 					"cannot %sreset (err = %d)\n",
 					warm ? "warm " : "", status);
 		} else {
+#ifdef SUPPORT_MIRRORLINK
+			wait_connect_change(udev);
+#endif
 			status = hub_port_wait_reset(hub, port1, udev, delay,
 								warm);
 			if (status && status != -ENOTCONN && status != -ENODEV)
@@ -4329,6 +4933,99 @@
 	return hcd->driver->enable_device(hcd, udev);
 }
 
+#ifdef CONFIG_USB_LOGO_TEST
+u32 usb_logo_test_start = 0;	/* ns (0 for disable) */
+module_param(usb_logo_test_start, uint, 0644);
+EXPORT_SYMBOL_GPL(usb_logo_test_start);
+
+static int usb_logo_thread(void *arg)
+{
+	struct usb_device *udev = (struct usb_device *)arg;
+	struct usb_hcd *hcd = bus_to_hcd(udev->bus);
+	struct usb_hub *hub = hdev_to_hub(udev->parent);
+	struct usb_device_descriptor *buf = NULL;
+
+	int retval = 0;
+
+	u16 idVendor;
+	u16 idProduct;
+
+	idVendor  = udev->descriptor.idVendor;
+	idProduct = udev->descriptor.idProduct;
+
+	if (udev->speed == USB_SPEED_LOW) {
+#include <mach/io_map.h>
+		void __iomem *regs = (void __iomem *)B_SYSTEM_BASE;
+
+		writel(RF_MASK_V(0xffff, 0x0002), regs + UPHY0_CTL0_OFFSET);
+		writel(RF_MASK_V(0xffff, 0x8000), regs + UPHY0_CTL1_OFFSET);
+		writel(RF_MASK_V(0xffff, 0x0004), regs + UPHY1_CTL0_OFFSET);
+		writel(RF_MASK_V(0xffff, 0x8000), regs + UPHY1_CTL1_OFFSET);
+	}
+
+	while (usb_logo_test_start == 0) {
+		msleep(500);
+	}
+
+	if (hub) {
+		retval = hub_port_reset(hub, udev->portnum,
+					udev, HUB_SHORT_RESET_TIME, false);
+		if (retval < 0)
+			goto fail;
+	}
+
+	if (udev->speed != USB_SPEED_HIGH) {
+		retval = -1;
+		printk("usb test mode,not high speed device\n");
+		goto fail;
+	}
+	switch (idProduct) {
+	case 0x0107:
+		printk("Test_DESC_EHCI\n");
+
+		buf = kmalloc(64, GFP_KERNEL);
+		if (!buf) {
+			retval = -ENOMEM;
+			goto fail;
+		}
+
+		do {
+			msleep(15000);
+			retval = usb_control_msg(udev,
+						 usb_rcvaddr0pipe(),
+						 USB_REQ_GET_DESCRIPTOR,
+						 USB_DIR_IN,
+						 USB_DT_DEVICE << 8, 0,
+						 buf, 64,
+						 initial_descriptor_timeout);
+			if (retval < 0) {
+				printk(KERN_NOTICE
+				       "usb_control_msg fail[%d]\n",retval);
+				goto fail;
+			}
+		} while (!kthread_should_stop());
+		break;
+	case 0x0101:
+	case 0x0102:
+	case 0x0103:
+	case 0x0104:
+	case 0x0106:
+	case 0x0108:
+		hcd->driver->usb_logo_test(hcd, idProduct);
+		break;
+	}
+
+fail:
+#if 0
+	if (buf) {
+		kfree(buf);
+		buf = NULL;
+	}
+#endif
+	return retval;
+}
+#endif	/* CONFIG_USB_LOGO_TEST */
+
 /* Reset device, (re)assign address, get device descriptor.
  * Device connection must be stable, no more debouncing needed.
  * Returns device in USB_STATE_ADDRESS, except on error.
@@ -4343,6 +5040,7 @@
 hub_port_init(struct usb_hub *hub, struct usb_device *udev, int port1,
 		int retry_counter)
 {
+	int			j;
 	struct usb_device	*hdev = hub->hdev;
 	struct usb_hcd		*hcd = bus_to_hcd(hdev->bus);
 	int			retries, operations, retval, i;
@@ -4417,6 +5115,7 @@
 	else
 		speed = usb_speed_string(udev->speed);
 
+	printk(KERN_DEBUG "\n\n### ===\tusb start enum\t=\n");
 	if (udev->speed < USB_SPEED_SUPER)
 		dev_info(&udev->dev,
 				"%s %s USB device number %d using %s\n",
@@ -4477,13 +5176,29 @@
 			 * 255 is for WUSB devices, we actually need to use
 			 * 512 (WUSB1.0[4.8.1]).
 			 */
+			printk(KERN_DEBUG "Start get dev descriptor\n");
 			for (operations = 0; operations < 3; ++operations) {
 				buf->bMaxPacketSize0 = 0;
+				hcd->enum_msg_flag = true;
 				r = usb_control_msg(udev, usb_rcvaddr0pipe(),
 					USB_REQ_GET_DESCRIPTOR, USB_DIR_IN,
 					USB_DT_DEVICE << 8, 0,
 					buf, GET_DESCRIPTOR_BUFSIZE,
 					initial_descriptor_timeout);
+				hcd->enum_msg_flag = false;
+				if (r < 0) {
+					printk(KERN_NOTICE
+					       "\n### Check your USB cable(ret=%d)... retry[%d]\n",
+					       r, operations);
+#ifdef CONFIG_USB_HOST_NOT_FINISH_QTD_WHEN_DISC_WORKAROUND
+					if (-ENOTCONN == r) {
+						printk(KERN_NOTICE
+						       "***Warn,dev disc during get dev descriptor***\n");
+						retval = -ENOTCONN;
+						goto fail;
+					}
+#endif
+				}
 				switch (buf->bMaxPacketSize0) {
 				case 8: case 16: case 32: case 64: case 255:
 					if (buf->bDescriptorType ==
@@ -4495,6 +5210,17 @@
 				default:
 					if (r == 0)
 						r = -EPROTO;
+#ifdef CONFIG_RETRY_TIMES
+					if ((hdev->speed == USB_SPEED_HIGH)
+					    && (r < 0) && (j == 2)) {
+						printk(KERN_NOTICE
+						       "Waring: down to full speed\n");
+						retval = -ENOTCONN;
+						udev->reset_count = 0;
+						kfree(buf);
+						goto fail;
+					}
+#endif
 					break;
 				}
 				/*
@@ -4506,6 +5232,7 @@
 				if (r == 0  || (r == -ETIMEDOUT && retries == 0))
 					break;
 			}
+			printk(KERN_DEBUG "End get dev descriptor\n");
 			udev->descriptor.bMaxPacketSize0 =
 					buf->bMaxPacketSize0;
 			kfree(buf);
@@ -4520,9 +5247,21 @@
 				goto fail;
 			}
 			if (r) {
+#ifdef CONFIG_USB_BAD_DEVICE_INFO
+				u16 status, change;
+#endif
+
 				if (r != -ENODEV)
 					dev_err(&udev->dev, "device descriptor read/64, error %d\n",
 							r);
+#ifdef CONFIG_USB_BAD_DEVICE_INFO
+				hub_port_status(hub, port1, &status, &change);
+				if (status & USB_PORT_STAT_CONNECTION) {
+					udev->descriptor.bDeviceClass =
+					    USB_CLASS_DEVICE_NOT_SUPPORT;
+					udev->speed = USB_SPEED_HIGH;
+				}
+#endif
 				retval = -EMSGSIZE;
 				continue;
 			}
@@ -4536,7 +5275,12 @@
 		 */
 		if (udev->wusb == 0) {
 			for (operations = 0; operations < SET_ADDRESS_TRIES; ++operations) {
+				printk(KERN_DEBUG
+				       "[usbENUM]%s [%d] %p address [%d]\n",
+				       __FUNCTION__, __LINE__, udev, j);
+				hcd->enum_msg_flag = true;
 				retval = hub_set_address(udev, devnum);
+				hcd->enum_msg_flag = false;
 				if (retval >= 0)
 					break;
 				msleep(200);
@@ -4621,7 +5365,9 @@
 		usb_ep0_reinit(udev);
 	}
 
+	hcd->enum_msg_flag = true;
 	retval = usb_get_device_descriptor(udev, USB_DT_DEVICE_SIZE);
+	hcd->enum_msg_flag = false;
 	if (retval < (signed)sizeof(udev->descriptor)) {
 		if (retval != -ENODEV)
 			dev_err(&udev->dev, "device descriptor read/all, error %d\n",
@@ -4641,16 +5387,20 @@
 		}
 	}
 
+	printk(KERN_DEBUG "[usbENUM][%d] init end\n", __LINE__);
 	retval = 0;
 	/* notify HCD that we have a device connected and addressed */
 	if (hcd->driver->update_device)
 		hcd->driver->update_device(hcd, udev);
 	hub_set_initial_usb2_lpm_policy(udev);
 fail:
+	printk(KERN_DEBUG "[usbENUM]%s [%d] ret:%d\n",
+	       __FUNCTION__, __LINE__, retval);
 	if (retval) {
 		hub_port_disable(hub, port1, 0);
 		update_devnum(udev, devnum);	/* for disconnect processing */
 	}
+	printk(KERN_DEBUG "[usbENUM]%s [%d] --\n", __FUNCTION__, __LINE__);
 	mutex_unlock(hcd->address0_mutex);
 	return retval;
 }
@@ -4679,6 +5429,11 @@
 			queue_delayed_work(system_power_efficient_wq,
 					&hub->leds, 0);
 		}
+#ifdef CONFIG_USB_HOST_ENUM_RETRY
+		if (!hub->hdev->parent) {
+			enum_event_handle(hub, ENUM_SUCCESS_NOT_RUN_TOP_SPEED);
+		}
+#endif
 	}
 	kfree(qual);
 }
@@ -4735,18 +5490,48 @@
 {
 	int status = -ENODEV;
 	int i;
+	int port_num = 0;
 	unsigned unit_load;
+	struct platform_device *pdev;
 	struct usb_device *hdev = hub->hdev;
 	struct usb_hcd *hcd = bus_to_hcd(hdev->bus);
 	struct usb_port *port_dev = hub->ports[port1 - 1];
 	struct usb_device *udev = port_dev->child;
 	static int unreliable_port = -1;
+#ifdef CONFIG_USB_LOGO_TEST
+	u16 idVendor;
+	u16 idProduct;
+#endif
+
+	printk(KERN_DEBUG "%s start\n",__FUNCTION__);
+	if (!hub->hdev->parent) {
+		if (hcd->driver->relinquish_port) {
+			printk(KERN_NOTICE "Run in EHCI\n");
+		} else {
+			printk(KERN_NOTICE "Run in OHCI\n");
+		}
+		pdev = to_platform_device(hcd->self.controller);
+		if (pdev) {
+			port_num = pdev->id - 1;
+			printk(KERN_NOTICE "port num is %d\n", port_num);
+		}
+	}
 
 	/* Disconnect any existing devices under this port */
 	if (udev) {
+#ifdef CONFIG_RETRY_TIMES
+		int count = udev->reset_count;
+#endif
 		if (hcd->usb_phy && !hdev->parent)
 			usb_phy_notify_disconnect(hcd->usb_phy, udev->speed);
 		usb_disconnect(&port_dev->child);
+#ifdef CONFIG_RETRY_TIMES
+		if (count == 0) {
+			printk("%s %d %d\n", __func__, __LINE__, count);
+			clear_bit(port1, hub->change_bits);
+			goto done;
+		}
+#endif
 	}
 
 	/* We can forget about a "removed" device when there's a physical
@@ -4758,6 +5543,7 @@
 
 	if (portchange & (USB_PORT_STAT_C_CONNECTION |
 				USB_PORT_STAT_C_ENABLE)) {
+		printk(KERN_NOTICE "Warn, dev disc after debounce\n");
 		status = hub_port_debounce_be_stable(hub, port1);
 		if (status < 0) {
 			if (status != -ENODEV &&
@@ -4796,6 +5582,20 @@
 		unit_load = 100;
 
 	status = 0;
+#ifdef SUPPORT_MIRRORLINK
+	mirror_link_cmd_state = MIRRORLINK_CMD_IDLE;
+#endif
+#ifdef CONFIG_USB_HOST_ENUM_RETRY
+	if (!hub->hdev->parent) {
+		hcd->hub_port_num = port1;
+		hcd->enum_port_status = portstatus;
+		if (HANDLE_FAIL == enum_event_handle(hub,
+						     ENUM_START_RX_ACTIVE_HANDLE))
+			return;
+
+		enum_event_handle(hub, ENUM_START);
+	}
+#endif
 	for (i = 0; i < SET_CONFIG_TRIES; i++) {
 
 		/* reallocate for each attempt, since references
@@ -4826,12 +5626,29 @@
 		}
 
 		/* reset (non-USB 3.0 devices) and get descriptor */
+		printk(KERN_DEBUG
+		       "[usbENUM]%s [%d]hub_port_init++\n",
+		       __FUNCTION__, __LINE__);
 		usb_lock_port(port_dev);
 		status = hub_port_init(hub, udev, port1, i);
 		usb_unlock_port(port_dev);
+		printk(KERN_DEBUG "[usbENUM]%s [%d]hub_port_init-- %d(%x)\n",
+				       __FUNCTION__, __LINE__, status, status);
+#ifdef CONFIG_USB_BAD_DEVICE_INFO
+		if (tid_test_flag) {
+			if (status < 0) {
+				if (udev->descriptor.bDeviceClass !=
+				    USB_CLASS_DEVICE_NOT_SUPPORT)
+					goto loop;
+			}
+		} else {
+			if (status < 0)
+				goto loop;
+		}
+#else
 		if (status < 0)
 			goto loop;
-
+#endif
 		if (udev->quirks & USB_QUIRK_DELAY_INIT)
 			msleep(2000);
 
@@ -4867,12 +5684,13 @@
 			}
 		}
 
+#if 0
 		/* check for devices running slower than they could */
 		if (le16_to_cpu(udev->descriptor.bcdUSB) >= 0x0200
 				&& udev->speed == USB_SPEED_FULL
 				&& highspeed_hubs != 0)
 			check_highspeed(hub, udev, port1);
-
+#endif
 		/* Store the parent's children[] pointer.  At this point
 		 * udev becomes globally accessible, although presumably
 		 * no one will look at it until hdev is unlocked.
@@ -4895,7 +5713,17 @@
 
 		/* Run it through the hoops (find a driver, etc) */
 		if (!status) {
+			printk(KERN_DEBUG "[usbENUM][%d] new\n", __LINE__);
 			status = usb_new_device(udev);
+#ifdef SUPPORT_MIRRORLINK
+			if (status == -1) {
+				i--;
+				spin_lock_irq(&device_state_lock);
+				hdev->children[port1 - 1] = NULL;
+				spin_unlock_irq(&device_state_lock);
+				goto loop;
+			}
+#endif
 			if (status) {
 				mutex_lock(&usb_port_peer_mutex);
 				spin_lock_irq(&device_state_lock);
@@ -4916,6 +5744,62 @@
 		if (status)
 			dev_dbg(hub->intfdev, "%dmA power budget left\n", status);
 
+#ifdef CONFIG_USB_LOGO_TEST
+		if (user_id == 0) {
+			idVendor  = udev->descriptor.idVendor;
+			idProduct = udev->descriptor.idProduct;
+		} else {
+			idVendor  = 0x1A0A;
+			idProduct = usb_idProduct;
+
+			udev->descriptor.idVendor = 0x1A0A;
+			udev->descriptor.idProduct = usb_idProduct;
+
+			user_id = 0;
+			/* udev->descriptor.bDeviceClass = 0x1F; */
+		}
+
+		if ((idVendor == 0x1A0A)
+		    && (idProduct == 0x0101
+			|| idProduct == 0x0102
+			|| idProduct == 0x0103
+			|| idProduct == 0x0104
+			|| idProduct == 0x0106
+			|| idProduct == 0x0107
+			|| idProduct == 0x0108)) {
+			hub->usb_logo_thread = kthread_create(usb_logo_thread,
+							      udev,
+							      "usb_logo_test");
+			wake_up_process(hub->usb_logo_thread);
+			printk(KERN_NOTICE "@@@idVendor = 0x%x idProduct= 0x%x\n",
+			       udev->descriptor.idVendor, udev->descriptor.idProduct);
+		}
+#endif
+
+		/* check for devices running slower than they could */
+		if (le16_to_cpu(udev->descriptor.bcdUSB) >= 0x0200
+				&& udev->speed == USB_SPEED_FULL
+				&& highspeed_hubs != 0)
+			check_highspeed (hub, udev, port1);
+
+#ifdef CONFIG_USB_HOST_ENUM_RETRY
+		else if (!hub->hdev->parent) {
+			if (!enum_rx_active_flag[port_num]) {
+				enum_event_handle(hub,
+						  ENUM_SUCCESS_RUN_TOP_SPEED);
+			} else {
+				break;
+			}
+		}
+#endif
+		if (!hub->hdev->parent) {
+			enum_success_times[port_num]++;
+			printk(KERN_DEBUG "port_num:%d,enum success times:%d\n",
+			       port_num, enum_success_times[port_num]);
+		}
+		printk(KERN_DEBUG "########################\n");
+		printk(KERN_DEBUG "Enumerate Device Success\n");
+		printk(KERN_DEBUG "########################\n");
 		return;
 
 loop_disable:
@@ -4946,11 +5830,18 @@
 	}
 
 done:
+	printk(KERN_DEBUG "[usbENUM]%s [%d] status:%d----\n",
+	       __FUNCTION__, __LINE__, status);
 	hub_port_disable(hub, port1, 1);
-	if (hcd->driver->relinquish_port && !hub->hdev->parent) {
-		if (status != -ENOTCONN && status != -ENODEV)
-			hcd->driver->relinquish_port(hcd, port1);
+#ifdef CONFIG_USB_HOST_ENUM_RETRY
+	if (!hub->hdev->parent && !enum_rx_active_flag[port_num]) {
+		enum_event_handle(hub, ENUM_FAIL_NOT_RX_ACTIVE);
 	}
+#else
+	if (hcd->driver->relinquish_port && !hub->hdev->parent)
+		hcd->driver->relinquish_port(hcd, port1);
+#endif
+	printk(KERN_DEBUG "%s end\n",__FUNCTION__);
 }
 
 /* Handle physical or logical connection change events.
@@ -4969,6 +5860,7 @@
 	struct usb_device *udev = port_dev->child;
 	int status = -ENODEV;
 
+	printk(KERN_NOTICE "%s in\n", __FUNCTION__);
 	dev_dbg(&port_dev->dev, "status %04x, change %04x, %s\n", portstatus,
 			portchange, portspeed(hub, portstatus));
 
@@ -5012,6 +5904,7 @@
 	usb_unlock_port(port_dev);
 	hub_port_connect(hub, port1, portstatus, portchange);
 	usb_lock_port(port_dev);
+	printk(KERN_NOTICE "%s out\n", __FUNCTION__);
 }
 
 static void port_event(struct usb_hub *hub, int port1)
@@ -5023,6 +5916,7 @@
 	struct usb_device *hdev = hub->hdev;
 	u16 portstatus, portchange;
 
+	printk(KERN_NOTICE "%s in\n",__FUNCTION__);
 	connect_change = test_bit(port1, hub->change_bits);
 	clear_bit(port1, hub->event_bits);
 	clear_bit(port1, hub->wakeup_bits);
@@ -5119,8 +6013,9 @@
 		hub_port_connect_change(hub, port1, portstatus, portchange);
 }
 
-static void hub_event(struct work_struct *work)
+static void hub_events(void)
 {
+	struct list_head *tmp;
 	struct usb_device *hdev;
 	struct usb_interface *intf;
 	struct usb_hub *hub;
@@ -5129,117 +6024,149 @@
 	u16 hubchange;
 	int i, ret;
 
-	hub = container_of(work, struct usb_hub, events);
-	hdev = hub->hdev;
-	hub_dev = hub->intfdev;
-	intf = to_usb_interface(hub_dev);
-
-	dev_dbg(hub_dev, "state %d ports %d chg %04x evt %04x\n",
-			hdev->state, hdev->maxchild,
-			/* NOTE: expects max 15 ports... */
-			(u16) hub->change_bits[0],
-			(u16) hub->event_bits[0]);
-
-	/* Lock the device, then check to see if we were
-	 * disconnected while waiting for the lock to succeed. */
-	usb_lock_device(hdev);
-	if (unlikely(hub->disconnected))
-		goto out_hdev_lock;
-
-	/* If the hub has died, clean up after it */
-	if (hdev->state == USB_STATE_NOTATTACHED) {
-		hub->error = -ENODEV;
-		hub_quiesce(hub, HUB_DISCONNECT);
-		goto out_hdev_lock;
-	}
-
-	/* Autoresume */
-	ret = usb_autopm_get_interface(intf);
-	if (ret) {
-		dev_dbg(hub_dev, "Can't autoresume: %d\n", ret);
-		goto out_hdev_lock;
-	}
-
-	/* If this is an inactive hub, do nothing */
-	if (hub->quiescing)
-		goto out_autopm;
+	while (1) {
+		/* Grab the first entry at the beginning of the list */
+		spin_lock_irq(&hub_event_lock);
+		if (list_empty(&hub_event_list)) {
+			spin_unlock_irq(&hub_event_lock);
+			break;
+		}
+		tmp = hub_event_list.next;
+		list_del_init(tmp);
 
-	if (hub->error) {
-		dev_dbg(hub_dev, "resetting for error %d\n", hub->error);
+		hub = list_entry(tmp, struct usb_hub, event_list);
+		kref_get(&hub->kref);
+		hdev = hub->hdev;
+		usb_get_dev(hdev);
+		spin_unlock_irq(&hub_event_lock);
+
+		hub_dev = hub->intfdev;
+		intf = to_usb_interface(hub_dev);
+		dev_dbg(hub_dev, "state %d ports %d chg %04x evt %04x\n",
+				hdev->state, hdev->maxchild,
+				/* NOTE: expects max 15 ports... */
+				(u16) hub->change_bits[0],
+				(u16) hub->event_bits[0]);
+
+		/* Lock the device, then check to see if we were
+		 * disconnected while waiting for the lock to succeed. */
+		usb_lock_device(hdev);
+		if (unlikely(hub->disconnected))
+			goto out_hdev_lock;
+
+		/* If the hub has died, clean up after it */
+		if (hdev->state == USB_STATE_NOTATTACHED) {
+			hub->error = -ENODEV;
+			hub_quiesce(hub, HUB_DISCONNECT);
+			goto out_hdev_lock;
+		}
+
+		/* If the hub has died, clean up after it */
+		if (hdev->state == USB_STATE_NOTATTACHED) {
+			hub->error = -ENODEV;
+			hub_quiesce(hub, HUB_DISCONNECT);
+			goto loop;
+		}
 
-		ret = usb_reset_device(hdev);
+		/* Autoresume */
+		ret = usb_autopm_get_interface(intf);
 		if (ret) {
-			dev_dbg(hub_dev, "error resetting hub: %d\n", ret);
-			goto out_autopm;
+			dev_dbg(hub_dev, "Can't autoresume: %d\n", ret);
+			goto out_hdev_lock;
 		}
 
-		hub->nerrors = 0;
-		hub->error = 0;
-	}
+		/* If this is an inactive hub, do nothing */
+		if (hub->quiescing)
+			goto out_autopm;
 
-	/* deal with port status changes */
-	for (i = 1; i <= hdev->maxchild; i++) {
-		struct usb_port *port_dev = hub->ports[i - 1];
+		if (hub->error) {
+			dev_dbg(hub_dev, "resetting for error %d\n", hub->error);
 
-		if (test_bit(i, hub->event_bits)
-				|| test_bit(i, hub->change_bits)
-				|| test_bit(i, hub->wakeup_bits)) {
-			/*
-			 * The get_noresume and barrier ensure that if
-			 * the port was in the process of resuming, we
-			 * flush that work and keep the port active for
-			 * the duration of the port_event().  However,
-			 * if the port is runtime pm suspended
-			 * (powered-off), we leave it in that state, run
-			 * an abbreviated port_event(), and move on.
-			 */
-			pm_runtime_get_noresume(&port_dev->dev);
-			pm_runtime_barrier(&port_dev->dev);
-			usb_lock_port(port_dev);
-			port_event(hub, i);
-			usb_unlock_port(port_dev);
-			pm_runtime_put_sync(&port_dev->dev);
-		}
-	}
+			ret = usb_reset_device(hdev);
+			if (ret) {
+				dev_dbg(hub_dev, "error resetting hub: %d\n", ret);
+				goto out_autopm;
+			}
 
-	/* deal with hub status changes */
-	if (test_and_clear_bit(0, hub->event_bits) == 0)
-		;	/* do nothing */
-	else if (hub_hub_status(hub, &hubstatus, &hubchange) < 0)
-		dev_err(hub_dev, "get_hub_status failed\n");
-	else {
-		if (hubchange & HUB_CHANGE_LOCAL_POWER) {
-			dev_dbg(hub_dev, "power change\n");
-			clear_hub_feature(hdev, C_HUB_LOCAL_POWER);
-			if (hubstatus & HUB_STATUS_LOCAL_POWER)
-				/* FIXME: Is this always true? */
-				hub->limited_power = 1;
-			else
-				hub->limited_power = 0;
+			hub->nerrors = 0;
+			hub->error = 0;
 		}
-		if (hubchange & HUB_CHANGE_OVERCURRENT) {
-			u16 status = 0;
-			u16 unused;
-
-			dev_dbg(hub_dev, "over-current change\n");
-			clear_hub_feature(hdev, C_HUB_OVER_CURRENT);
-			msleep(500);	/* Cool down */
-			hub_power_on(hub, true);
-			hub_hub_status(hub, &status, &unused);
-			if (status & HUB_STATUS_OVERCURRENT)
-				dev_err(hub_dev, "over-current condition\n");
+
+		/* deal with port status changes */
+		printk(KERN_NOTICE "%s,hub:%p\n",__FUNCTION__,hub);
+		for (i = 1; i <= hdev->maxchild; i++) {
+			struct usb_port *port_dev = hub->ports[i - 1];
+
+			if (test_bit(i, hub->event_bits)
+					|| test_bit(i, hub->change_bits)
+					|| test_bit(i, hub->wakeup_bits)) {
+				/*
+				 * The get_noresume and barrier ensure that if
+				 * the port was in the process of resuming, we
+				 * flush that work and keep the port active for
+				 * the duration of the port_event().  However,
+				 * if the port is runtime pm suspended
+				 * (powered-off), we leave it in that state, run
+				 * an abbreviated port_event(), and move on.
+				 */
+				pm_runtime_get_noresume(&port_dev->dev);
+				pm_runtime_barrier(&port_dev->dev);
+				usb_lock_port(port_dev);
+				port_event(hub, i);
+				usb_unlock_port(port_dev);
+				pm_runtime_put_sync(&port_dev->dev);
+			}
 		}
-	}
 
-out_autopm:
-	/* Balance the usb_autopm_get_interface() above */
-	usb_autopm_put_interface_no_suspend(intf);
-out_hdev_lock:
-	usb_unlock_device(hdev);
+		/* deal with hub status changes */
+		if (test_and_clear_bit(0, hub->event_bits) == 0)
+			;	/* do nothing */
+		else if (hub_hub_status(hub, &hubstatus, &hubchange) < 0)
+			dev_err(hub_dev, "get_hub_status failed\n");
+		else {
+			if (hubchange & HUB_CHANGE_LOCAL_POWER) {
+				dev_dbg(hub_dev, "power change\n");
+				clear_hub_feature(hdev, C_HUB_LOCAL_POWER);
+				if (hubstatus & HUB_STATUS_LOCAL_POWER)
+					/* FIXME: Is this always true? */
+					hub->limited_power = 1;
+				else
+					hub->limited_power = 0;
+			}
+			if (hubchange & HUB_CHANGE_OVERCURRENT) {
+				u16 status = 0;
+				u16 unused;
+
+				dev_dbg(hub_dev, "over-current change\n");
+				clear_hub_feature(hdev, C_HUB_OVER_CURRENT);
+				msleep(500);	/* Cool down */
+				hub_power_on(hub, true);
+				hub_hub_status(hub, &status, &unused);
+				if (status & HUB_STATUS_OVERCURRENT)
+					dev_err(hub_dev, "over-current condition\n");
+			}
+		}
 
-	/* Balance the stuff in kick_hub_wq() and allow autosuspend */
-	usb_autopm_put_interface(intf);
-	kref_put(&hub->kref, hub_release);
+	out_autopm:
+		/* Balance the usb_autopm_get_interface() above */
+		usb_autopm_put_interface_no_suspend(intf);
+	loop:
+		/* Balance the usb_autopm_get_interface_no_resume() in
+		 * kick_khubd() and allow autosuspend.
+		 */
+		usb_autopm_put_interface(intf);
+	out_hdev_lock:
+		usb_unlock_device(hdev);
+
+		/* Balance the stuff in kick_hub_wq() and allow autosuspend */
+		usb_autopm_put_interface(intf);
+		kref_put(&hub->kref, hub_release);
+#ifdef CONFIG_USB_HOST_ENUM_RETRY
+			if (!hub->hdev->parent) {
+				enum_event_handle(hub, ENUM_FAIL_RX_ACTIVE);
+			}
+#endif
+	}
 }
 
 static const struct usb_device_id hub_id_table[] = {
@@ -5271,6 +6198,26 @@
 	.supports_autosuspend =	1,
 };
 
+static int hub_thread(void *__unused)
+{
+	/* khubd needs to be freezable to avoid interfering with USB-PERSIST
+	 * port handover.  Otherwise it might see that a full-speed device
+	 * was gone before the EHCI controller had handed its port over to
+	 * the companion full-speed controller.
+	 */
+	set_freezable();
+
+	do {
+		hub_events();
+		wait_event_freezable(khubd_wait,
+				!list_empty(&hub_event_list) ||
+				kthread_should_stop());
+	} while (!kthread_should_stop() || !list_empty(&hub_event_list));
+
+	pr_debug("%s: khubd exiting\n", usbcore_name);
+	return 0;
+}
+
 int usb_hub_init(void)
 {
 	if (usb_register(&hub_driver) < 0) {
@@ -5279,26 +6226,20 @@
 		return -1;
 	}
 
-	/*
-	 * The workqueue needs to be freezable to avoid interfering with
-	 * USB-PERSIST port handover. Otherwise it might see that a full-speed
-	 * device was gone before the EHCI controller had handed its port
-	 * over to the companion full-speed controller.
-	 */
-	hub_wq = alloc_workqueue("usb_hub_wq", WQ_FREEZABLE, 0);
-	if (hub_wq)
+	khubd_task = kthread_run(hub_thread, NULL, "khubd");
+	if (!IS_ERR(khubd_task))
 		return 0;
 
 	/* Fall through if kernel_thread failed */
 	usb_deregister(&hub_driver);
-	pr_err("%s: can't allocate workqueue for usb hub\n", usbcore_name);
+	printk(KERN_ERR "%s: can't start khubd\n", usbcore_name);
 
 	return -1;
 }
 
 void usb_hub_cleanup(void)
 {
-	destroy_workqueue(hub_wq);
+	kthread_stop(khubd_task);
 
 	/*
 	 * Hub resources are freed for us by usb_deregister. It calls
@@ -5449,6 +6390,11 @@
 		return -EISDIR;
 
 	parent_hub = usb_hub_to_struct_hub(parent_hdev);
+#ifdef	CONFIG_RETRY_TIMES
+	if (udev->reset_count == 0) {
+		goto re_enumerate;
+	}
+#endif
 
 	/* Disable USB2 hardware LPM.
 	 * It will be re-enabled by the enumeration process.
@@ -5572,6 +6518,9 @@
 	return 0;
 
 re_enumerate:
+#ifdef CONFIG_RETRY_TIMES
+	udev->reset_count = 0;
+#endif
 	usb_release_bos_descriptor(udev);
 	udev->bos = bos;
 re_enumerate_no_bos:
@@ -5580,6 +6529,14 @@
 	return -ENODEV;
 }
 
+#ifdef CONFIG_RETRY_TIMES
+static long usb_time_delay = 0;
+module_param(usb_time_delay, long, 0644);
+
+static u32 usb_retry_times = 5;
+module_param(usb_retry_times, uint, 0644);
+#endif
+
 /**
  * usb_reset_device - warn interface drivers and perform a USB port reset
  * @udev: device to reset (not in SUSPENDED or NOTATTACHED state)
@@ -5609,6 +6566,9 @@
 	struct usb_port *port_dev;
 	struct usb_host_config *config = udev->actconfig;
 	struct usb_hub *hub = usb_hub_to_struct_hub(udev->parent);
+#ifdef CONFIG_RETRY_TIMES
+	struct timespec now, d;
+#endif
 
 	if (udev->state == USB_STATE_NOTATTACHED ||
 			udev->state == USB_STATE_SUSPENDED) {
@@ -5658,9 +6618,26 @@
 		}
 	}
 
+#ifdef	CONFIG_RETRY_TIMES
+	getnstimeofday(&now);
+
+	if (is_usb_high_bus(udev->bus)) {
+		d = timespec_sub(now, udev->t_prev);
+		if (d.tv_sec <= usb_time_delay) {
+			if (udev->reset_count > 0) {
+				udev->reset_count--;
+			}
+		} else {
+			udev->reset_count = usb_retry_times;
+		}
+	}
+#endif
 	usb_lock_port(port_dev);
 	ret = usb_reset_and_verify_device(udev);
 	usb_unlock_port(port_dev);
+#ifdef	CONFIG_RETRY_TIMES
+	getnstimeofday(&udev->t_prev);
+#endif
 
 	if (config) {
 		for (i = config->desc.bNumInterfaces - 1; i >= 0; --i) {
--- a/drivers/usb/core/hub.h	2018-11-23 10:16:15.956819221 +0300
+++ a/drivers/usb/core/hub.h	2018-11-23 10:31:03.783051883 +0300
@@ -41,6 +41,7 @@
 	int			error;		/* last reported error */
 	int			nerrors;	/* track consecutive errors */
 
+	struct list_head	event_list;	/* hubs w/data or errs ready */
 	unsigned long		event_bits[1];	/* status change bitmask */
 	unsigned long		change_bits[1];	/* ports with logical connect
 							status change */
@@ -78,6 +79,9 @@
 	struct delayed_work	init_work;
 	struct work_struct      events;
 	struct usb_port		**ports;
+#ifdef	CONFIG_USB_LOGO_TEST
+	struct task_struct	*usb_logo_thread;
+#endif
 };
 
 /**
--- a/drivers/usb/core/Kconfig	2018-11-23 10:16:15.954819340 +0300
+++ a/drivers/usb/core/Kconfig	2018-11-23 10:31:03.781052002 +0300
@@ -1,6 +1,23 @@
 #
 # USB Core configuration
 #
+config USB_DEBUG
+	bool "USB verbose debug messages"
+	depends on USB
+	help
+	  Say Y here if you want the USB core & hub drivers to produce a bunch
+	  of debug messages to the system log. Select this if you are having a
+	  problem with USB support and want to see more of what is going on.
+
+config USB_PHY_RX_ACTIVE_QUESTION_WORKAROUND
+	bool "Enable USB PHY RX Active Question Workaround"
+	depends on USB
+
+config USB_BAD_DEVICE_INFO
+	bool "support bad usb device info"
+	depends on USB
+	default n
+
 config USB_ANNOUNCE_NEW_DEVICES
 	bool "USB announce new devices"
 	help
@@ -43,7 +60,6 @@
 
 config USB_OTG
 	bool "OTG support"
-	depends on PM
 	default n
 	help
 	  The most notable feature of USB OTG is support for a
--- a/drivers/usb/core/Makefile	2018-11-23 10:16:15.954819340 +0300
+++ a/drivers/usb/core/Makefile	2018-11-23 10:31:03.779052121 +0300
@@ -1,6 +1,7 @@
 #
 # Makefile for USB Core files and filesystem
 #
+ccflags-$(CONFIG_USB_DEBUG) := -DDEBUG
 
 usbcore-y := usb.o hub.o hcd.o urb.o message.o driver.o
 usbcore-y += config.o file.o buffer.o sysfs.o endpoint.o
--- a/drivers/usb/core/message.c	2018-11-23 10:16:15.956819221 +0300
+++ a/drivers/usb/core/message.c	2018-11-23 10:31:03.780052061 +0300
@@ -19,9 +19,11 @@
 #include <linux/usb/quirks.h>
 #include <linux/usb/hcd.h>	/* for usbcore internals */
 #include <asm/byteorder.h>
+#include <linux/usb/sp_usb.h>
 
 #include "usb.h"
 
+
 static void cancel_async_set_config(struct usb_device *udev);
 
 struct api_context {
@@ -49,6 +51,13 @@
 	struct api_context ctx;
 	unsigned long expire;
 	int retval;
+	struct usb_device *dev;
+#ifdef CONFIG_USB_HOST_NOT_FINISH_QTD_WHEN_DISC_WORKAROUND
+	struct usb_hcd *hcd = bus_to_hcd(urb->dev->bus);
+#endif
+
+	dev = urb->dev;
+	dev->current_urb = urb;
 
 	init_completion(&ctx.done);
 	urb->context = &ctx;
@@ -56,6 +65,41 @@
 	retval = usb_submit_urb(urb, GFP_NOIO);
 	if (unlikely(retval))
 		goto out;
+#ifdef CONFIG_USB_HOST_NOT_FINISH_QTD_WHEN_DISC_WORKAROUND
+	do {
+		if (hcd->enum_msg_flag && hcd->hub_thread == current) {
+			int port_status;
+
+			hcd->current_active_urb = urb;
+			if (hcd->driver->get_port_status_from_register) {
+				port_status = hcd->driver->get_port_status_from_register(hcd);
+				if (hcd->driver->relinquish_port) {
+					if ((!(port_status & CURRENT_CONNECT_STATUS))
+					    || (port_status & EHCI_CONNECT_STATUS_CHANGE)) {
+						printk(KERN_NOTICE
+						       "\ndev disc after submit urb, ps:%x\n",
+						       port_status);
+						hcd->current_active_urb = NULL;
+						retval = -ENOTCONN;
+						usb_kill_urb(urb);
+						goto out;
+					}
+				} else {
+					if ((!(port_status & CURRENT_CONNECT_STATUS))
+					    || (port_status & OHCI_CONNECT_STATUS_CHANGE)) {
+						printk(KERN_NOTICE
+						       "\ndev disc after submit urb,ps:%x\n",
+						       port_status);
+						hcd->current_active_urb = NULL;
+						retval = -ENOTCONN;
+						usb_kill_urb(urb);
+						goto out;
+					}
+				}
+			}
+		}
+	} while (0);
+#endif
 
 	expire = timeout ? msecs_to_jiffies(timeout) : MAX_SCHEDULE_TIMEOUT;
 	if (!wait_for_completion_timeout(&ctx.done, expire)) {
@@ -69,9 +113,24 @@
 			usb_urb_dir_in(urb) ? "in" : "out",
 			urb->actual_length,
 			urb->transfer_buffer_length);
-	} else
+	} else {
 		retval = ctx.status;
+#ifdef CONFIG_USB_HOST_NOT_FINISH_QTD_WHEN_DISC_WORKAROUND
+		if (-ENOTCONN_IRQ == retval) {
+			printk(KERN_NOTICE "\n***Warn, stop urb wait***\n");
+			retval = -ENOTCONN;
+			usb_kill_urb(urb);
+		}
+#endif
+	}
+
+#ifdef CONFIG_USB_HOST_NOT_FINISH_QTD_WHEN_DISC_WORKAROUND
+	if (hcd->enum_msg_flag && hcd->hub_thread == current)
+		hcd->current_active_urb = NULL;
+#endif
+
 out:
+	dev->current_urb = NULL;
 	if (actual_length)
 		*actual_length = urb->actual_length;
 
--- a/drivers/usb/core/sysfs.c	2018-11-23 10:16:15.957819161 +0300
+++ a/drivers/usb/core/sysfs.c	2018-11-23 10:31:03.782051942 +0300
@@ -44,9 +44,15 @@
 	usb_actconfig_show(field, format_string)		\
 	static DEVICE_ATTR_RO(field)
 
+#ifndef CONFIG_USB_LOGO_TEST
 usb_actconfig_attr(bNumInterfaces, "%2d\n");
+#else
+usb_actconfig_attr(bNumInterfaces, "%d\n");
+#endif
+
 usb_actconfig_attr(bmAttributes, "%2x\n");
 
+#ifndef CONFIG_USB_LOGO_TEST
 static ssize_t bMaxPower_show(struct device *dev,
 		struct device_attribute *attr, char *buf)
 {
@@ -65,6 +71,31 @@
 	return rc;
 }
 static DEVICE_ATTR_RO(bMaxPower);
+#else
+static ssize_t show_bMaxPower(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	struct usb_device *udev;
+	struct usb_host_config *actconfig;
+
+	udev = to_usb_device(dev);
+	actconfig = udev->actconfig;
+	if (actconfig)
+		return sprintf(buf, "%3dmA\n", actconfig->desc.bMaxPower * 2);
+	else {
+		__u8 maxp = 0;
+		int i;
+
+		for (i = 0; i < udev->descriptor.bNumConfigurations; i++)
+			maxp = maxp > udev->config[i].desc.bMaxPower
+			       ? maxp
+			       : udev->config[i].desc.bMaxPower;
+
+		return sprintf(buf, "%3dmA\n", maxp * 2);
+	}
+}
+
+static DEVICE_ATTR(bMaxPower, S_IRUGO, show_bMaxPower, NULL);
+#endif
 
 static ssize_t configuration_show(struct device *dev,
 		struct device_attribute *attr, char *buf)
@@ -770,6 +801,25 @@
 }
 static DEVICE_ATTR_IGNORE_LOCKDEP(remove, S_IWUSR, NULL, remove_store);
 
+#ifdef CONFIG_USB_BAD_DEVICE_INFO
+/* Get a device status */
+static ssize_t show_usb_device_status(struct device *dev,
+				      struct device_attribute *attr, char *buf)
+{
+	struct usb_device *udev;
+	u16 devstat;
+	int status;
+
+	udev = to_usb_device(dev);
+
+	status = usb_get_status(udev, USB_RECIP_DEVICE, 0, &devstat);
+	if (status < 0)
+		return 0;
+
+	return sprintf(buf, "%d\n", devstat);
+}
+static DEVICE_ATTR(device_status, S_IRUGO, show_usb_device_status, NULL);
+#endif
 
 static struct attribute *dev_attrs[] = {
 	/* current configuration's attributes */
@@ -803,6 +853,9 @@
 #ifdef CONFIG_OF
 	&dev_attr_devspec.attr,
 #endif
+#ifdef CONFIG_USB_BAD_DEVICE_INFO
+	&dev_attr_device_status.attr,
+#endif
 	NULL,
 };
 static struct attribute_group dev_attr_grp = {
--- a/drivers/usb/core/urb.c	2018-11-23 10:16:15.957819161 +0300
+++ a/drivers/usb/core/urb.c	2018-11-23 10:31:03.780052061 +0300
@@ -659,13 +659,35 @@
  */
 void usb_kill_urb(struct urb *urb)
 {
+	int t;
+	struct usb_device *dev;
+#ifdef CONFIG_USB_HOST_RESET_SP
+	extern void Reset_usb_host_ctrler(struct usb_device *udev);
+#endif
 	might_sleep();
 	if (!(urb && urb->dev && urb->ep))
 		return;
+
+	dev = urb->dev;
 	atomic_inc(&urb->reject);
 
 	usb_hcd_unlink_urb(urb, -ENOENT);
-	wait_event(usb_kill_urb_queue, atomic_read(&urb->use_count) == 0);
+	t = wait_event_timeout(usb_kill_urb_queue, atomic_read(&urb->use_count) == 0, 1 * HZ);
+	if (!t) {
+		printk(KERN_NOTICE "### Wait urb kill timeout: %p\n",urb);
+#ifdef CONFIG_USB_HOST_RESET_SP
+		if (urb->uphy_stuck_flag) {
+			urb->uphy_stuck_flag = 0;
+			printk(KERN_NOTICE "### Uphy stuck,USB need finish urb..\n");
+		} else {
+			printk(KERN_NOTICE "\n##@@ ==========\n");
+			Reset_usb_host_ctrler(dev);
+		}
+#else
+		printk(KERN_NOTICE "### USB need finish urb..\n");
+#endif
+		dump_stack();
+	}
 
 	atomic_dec(&urb->reject);
 }
--- a/drivers/usb/core/usb.c	2018-11-23 10:16:15.957819161 +0300
+++ a/drivers/usb/core/usb.c	2018-11-23 10:31:03.787051645 +0300
@@ -45,9 +45,34 @@
 #include <linux/scatterlist.h>
 #include <linux/mm.h>
 #include <linux/dma-mapping.h>
+#include <asm/uaccess.h>
+#include <linux/proc_fs.h>
+
 
 #include "usb.h"
 
+#ifdef CONFIG_USB_LOGO_TEST
+#include <linux/uaccess.h>
+#include <linux/proc_fs.h>
+#include <linux/usb/sp_usb.h>
+
+#define COMPARE_CHAR_NUMBER		3
+#define BASIC_VALUE			10
+#define LIMITS_OF_AUTHORITY		0666
+#define MAX_LENGTH			64
+#define DIRECTIORY_NAME			"usb_verify_test"
+#define TESET_FLAG_FILE_NAME		"specific_test_set"
+#define HUB_LEVLE_FILE_NAME		"hub_level_set"
+
+bool tid_test_flag = false;
+u8 max_topo_level = 6;
+static struct proc_dir_entry *dir_entry;
+static struct proc_dir_entry *test_flag_entry;
+static struct proc_dir_entry *hub_level_entry;
+EXPORT_SYMBOL_GPL(tid_test_flag);
+EXPORT_SYMBOL_GPL(max_topo_level);
+#endif
+
 
 const char *usbcore_name = "usbcore";
 
@@ -595,7 +620,9 @@
 	dev->state = USB_STATE_ATTACHED;
 	dev->lpm_disable_count = 1;
 	atomic_set(&dev->urbnum, 0);
-
+#ifdef CONFIG_RETRY_TIMES
+	dev->reset_count = 5;
+#endif
 	INIT_LIST_HEAD(&dev->ep0.urb_list);
 	dev->ep0.desc.bLength = USB_DT_ENDPOINT_SIZE;
 	dev->ep0.desc.bDescriptorType = USB_DT_ENDPOINT;
@@ -1197,8 +1224,157 @@
 /*
  * Init
  */
+
+
+#ifdef CONFIG_USB_LOGO_TEST
+static int usb_specific_test_set_show(struct seq_file *m, void *v)
+{
+	return 0;
+}
+
+static int usb_specific_test_set_write(struct file *file,
+				const char __user *buf, size_t count, loff_t *data)
+{
+	char verify_parameter[MAX_LENGTH];
+
+	if (count > MAX_LENGTH)
+		count = MAX_LENGTH;
+
+	printk(KERN_DEBUG "USB verify parameters set\n");
+	memset(verify_parameter, 0, MAX_LENGTH);
+	if (copy_from_user(verify_parameter, buf, count))
+		return -EFAULT;
+
+	if (strncmp(verify_parameter, "ORI", COMPARE_CHAR_NUMBER) == 0) {
+		printk(KERN_DEBUG "recover to origin set\n");
+		tid_test_flag = false;
+	} else if (strncmp(verify_parameter, "TID", COMPARE_CHAR_NUMBER) == 0) {
+		printk(KERN_DEBUG "comfs to comhs test set\n");
+		tid_test_flag = true;
+	} else if (strncmp(verify_parameter, "MFI", COMPARE_CHAR_NUMBER) == 0) {
+		printk(KERN_DEBUG "comfs to comhs test set\n");
+		tid_test_flag = true;
+	} else {
+		printk(KERN_DEBUG "now, not support value:%s\n",verify_parameter);
+	}
+
+	return count;
+}
+
+static int usb_specific_test_proc_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, usb_specific_test_set_show, NULL);
+}
+
+static const struct file_operations usb_specific_test_proc_fops = {
+	.owner		= THIS_MODULE,
+	.open		= usb_specific_test_proc_open,
+	.read		= seq_read,
+	.write		= usb_specific_test_set_write,
+	.release	= single_release,
+};
+
+static int usb_hub_level_set_show(struct seq_file *m, void *v)
+{
+	int len;
+	char verify_parameter[MAX_LENGTH];
+
+	printk(KERN_DEBUG "+%s\n", __FUNCTION__);
+	memset(verify_parameter, 0, sizeof(verify_parameter));
+	len = num_to_str(verify_parameter,MAX_LENGTH,max_topo_level);
+	if (!len)
+		printk(KERN_NOTICE "num_to_str error\n");
+	else
+		seq_printf(m, "%s\n", verify_parameter);
+
+	return 0;
+}
+
+static int usb_hub_level_set_write(struct file *file,
+				const char __user *buf, size_t count, loff_t *data)
+{
+	u64 value;
+	char verify_parameter[MAX_LENGTH];
+
+	if (count > MAX_LENGTH)
+		count = MAX_LENGTH;
+
+	printk(KERN_DEBUG "+%s\n", __FUNCTION__);
+	memset(verify_parameter, 0, MAX_LENGTH);
+	if (copy_from_user(verify_parameter, buf, count))
+		return -EFAULT;
+
+	value = simple_strtoull(verify_parameter, NULL, BASIC_VALUE);
+	max_topo_level = value;
+	printk(KERN_DEBUG "USB verify max hub level value:%d\n", max_topo_level);
+
+	return count;
+}
+
+static int usb_hub_level_proc_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, usb_hub_level_set_show, NULL);
+}
+
+static const struct file_operations hub_level_proc_fops = {
+	.owner		= THIS_MODULE,
+	.open		= usb_hub_level_proc_open,
+	.read		= seq_read,
+	.write		= usb_hub_level_set_write,
+	.release	= single_release,
+};
+
+static int proc_entry_add(void)
+{
+	dir_entry = proc_mkdir(DIRECTIORY_NAME, NULL);
+	if (!dir_entry) {
+		printk(KERN_NOTICE "can't create /proc/usb_verify_test\n");
+		return -ENOMEM;
+	}
+
+	test_flag_entry = proc_create(TESET_FLAG_FILE_NAME, LIMITS_OF_AUTHORITY,
+				      dir_entry, &usb_specific_test_proc_fops);
+	if (!test_flag_entry) {
+		printk(KERN_NOTICE
+		       "can't create /proc/usb_verify_test/specific_test_set\n");
+		remove_proc_entry(TESET_FLAG_FILE_NAME, dir_entry);
+		return -ENOMEM;
+	}
+
+	hub_level_entry = proc_create(HUB_LEVLE_FILE_NAME, LIMITS_OF_AUTHORITY,
+				      dir_entry, &hub_level_proc_fops);
+	if (!hub_level_entry) {
+		printk(KERN_NOTICE
+		       "can't create /proc/usb_verify_test/hub_level_set\n");
+		remove_proc_entry(HUB_LEVLE_FILE_NAME, dir_entry);
+		return -ENOMEM;
+	}
+
+	return 0;
+}
+
+static void proc_entry_remove(void)
+{
+	remove_proc_entry(TESET_FLAG_FILE_NAME, dir_entry);
+	remove_proc_entry(HUB_LEVLE_FILE_NAME, dir_entry);
+	remove_proc_entry(DIRECTIORY_NAME, NULL);
+}
+#endif
+
+static void sp_get_port_state(void)
+{
+#ifdef CONFIG_USB_PORT0
+	sp_port_enabled |= 0x01;
+#endif
+
+#ifdef CONFIG_USB_PORT1
+	sp_port_enabled |= 0x02;
+#endif
+}
+
 static int __init usb_init(void)
 {
+	int i;
 	int retval;
 	if (usb_disabled()) {
 		pr_info("%s: USB support disabled\n", usbcore_name);
@@ -1206,6 +1382,12 @@
 	}
 	usb_init_pool_max();
 
+#ifdef CONFIG_USB_LOGO_TEST
+	retval = proc_entry_add();
+	if (retval)
+		goto out;
+#endif
+
 	retval = usb_debugfs_init();
 	if (retval)
 		goto out;
@@ -1230,8 +1412,20 @@
 	if (retval)
 		goto hub_init_failed;
 	retval = usb_register_device_driver(&usb_generic_driver, THIS_MODULE);
-	if (!retval)
+	if (!retval){
+		for (i = 0; i < USB_PORT_NUM; i++) {
+			sema_init(&enum_rx_active_reset_sem[i], 0);
+		}
+#ifdef CONFIG_GADGET_USB0
+		accessory_port_id = USB_PORT0_ID;
+#else
+		accessory_port_id = USB_PORT1_ID;
+#endif
+		printk(KERN_NOTICE "usb acc config port= %d\n",accessory_port_id);
+		sp_get_port_state();
+
 		goto out;
+	}
 
 	usb_hub_cleanup();
 hub_init_failed:
@@ -1260,6 +1454,9 @@
 	if (usb_disabled())
 		return;
 
+#ifdef CONFIG_USB_LOGO_TEST
+	proc_entry_remove();
+#endif
 	usb_deregister_device_driver(&usb_generic_driver);
 	usb_major_cleanup();
 	usb_deregister(&usbfs_driver);
--- a/drivers/usb/gadget/composite.c	2018-11-23 10:16:15.962818864 +0300
+++ a/drivers/usb/gadget/composite.c	2018-11-23 10:31:03.795051170 +0300
@@ -2003,7 +2003,7 @@
 }
 
 /*-------------------------------------------------------------------------*/
-
+#if 0
 static ssize_t suspended_show(struct device *dev, struct device_attribute *attr,
 			      char *buf)
 {
@@ -2013,7 +2013,7 @@
 	return sprintf(buf, "%d\n", cdev->suspended);
 }
 static DEVICE_ATTR_RO(suspended);
-
+#endif
 static void __composite_unbind(struct usb_gadget *gadget, bool unbind_driver)
 {
 	struct usb_composite_dev	*cdev = get_gadget_data(gadget);
@@ -2103,11 +2103,11 @@
 	cdev->req->buf = kmalloc(USB_COMP_EP0_BUFSIZ, GFP_KERNEL);
 	if (!cdev->req->buf)
 		goto fail;
-
+#if 0
 	ret = device_create_file(&gadget->dev, &dev_attr_suspended);
 	if (ret)
 		goto fail_dev;
-
+#endif
 	cdev->req->complete = composite_setup_complete;
 	cdev->req->context = cdev;
 	gadget->ep0->driver_data = cdev;
@@ -2128,7 +2128,7 @@
 	 */
 	usb_ep_autoconfig_reset(gadget);
 	return 0;
-fail_dev:
+
 	kfree(cdev->req->buf);
 fail:
 	usb_ep_free_request(gadget->ep0, cdev->req);
@@ -2183,7 +2183,7 @@
 		usb_ep_free_request(cdev->gadget->ep0, cdev->req);
 	}
 	cdev->next_string_id = 0;
-	device_remove_file(&cdev->gadget->dev, &dev_attr_suspended);
+	//device_remove_file(&cdev->gadget->dev, &dev_attr_suspended);
 }
 
 static int composite_bind(struct usb_gadget *gadget,
--- a/drivers/usb/gadget/epautoconf.c	2018-11-23 10:16:15.962818864 +0300
+++ a/drivers/usb/gadget/epautoconf.c	2018-11-23 10:31:03.794051229 +0300
@@ -20,6 +20,173 @@
 #include <linux/usb/ch9.h>
 #include <linux/usb/gadget.h>
 
+static unsigned epnum;
+
+static int
+ep_matches (
+	struct usb_gadget		*gadget,
+	struct usb_ep			*ep,
+	struct usb_endpoint_descriptor	*desc,
+	struct usb_ss_ep_comp_descriptor *ep_comp
+)
+{
+	u8		type;
+	const char	*tmp;
+	u16		max;
+
+	int		num_req_streams = 0;
+
+	/* endpoint already claimed? */
+	if (NULL != ep->driver_data)
+		return 0;
+
+	/* only support ep0 for portable CONTROL traffic */
+	type = desc->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK;
+	if (USB_ENDPOINT_XFER_CONTROL == type)
+		return 0;
+
+	/* some other naming convention */
+	if ('e' != ep->name[0])
+		return 0;
+
+	/* type-restriction:  "-iso", "-bulk", or "-int".
+	 * direction-restriction:  "in", "out".
+	 */
+	if ('-' != ep->name[2]) {
+		tmp = strrchr (ep->name, '-');
+		if (tmp) {
+			switch (type) {
+			case USB_ENDPOINT_XFER_INT:
+				/* bulk endpoints handle interrupt transfers,
+				 * except the toggle-quirky iso-synch kind
+				 */
+				if ('s' == tmp[2])	// == "-iso"
+					return 0;
+				/* for now, avoid PXA "interrupt-in";
+				 * it's documented as never using DATA1.
+				 */
+				if (gadget_is_pxa (gadget)
+						&& 'i' == tmp [1])
+					return 0;
+				break;
+			case USB_ENDPOINT_XFER_BULK:
+				if ('b' != tmp[1])	// != "-bulk"
+					return 0;
+				break;
+			case USB_ENDPOINT_XFER_ISOC:
+				if ('s' != tmp[2])	// != "-iso"
+					return 0;
+			}
+		} else {
+			tmp = ep->name + strlen (ep->name);
+		}
+
+		/* direction-restriction:  "..in-..", "out-.." */
+		tmp--;
+		if (!isdigit (*tmp)) {
+			if (desc->bEndpointAddress & USB_DIR_IN) {
+				if ('n' != *tmp)
+					return 0;
+			} else {
+				if ('t' != *tmp)
+					return 0;
+			}
+		}
+	}
+
+	/*
+	 * Get the number of required streams from the EP companion
+	 * descriptor and see if the EP matches it
+	 */
+	if (usb_endpoint_xfer_bulk(desc)) {
+		if (ep_comp && gadget->max_speed >= USB_SPEED_SUPER) {
+			num_req_streams = ep_comp->bmAttributes & 0x1f;
+			if (num_req_streams > ep->max_streams)
+				return 0;
+		}
+
+	}
+
+	/*
+	 * If the protocol driver hasn't yet decided on wMaxPacketSize
+	 * and wants to know the maximum possible, provide the info.
+	 */
+	if (desc->wMaxPacketSize == 0)
+		desc->wMaxPacketSize = cpu_to_le16(ep->maxpacket_limit);
+
+	/* endpoint maxpacket size is an input parameter, except for bulk
+	 * where it's an output parameter representing the full speed limit.
+	 * the usb spec fixes high speed bulk maxpacket at 512 bytes.
+	 */
+	max = 0x7ff & usb_endpoint_maxp(desc);
+	switch (type) {
+	case USB_ENDPOINT_XFER_INT:
+		/* INT:  limit 64 bytes full speed, 1024 high/super speed */
+		if (!gadget_is_dualspeed(gadget) && max > 64)
+			return 0;
+		/* FALLTHROUGH */
+
+	case USB_ENDPOINT_XFER_ISOC:
+		/* ISO:  limit 1023 bytes full speed, 1024 high/super speed */
+		if (ep->maxpacket < max)
+			return 0;
+		if (!gadget_is_dualspeed(gadget) && max > 1023)
+			return 0;
+
+		/* BOTH:  "high bandwidth" works only at high speed */
+		if ((desc->wMaxPacketSize & cpu_to_le16(3<<11))) {
+			if (!gadget_is_dualspeed(gadget))
+				return 0;
+			/* configure your hardware with enough buffering!! */
+		}
+		break;
+	}
+
+	/* MATCH!! */
+
+	/* report address */
+	desc->bEndpointAddress &= USB_DIR_IN;
+	if (isdigit (ep->name [2])) {
+		u8	num = simple_strtoul (&ep->name [2], NULL, 10);
+		desc->bEndpointAddress |= num;
+#ifdef	MANY_ENDPOINTS
+	} else if (desc->bEndpointAddress & USB_DIR_IN) {
+		if (++in_epnum > 15)
+			return 0;
+		desc->bEndpointAddress = USB_DIR_IN | in_epnum;
+#endif
+	} else {
+		if (++epnum > 15)
+			return 0;
+		desc->bEndpointAddress |= epnum;
+	}
+
+	/* report (variable) full speed bulk maxpacket */
+	if ((USB_ENDPOINT_XFER_BULK == type) && !ep_comp) {
+		int size = ep->maxpacket;
+
+		/* min() doesn't work on bitfields with gcc-3.5 */
+		if (size > 64)
+			size = 64;
+		desc->wMaxPacketSize = cpu_to_le16(size);
+	}
+	ep->address = desc->bEndpointAddress;
+	return 1;
+}
+
+
+static struct usb_ep *
+find_ep (struct usb_gadget *gadget, const char *name)
+{
+	struct usb_ep	*ep;
+
+	list_for_each_entry (ep, &gadget->ep_list, ep_list) {
+		if (0 == strcmp (ep->name, name))
+			return ep;
+	}
+	return NULL;
+}
+
 /**
  * usb_ep_autoconfig_ss() - choose an endpoint matching the ep
  * descriptor and ep companion descriptor
@@ -75,58 +242,93 @@
 
 	type = desc->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK;
 
-	if (gadget->ops->match_ep) {
-		ep = gadget->ops->match_ep(gadget, desc, ep_comp);
-		if (ep)
+	/* First, apply chip-specific "best usage" knowledge.
+	 * This might make a good usb_gadget_ops hook ...
+	 */
+	if (gadget_is_net2280 (gadget) && type == USB_ENDPOINT_XFER_INT) {
+		/* ep-e, ep-f are PIO with only 64 byte fifos */
+		ep = find_ep (gadget, "ep-e");
+		if (ep && ep_matches(gadget, ep, desc, ep_comp))
+			goto found_ep;
+		ep = find_ep (gadget, "ep-f");
+		if (ep && ep_matches(gadget, ep, desc, ep_comp))
 			goto found_ep;
+
+	} else if (gadget_is_goku (gadget)) {
+		if (USB_ENDPOINT_XFER_INT == type) {
+			/* single buffering is enough */
+			ep = find_ep(gadget, "ep3-bulk");
+			if (ep && ep_matches(gadget, ep, desc, ep_comp))
+				goto found_ep;
+		} else if (USB_ENDPOINT_XFER_BULK == type
+				&& (USB_DIR_IN & desc->bEndpointAddress)) {
+			/* DMA may be available */
+			ep = find_ep(gadget, "ep2-bulk");
+			if (ep && ep_matches(gadget, ep, desc,
+					      ep_comp))
+				goto found_ep;
+		}
+
+#ifdef CONFIG_BLACKFIN
+	} else if (gadget_is_musbhdrc(gadget)) {
+		if ((USB_ENDPOINT_XFER_BULK == type) ||
+		    (USB_ENDPOINT_XFER_ISOC == type)) {
+			if (USB_DIR_IN & desc->bEndpointAddress)
+				ep = find_ep (gadget, "ep5in");
+			else
+				ep = find_ep (gadget, "ep6out");
+		} else if (USB_ENDPOINT_XFER_INT == type) {
+			if (USB_DIR_IN & desc->bEndpointAddress)
+				ep = find_ep(gadget, "ep1in");
+			else
+				ep = find_ep(gadget, "ep2out");
+		} else
+			ep = NULL;
+		if (ep && ep_matches(gadget, ep, desc, ep_comp))
+			goto found_ep;
+#endif
+
+#ifdef CONFIG_USB_GADGET_SUNPLUS
+	} else if (gadget_is_sp628(gadget)) {
+		ep = NULL;printk("wei ep config\n");
+		if (USB_ENDPOINT_XFER_BULK == type) {
+			if (desc->bInterval == 0xDC) { // Function: MSDC
+				ep = find_ep(gadget,
+					(USB_DIR_IN & desc->bEndpointAddress) ? "ep8in-bulk" : "ep8in-bulk");
+			}
+			if (desc->bInterval == 0xDB) { // Function: ADB
+				ep = find_ep(gadget,
+					(USB_DIR_IN & desc->bEndpointAddress) ? "ep8in-bulk" : "ep9out-bulk");
+			}
+			else if(desc->bInterval == 0x1) { // Function: iap
+				ep = find_ep(gadget,
+					(USB_DIR_IN & desc->bEndpointAddress) ? "ep8in-bulk" : "ep9out-bulk");
+				desc->bInterval = 0;
+			}else{ // Function:
+				ep = find_ep(gadget,
+                                        (USB_DIR_IN & desc->bEndpointAddress) ? "ep1in-bulk" : "ep11out-bulk");
+			}
+		} else if (USB_ENDPOINT_XFER_INT == type) {
+			    ep = find_ep(gadget, "ep3in-int");
+		} else if (USB_ENDPOINT_XFER_ISOC == type){
+			ep = find_ep(gadget, (USB_DIR_IN & desc->bEndpointAddress) ? "ep5-iso" : "ep12-iso");
+		}
+		if (ep && ep_matches(gadget, ep, desc,ep_comp))
+			goto found_ep;
+#endif
 	}
 
 	/* Second, look at endpoints until an unclaimed one looks usable */
 	list_for_each_entry (ep, &gadget->ep_list, ep_list) {
-		if (usb_gadget_ep_match_desc(gadget, ep, desc, ep_comp))
+		if (ep_matches(gadget, ep, desc, ep_comp))
 			goto found_ep;
 	}
 
 	/* Fail */
 	return NULL;
 found_ep:
-
-	/*
-	 * If the protocol driver hasn't yet decided on wMaxPacketSize
-	 * and wants to know the maximum possible, provide the info.
-	 */
-	if (desc->wMaxPacketSize == 0)
-		desc->wMaxPacketSize = cpu_to_le16(ep->maxpacket_limit);
-
-	/* report address */
-	desc->bEndpointAddress &= USB_DIR_IN;
-	if (isdigit(ep->name[2])) {
-		u8 num = simple_strtoul(&ep->name[2], NULL, 10);
-		desc->bEndpointAddress |= num;
-	} else if (desc->bEndpointAddress & USB_DIR_IN) {
-		if (++gadget->in_epnum > 15)
-			return NULL;
-		desc->bEndpointAddress = USB_DIR_IN | gadget->in_epnum;
-	} else {
-		if (++gadget->out_epnum > 15)
-			return NULL;
-		desc->bEndpointAddress |= gadget->out_epnum;
-	}
-
-	/* report (variable) full speed bulk maxpacket */
-	if ((type == USB_ENDPOINT_XFER_BULK) && !ep_comp) {
-		int size = ep->maxpacket_limit;
-
-		/* min() doesn't work on bitfields with gcc-3.5 */
-		if (size > 64)
-			size = 64;
-		desc->wMaxPacketSize = cpu_to_le16(size);
-	}
-
-	ep->address = desc->bEndpointAddress;
 	ep->desc = NULL;
 	ep->comp_desc = NULL;
-	ep->claimed = true;
 	return ep;
 }
 EXPORT_SYMBOL_GPL(usb_ep_autoconfig_ss);
@@ -207,5 +409,9 @@
 	}
 	gadget->in_epnum = 0;
 	gadget->out_epnum = 0;
+#ifdef	MANY_ENDPOINTS
+	in_epnum = 0;
+#endif
+	epnum = 0;
 }
 EXPORT_SYMBOL_GPL(usb_ep_autoconfig_reset);
--- a/drivers/usb/gadget/function/f_loopback.c	2018-11-23 10:16:15.963818805 +0300
+++ a/drivers/usb/gadget/function/f_loopback.c	2018-11-23 10:31:03.792051348 +0300
@@ -15,12 +15,11 @@
 #include <linux/slab.h>
 #include <linux/kernel.h>
 #include <linux/device.h>
-#include <linux/module.h>
-#include <linux/err.h>
-#include <linux/usb/composite.h>
 
 #include "g_zero.h"
-#include "u_f.h"
+#include <linux/usb/gadget_chips.h>
+
+
 
 /*
  * LOOPBACK FUNCTION ... a testing vehicle for USB peripherals,
@@ -28,15 +27,17 @@
  * This takes messages of various sizes written OUT to a device, and loops
  * them back so they can be read IN from it.  It has been used by certain
  * test applications.  It supports limited testing of data queueing logic.
+ *
+ *
+ * This is currently packaged as a configuration driver, which can't be
+ * combined with other functions to make composite devices.  However, it
+ * can be combined with other independent configurations.
  */
 struct f_loopback {
 	struct usb_function	function;
 
 	struct usb_ep		*in_ep;
 	struct usb_ep		*out_ep;
-
-	unsigned                qlen;
-	unsigned                buflen;
 };
 
 static inline struct f_loopback *func_to_loop(struct usb_function *f)
@@ -44,10 +45,14 @@
 	return container_of(f, struct f_loopback, function);
 }
 
+static unsigned qlen = 32;
+module_param(qlen, uint, 0);
+MODULE_PARM_DESC(qlenn, "depth of loopback queue");
+
 /*-------------------------------------------------------------------------*/
 
 static struct usb_interface_descriptor loopback_intf = {
-	.bLength =		sizeof(loopback_intf),
+	.bLength =		sizeof loopback_intf,
 	.bDescriptorType =	USB_DT_INTERFACE,
 
 	.bNumEndpoints =	2,
@@ -115,7 +120,7 @@
 	.wMaxPacketSize =	cpu_to_le16(1024),
 };
 
-static struct usb_ss_ep_comp_descriptor ss_loop_source_comp_desc = {
+struct usb_ss_ep_comp_descriptor ss_loop_source_comp_desc = {
 	.bLength =		USB_DT_SS_EP_COMP_SIZE,
 	.bDescriptorType =	USB_DT_SS_ENDPOINT_COMP,
 	.bMaxBurst =		0,
@@ -131,7 +136,7 @@
 	.wMaxPacketSize =	cpu_to_le16(1024),
 };
 
-static struct usb_ss_ep_comp_descriptor ss_loop_sink_comp_desc = {
+struct usb_ss_ep_comp_descriptor ss_loop_sink_comp_desc = {
 	.bLength =		USB_DT_SS_EP_COMP_SIZE,
 	.bDescriptorType =	USB_DT_SS_ENDPOINT_COMP,
 	.bMaxBurst =		0,
@@ -167,12 +172,12 @@
 
 /*-------------------------------------------------------------------------*/
 
-static int loopback_bind(struct usb_configuration *c, struct usb_function *f)
+static int __init
+loopback_bind(struct usb_configuration *c, struct usb_function *f)
 {
 	struct usb_composite_dev *cdev = c->cdev;
 	struct f_loopback	*loop = func_to_loop(f);
 	int			id;
-	int ret;
 
 	/* allocate interface ID(s) */
 	id = usb_interface_id(c, f);
@@ -180,12 +185,6 @@
 		return id;
 	loopback_intf.bInterfaceNumber = id;
 
-	id = usb_string_id(cdev);
-	if (id < 0)
-		return id;
-	strings_loopback[0].id = id;
-	loopback_intf.iInterface = id;
-
 	/* allocate endpoints */
 
 	loop->in_ep = usb_ep_autoconfig(cdev->gadget, &fs_loop_source_desc);
@@ -195,25 +194,30 @@
 			f->name, cdev->gadget->name);
 		return -ENODEV;
 	}
+	loop->in_ep->driver_data = cdev;	/* claim */
 
 	loop->out_ep = usb_ep_autoconfig(cdev->gadget, &fs_loop_sink_desc);
 	if (!loop->out_ep)
 		goto autoconf_fail;
+	loop->out_ep->driver_data = cdev;	/* claim */
 
 	/* support high speed hardware */
-	hs_loop_source_desc.bEndpointAddress =
-		fs_loop_source_desc.bEndpointAddress;
-	hs_loop_sink_desc.bEndpointAddress = fs_loop_sink_desc.bEndpointAddress;
+	if (gadget_is_dualspeed(c->cdev->gadget)) {
+		hs_loop_source_desc.bEndpointAddress =
+				fs_loop_source_desc.bEndpointAddress;
+		hs_loop_sink_desc.bEndpointAddress =
+				fs_loop_sink_desc.bEndpointAddress;
+		f->hs_descriptors = hs_loopback_descs;
+	}
 
 	/* support super speed hardware */
-	ss_loop_source_desc.bEndpointAddress =
-		fs_loop_source_desc.bEndpointAddress;
-	ss_loop_sink_desc.bEndpointAddress = fs_loop_sink_desc.bEndpointAddress;
-
-	ret = usb_assign_descriptors(f, fs_loopback_descs, hs_loopback_descs,
-			ss_loopback_descs, NULL);
-	if (ret)
-		return ret;
+	if (gadget_is_superspeed(c->cdev->gadget)) {
+		ss_loop_source_desc.bEndpointAddress =
+				fs_loop_source_desc.bEndpointAddress;
+		ss_loop_sink_desc.bEndpointAddress =
+				fs_loop_sink_desc.bEndpointAddress;
+		f->ss_descriptors = ss_loopback_descs;
+	}
 
 	DBG(cdev, "%s speed %s: IN/%s, OUT/%s\n",
 	    (gadget_is_superspeed(c->cdev->gadget) ? "super" :
@@ -222,17 +226,9 @@
 	return 0;
 }
 
-static void lb_free_func(struct usb_function *f)
+static void
+loopback_unbind(struct usb_configuration *c, struct usb_function *f)
 {
-	struct f_lb_opts *opts;
-
-	opts = container_of(f->fi, struct f_lb_opts, func_inst);
-
-	mutex_lock(&opts->lock);
-	opts->refcnt--;
-	mutex_unlock(&opts->lock);
-
-	usb_free_all_descriptors(f);
 	kfree(func_to_loop(f));
 }
 
@@ -243,38 +239,31 @@
 	int			status = req->status;
 
 	switch (status) {
+
 	case 0:				/* normal completion? */
 		if (ep == loop->out_ep) {
-			/*
-			 * We received some data from the host so let's
-			 * queue it so host can read the from our in ep
-			 */
-			struct usb_request *in_req = req->context;
-
-			in_req->zero = (req->actual < req->length);
-			in_req->length = req->actual;
-			ep = loop->in_ep;
-			req = in_req;
-		} else {
-			/*
-			 * We have just looped back a bunch of data
-			 * to host. Now let's wait for some more data.
-			 */
-			req = req->context;
-			ep = loop->out_ep;
+			/* loop this OUT packet back IN to the host */
+			req->zero = (req->actual < req->length);
+			req->length = req->actual;
+			status = usb_ep_queue(loop->in_ep, req, GFP_ATOMIC);
+			if (status == 0)
+				return;
+
+			/* "should never get here" */
+			ERROR(cdev, "can't loop %s to %s: %d\n",
+				ep->name, loop->in_ep->name,
+				status);
 		}
 
-		/* queue the buffer back to host or for next bunch of data */
-		status = usb_ep_queue(ep, req, GFP_ATOMIC);
-		if (status == 0) {
+		/* queue the buffer for some later OUT packet */
+		req->length = buflen;
+		status = usb_ep_queue(loop->out_ep, req, GFP_ATOMIC);
+		if (status == 0)
 			return;
-		} else {
-			ERROR(cdev, "Unable to loop back buffer to %s: %d\n",
-			      ep->name, status);
-			goto free_req;
-		}
 
 		/* "should never get here" */
+		/* FALLTHROUGH */
+
 	default:
 		ERROR(cdev, "%s loop complete --> %d, %d/%d\n", ep->name,
 				status, req->actual, req->length);
@@ -288,10 +277,6 @@
 	case -ECONNABORTED:		/* hardware forced ep reset */
 	case -ECONNRESET:		/* request dequeued */
 	case -ESHUTDOWN:		/* disconnect from host */
-free_req:
-		usb_ep_free_request(ep == loop->in_ep ?
-				    loop->out_ep : loop->in_ep,
-				    req->context);
 		free_ep_req(ep, req);
 		return;
 	}
@@ -302,109 +287,65 @@
 	struct usb_composite_dev	*cdev;
 
 	cdev = loop->function.config->cdev;
-	disable_endpoints(cdev, loop->in_ep, loop->out_ep, NULL, NULL);
+	disable_endpoints(cdev, loop->in_ep, loop->out_ep);
 	VDBG(cdev, "%s disabled\n", loop->function.name);
 }
 
-static inline struct usb_request *lb_alloc_ep_req(struct usb_ep *ep, int len)
-{
-	return alloc_ep_req(ep, len);
-}
-
-static int alloc_requests(struct usb_composite_dev *cdev,
-			  struct f_loopback *loop)
-{
-	struct usb_request *in_req, *out_req;
-	int i;
-	int result = 0;
-
-	/*
-	 * allocate a bunch of read buffers and queue them all at once.
-	 * we buffer at most 'qlen' transfers; We allocate buffers only
-	 * for out transfer and reuse them in IN transfers to implement
-	 * our loopback functionality
-	 */
-	for (i = 0; i < loop->qlen && result == 0; i++) {
-		result = -ENOMEM;
-
-		in_req = usb_ep_alloc_request(loop->in_ep, GFP_ATOMIC);
-		if (!in_req)
-			goto fail;
-
-		out_req = lb_alloc_ep_req(loop->out_ep, loop->buflen);
-		if (!out_req)
-			goto fail_in;
-
-		in_req->complete = loopback_complete;
-		out_req->complete = loopback_complete;
-
-		in_req->buf = out_req->buf;
-		/* length will be set in complete routine */
-		in_req->context = out_req;
-		out_req->context = in_req;
-
-		result = usb_ep_queue(loop->out_ep, out_req, GFP_ATOMIC);
-		if (result) {
-			ERROR(cdev, "%s queue req --> %d\n",
-					loop->out_ep->name, result);
-			goto fail_out;
-		}
-	}
-
-	return 0;
-
-fail_out:
-	free_ep_req(loop->out_ep, out_req);
-fail_in:
-	usb_ep_free_request(loop->in_ep, in_req);
-fail:
-	return result;
-}
-
-static int enable_endpoint(struct usb_composite_dev *cdev,
-			   struct f_loopback *loop, struct usb_ep *ep)
+static int
+enable_loopback(struct usb_composite_dev *cdev, struct f_loopback *loop)
 {
-	int					result;
+	int					result = 0;
+	struct usb_ep				*ep;
+	struct usb_request			*req;
+	unsigned				i;
 
+	/* one endpoint writes data back IN to the host */
+	ep = loop->in_ep;
 	result = config_ep_by_speed(cdev->gadget, &(loop->function), ep);
 	if (result)
-		goto out;
-
+		return result;
 	result = usb_ep_enable(ep);
 	if (result < 0)
-		goto out;
+		return result;
 	ep->driver_data = loop;
-	result = 0;
-
-out:
-	return result;
-}
-
-static int
-enable_loopback(struct usb_composite_dev *cdev, struct f_loopback *loop)
-{
-	int					result = 0;
 
-	result = enable_endpoint(cdev, loop, loop->in_ep);
+	/* one endpoint just reads OUT packets */
+	ep = loop->out_ep;
+	result = config_ep_by_speed(cdev->gadget, &(loop->function), ep);
 	if (result)
-		goto out;
+		goto fail0;
 
-	result = enable_endpoint(cdev, loop, loop->out_ep);
-	if (result)
-		goto disable_in;
+	result = usb_ep_enable(ep);
+	if (result < 0) {
+fail0:
+		ep = loop->in_ep;
+		usb_ep_disable(ep);
+		ep->driver_data = NULL;
+		return result;
+	}
+	ep->driver_data = loop;
 
-	result = alloc_requests(cdev, loop);
-	if (result)
-		goto disable_out;
+	/* allocate a bunch of read buffers and queue them all at once.
+	 * we buffer at most 'qlen' transfers; fewer if any need more
+	 * than 'buflen' bytes each.
+	 */
+	for (i = 0; i < qlen && result == 0; i++) {
+		req = alloc_ep_req(ep);
+		if (req) {
+			req->complete = loopback_complete;
+			result = usb_ep_queue(ep, req, GFP_ATOMIC);
+			if (result)
+				ERROR(cdev, "%s queue req --> %d\n",
+						ep->name, result);
+		} else {
+			usb_ep_disable(ep);
+			ep->driver_data = NULL;
+			result = -ENOMEM;
+			goto fail0;
+		}
+	}
 
 	DBG(cdev, "%s enabled\n", loop->function.name);
-	return 0;
-
-disable_out:
-	usb_ep_disable(loop->out_ep);
-disable_in:
-	usb_ep_disable(loop->in_ep);
-out:
 	return result;
 }
 
@@ -415,7 +356,8 @@
 	struct usb_composite_dev *cdev = f->config->cdev;
 
 	/* we know alt is zero */
-	disable_loopback(loop);
+	if (loop->in_ep->driver_data)
+		disable_loopback(loop);
 	return enable_loopback(cdev, loop);
 }
 
@@ -426,177 +368,64 @@
 	disable_loopback(loop);
 }
 
-static struct usb_function *loopback_alloc(struct usb_function_instance *fi)
+/*-------------------------------------------------------------------------*/
+
+static int __init loopback_bind_config(struct usb_configuration *c)
 {
 	struct f_loopback	*loop;
-	struct f_lb_opts	*lb_opts;
+	int			status;
 
 	loop = kzalloc(sizeof *loop, GFP_KERNEL);
 	if (!loop)
-		return ERR_PTR(-ENOMEM);
-
-	lb_opts = container_of(fi, struct f_lb_opts, func_inst);
-
-	mutex_lock(&lb_opts->lock);
-	lb_opts->refcnt++;
-	mutex_unlock(&lb_opts->lock);
-
-	loop->buflen = lb_opts->bulk_buflen;
-	loop->qlen = lb_opts->qlen;
-	if (!loop->qlen)
-		loop->qlen = 32;
+		return -ENOMEM;
 
 	loop->function.name = "loopback";
+	loop->function.fs_descriptors = fs_loopback_descs;
 	loop->function.bind = loopback_bind;
+	loop->function.unbind = loopback_unbind;
 	loop->function.set_alt = loopback_set_alt;
 	loop->function.disable = loopback_disable;
-	loop->function.strings = loopback_strings;
-
-	loop->function.free_func = lb_free_func;
-
-	return &loop->function;
-}
 
-static inline struct f_lb_opts *to_f_lb_opts(struct config_item *item)
-{
-	return container_of(to_config_group(item), struct f_lb_opts,
-			    func_inst.group);
-}
-
-static void lb_attr_release(struct config_item *item)
-{
-	struct f_lb_opts *lb_opts = to_f_lb_opts(item);
-
-	usb_put_function_instance(&lb_opts->func_inst);
-}
-
-static struct configfs_item_operations lb_item_ops = {
-	.release		= lb_attr_release,
-};
-
-static ssize_t f_lb_opts_qlen_show(struct config_item *item, char *page)
-{
-	struct f_lb_opts *opts = to_f_lb_opts(item);
-	int result;
-
-	mutex_lock(&opts->lock);
-	result = sprintf(page, "%d\n", opts->qlen);
-	mutex_unlock(&opts->lock);
-
-	return result;
-}
-
-static ssize_t f_lb_opts_qlen_store(struct config_item *item,
-				    const char *page, size_t len)
-{
-	struct f_lb_opts *opts = to_f_lb_opts(item);
-	int ret;
-	u32 num;
-
-	mutex_lock(&opts->lock);
-	if (opts->refcnt) {
-		ret = -EBUSY;
-		goto end;
-	}
-
-	ret = kstrtou32(page, 0, &num);
-	if (ret)
-		goto end;
-
-	opts->qlen = num;
-	ret = len;
-end:
-	mutex_unlock(&opts->lock);
-	return ret;
-}
-
-CONFIGFS_ATTR(f_lb_opts_, qlen);
-
-static ssize_t f_lb_opts_bulk_buflen_show(struct config_item *item, char *page)
+	status = usb_add_function(c, &loop->function);
+	if (status)
+		kfree(loop);
+	return status;
+}
+
+static struct usb_configuration loopback_driver = {
+	.label		= "loopback",
+	.strings	= loopback_strings,
+	.bConfigurationValue = 2,
+	.bmAttributes	= USB_CONFIG_ATT_SELFPOWER,
+	/* .iConfiguration = DYNAMIC */
+};
+
+/**
+ * loopback_add - add a loopback testing configuration to a device
+ * @cdev: the device to support the loopback configuration
+ */
+int __init loopback_add(struct usb_composite_dev *cdev, bool autoresume)
 {
-	struct f_lb_opts *opts = to_f_lb_opts(item);
-	int result;
+	int id;
 
-	mutex_lock(&opts->lock);
-	result = sprintf(page, "%d\n", opts->bulk_buflen);
-	mutex_unlock(&opts->lock);
+	/* allocate string ID(s) */
+	id = usb_string_id(cdev);
+	if (id < 0)
+		return id;
+	strings_loopback[0].id = id;
 
-	return result;
-}
+	loopback_intf.iInterface = id;
+	loopback_driver.iConfiguration = id;
 
-static ssize_t f_lb_opts_bulk_buflen_store(struct config_item *item,
-				    const char *page, size_t len)
-{
-	struct f_lb_opts *opts = to_f_lb_opts(item);
-	int ret;
-	u32 num;
-
-	mutex_lock(&opts->lock);
-	if (opts->refcnt) {
-		ret = -EBUSY;
-		goto end;
+	/* support autoresume for remote wakeup testing */
+	if (autoresume)
+		loopback_driver.bmAttributes |= USB_CONFIG_ATT_WAKEUP;
+
+	/* support OTG systems */
+	if (gadget_is_otg(cdev->gadget)) {
+		loopback_driver.descriptors = otg_desc;
+		loopback_driver.bmAttributes |= USB_CONFIG_ATT_WAKEUP;
 	}
 
-	ret = kstrtou32(page, 0, &num);
-	if (ret)
-		goto end;
-
-	opts->bulk_buflen = num;
-	ret = len;
-end:
-	mutex_unlock(&opts->lock);
-	return ret;
-}
-
-CONFIGFS_ATTR(f_lb_opts_, bulk_buflen);
-
-static struct configfs_attribute *lb_attrs[] = {
-	&f_lb_opts_attr_qlen,
-	&f_lb_opts_attr_bulk_buflen,
-	NULL,
-};
-
-static struct config_item_type lb_func_type = {
-	.ct_item_ops    = &lb_item_ops,
-	.ct_attrs	= lb_attrs,
-	.ct_owner       = THIS_MODULE,
-};
-
-static void lb_free_instance(struct usb_function_instance *fi)
-{
-	struct f_lb_opts *lb_opts;
-
-	lb_opts = container_of(fi, struct f_lb_opts, func_inst);
-	kfree(lb_opts);
-}
-
-static struct usb_function_instance *loopback_alloc_instance(void)
-{
-	struct f_lb_opts *lb_opts;
-
-	lb_opts = kzalloc(sizeof(*lb_opts), GFP_KERNEL);
-	if (!lb_opts)
-		return ERR_PTR(-ENOMEM);
-	mutex_init(&lb_opts->lock);
-	lb_opts->func_inst.free_func_inst = lb_free_instance;
-	lb_opts->bulk_buflen = GZERO_BULK_BUFLEN;
-	lb_opts->qlen = GZERO_QLEN;
-
-	config_group_init_type_name(&lb_opts->func_inst.group, "",
-				    &lb_func_type);
-
-	return  &lb_opts->func_inst;
+	return usb_add_config(cdev, &loopback_driver, loopback_bind_config);
 }
-DECLARE_USB_FUNCTION(Loopback, loopback_alloc_instance, loopback_alloc);
-
-int __init lb_modinit(void)
-{
-	return usb_function_register(&Loopbackusb_func);
-}
-
-void __exit lb_modexit(void)
-{
-	usb_function_unregister(&Loopbackusb_func);
-}
-
-MODULE_LICENSE("GPL");
--- a/drivers/usb/gadget/function/f_sourcesink.c	2018-11-23 10:16:15.964818746 +0300
+++ a/drivers/usb/gadget/function/f_sourcesink.c	2018-11-23 10:31:03.793051288 +0300
@@ -16,11 +16,9 @@
 #include <linux/kernel.h>
 #include <linux/device.h>
 #include <linux/module.h>
-#include <linux/usb/composite.h>
-#include <linux/err.h>
 
 #include "g_zero.h"
-#include "u_f.h"
+
 
 /*
  * SOURCE/SINK FUNCTION ... a primary testing vehicle for USB peripheral
@@ -34,24 +32,24 @@
  * plus two that support control-OUT tests.  If the optional "autoresume"
  * mode is enabled, it provides good functional coverage for the "USBCV"
  * test harness from USB-IF.
+ *
+ * Note that because this doesn't queue more than one request at a time,
+ * some other function must be used to test queueing logic.  The network
+ * link (g_ether) is the best overall option for that, since its TX and RX
+ * queues are relatively independent, will receive a range of packet sizes,
+ * and can often be made to run out completely.  Those issues are important
+ * when stress testing peripheral controller drivers.
+ *
+ *
+ * This is currently packaged as a configuration driver, which can't be
+ * combined with other functions to make composite devices.  However, it
+ * can be combined with other independent configurations.
  */
 struct f_sourcesink {
 	struct usb_function	function;
 
 	struct usb_ep		*in_ep;
 	struct usb_ep		*out_ep;
-	struct usb_ep		*iso_in_ep;
-	struct usb_ep		*iso_out_ep;
-	int			cur_alt;
-
-	unsigned pattern;
-	unsigned isoc_interval;
-	unsigned isoc_maxpacket;
-	unsigned isoc_mult;
-	unsigned isoc_maxburst;
-	unsigned buflen;
-	unsigned bulk_qlen;
-	unsigned iso_qlen;
 };
 
 static inline struct f_sourcesink *func_to_ss(struct usb_function *f)
@@ -59,26 +57,19 @@
 	return container_of(f, struct f_sourcesink, function);
 }
 
+static unsigned pattern;
+module_param(pattern, uint, 0644);
+MODULE_PARM_DESC(pattern, "0 = all zeroes, 1 = mod63 ");
+
 /*-------------------------------------------------------------------------*/
 
-static struct usb_interface_descriptor source_sink_intf_alt0 = {
-	.bLength =		USB_DT_INTERFACE_SIZE,
+static struct usb_interface_descriptor source_sink_intf = {
+	.bLength =		sizeof source_sink_intf,
 	.bDescriptorType =	USB_DT_INTERFACE,
 
-	.bAlternateSetting =	0,
 	.bNumEndpoints =	2,
 	.bInterfaceClass =	USB_CLASS_VENDOR_SPEC,
-	/* .iInterface		= DYNAMIC */
-};
-
-static struct usb_interface_descriptor source_sink_intf_alt1 = {
-	.bLength =		USB_DT_INTERFACE_SIZE,
-	.bDescriptorType =	USB_DT_INTERFACE,
-
-	.bAlternateSetting =	1,
-	.bNumEndpoints =	4,
-	.bInterfaceClass =	USB_CLASS_VENDOR_SPEC,
-	/* .iInterface		= DYNAMIC */
+	/* .iInterface = DYNAMIC */
 };
 
 /* full speed support: */
@@ -99,36 +90,10 @@
 	.bmAttributes =		USB_ENDPOINT_XFER_BULK,
 };
 
-static struct usb_endpoint_descriptor fs_iso_source_desc = {
-	.bLength =		USB_DT_ENDPOINT_SIZE,
-	.bDescriptorType =	USB_DT_ENDPOINT,
-
-	.bEndpointAddress =	USB_DIR_IN,
-	.bmAttributes =		USB_ENDPOINT_XFER_ISOC,
-	.wMaxPacketSize =	cpu_to_le16(1023),
-	.bInterval =		4,
-};
-
-static struct usb_endpoint_descriptor fs_iso_sink_desc = {
-	.bLength =		USB_DT_ENDPOINT_SIZE,
-	.bDescriptorType =	USB_DT_ENDPOINT,
-
-	.bEndpointAddress =	USB_DIR_OUT,
-	.bmAttributes =		USB_ENDPOINT_XFER_ISOC,
-	.wMaxPacketSize =	cpu_to_le16(1023),
-	.bInterval =		4,
-};
-
 static struct usb_descriptor_header *fs_source_sink_descs[] = {
-	(struct usb_descriptor_header *) &source_sink_intf_alt0,
-	(struct usb_descriptor_header *) &fs_sink_desc,
-	(struct usb_descriptor_header *) &fs_source_desc,
-	(struct usb_descriptor_header *) &source_sink_intf_alt1,
-#define FS_ALT_IFC_1_OFFSET	3
+	(struct usb_descriptor_header *) &source_sink_intf,
 	(struct usb_descriptor_header *) &fs_sink_desc,
 	(struct usb_descriptor_header *) &fs_source_desc,
-	(struct usb_descriptor_header *) &fs_iso_sink_desc,
-	(struct usb_descriptor_header *) &fs_iso_source_desc,
 	NULL,
 };
 
@@ -150,34 +115,10 @@
 	.wMaxPacketSize =	cpu_to_le16(512),
 };
 
-static struct usb_endpoint_descriptor hs_iso_source_desc = {
-	.bLength =		USB_DT_ENDPOINT_SIZE,
-	.bDescriptorType =	USB_DT_ENDPOINT,
-
-	.bmAttributes =		USB_ENDPOINT_XFER_ISOC,
-	.wMaxPacketSize =	cpu_to_le16(1024),
-	.bInterval =		4,
-};
-
-static struct usb_endpoint_descriptor hs_iso_sink_desc = {
-	.bLength =		USB_DT_ENDPOINT_SIZE,
-	.bDescriptorType =	USB_DT_ENDPOINT,
-
-	.bmAttributes =		USB_ENDPOINT_XFER_ISOC,
-	.wMaxPacketSize =	cpu_to_le16(1024),
-	.bInterval =		4,
-};
-
 static struct usb_descriptor_header *hs_source_sink_descs[] = {
-	(struct usb_descriptor_header *) &source_sink_intf_alt0,
+	(struct usb_descriptor_header *) &source_sink_intf,
 	(struct usb_descriptor_header *) &hs_source_desc,
 	(struct usb_descriptor_header *) &hs_sink_desc,
-	(struct usb_descriptor_header *) &source_sink_intf_alt1,
-#define HS_ALT_IFC_1_OFFSET	3
-	(struct usb_descriptor_header *) &hs_source_desc,
-	(struct usb_descriptor_header *) &hs_sink_desc,
-	(struct usb_descriptor_header *) &hs_iso_source_desc,
-	(struct usb_descriptor_header *) &hs_iso_sink_desc,
 	NULL,
 };
 
@@ -191,10 +132,9 @@
 	.wMaxPacketSize =	cpu_to_le16(1024),
 };
 
-static struct usb_ss_ep_comp_descriptor ss_source_comp_desc = {
+struct usb_ss_ep_comp_descriptor ss_source_comp_desc = {
 	.bLength =		USB_DT_SS_EP_COMP_SIZE,
 	.bDescriptorType =	USB_DT_SS_ENDPOINT_COMP,
-
 	.bMaxBurst =		0,
 	.bmAttributes =		0,
 	.wBytesPerInterval =	0,
@@ -208,67 +148,20 @@
 	.wMaxPacketSize =	cpu_to_le16(1024),
 };
 
-static struct usb_ss_ep_comp_descriptor ss_sink_comp_desc = {
+struct usb_ss_ep_comp_descriptor ss_sink_comp_desc = {
 	.bLength =		USB_DT_SS_EP_COMP_SIZE,
 	.bDescriptorType =	USB_DT_SS_ENDPOINT_COMP,
-
 	.bMaxBurst =		0,
 	.bmAttributes =		0,
 	.wBytesPerInterval =	0,
 };
 
-static struct usb_endpoint_descriptor ss_iso_source_desc = {
-	.bLength =		USB_DT_ENDPOINT_SIZE,
-	.bDescriptorType =	USB_DT_ENDPOINT,
-
-	.bmAttributes =		USB_ENDPOINT_XFER_ISOC,
-	.wMaxPacketSize =	cpu_to_le16(1024),
-	.bInterval =		4,
-};
-
-static struct usb_ss_ep_comp_descriptor ss_iso_source_comp_desc = {
-	.bLength =		USB_DT_SS_EP_COMP_SIZE,
-	.bDescriptorType =	USB_DT_SS_ENDPOINT_COMP,
-
-	.bMaxBurst =		0,
-	.bmAttributes =		0,
-	.wBytesPerInterval =	cpu_to_le16(1024),
-};
-
-static struct usb_endpoint_descriptor ss_iso_sink_desc = {
-	.bLength =		USB_DT_ENDPOINT_SIZE,
-	.bDescriptorType =	USB_DT_ENDPOINT,
-
-	.bmAttributes =		USB_ENDPOINT_XFER_ISOC,
-	.wMaxPacketSize =	cpu_to_le16(1024),
-	.bInterval =		4,
-};
-
-static struct usb_ss_ep_comp_descriptor ss_iso_sink_comp_desc = {
-	.bLength =		USB_DT_SS_EP_COMP_SIZE,
-	.bDescriptorType =	USB_DT_SS_ENDPOINT_COMP,
-
-	.bMaxBurst =		0,
-	.bmAttributes =		0,
-	.wBytesPerInterval =	cpu_to_le16(1024),
-};
-
 static struct usb_descriptor_header *ss_source_sink_descs[] = {
-	(struct usb_descriptor_header *) &source_sink_intf_alt0,
+	(struct usb_descriptor_header *) &source_sink_intf,
 	(struct usb_descriptor_header *) &ss_source_desc,
 	(struct usb_descriptor_header *) &ss_source_comp_desc,
 	(struct usb_descriptor_header *) &ss_sink_desc,
 	(struct usb_descriptor_header *) &ss_sink_comp_desc,
-	(struct usb_descriptor_header *) &source_sink_intf_alt1,
-#define SS_ALT_IFC_1_OFFSET	5
-	(struct usb_descriptor_header *) &ss_source_desc,
-	(struct usb_descriptor_header *) &ss_source_comp_desc,
-	(struct usb_descriptor_header *) &ss_sink_desc,
-	(struct usb_descriptor_header *) &ss_sink_comp_desc,
-	(struct usb_descriptor_header *) &ss_iso_source_desc,
-	(struct usb_descriptor_header *) &ss_iso_source_comp_desc,
-	(struct usb_descriptor_header *) &ss_iso_sink_desc,
-	(struct usb_descriptor_header *) &ss_iso_sink_comp_desc,
 	NULL,
 };
 
@@ -291,191 +184,96 @@
 
 /*-------------------------------------------------------------------------*/
 
-static inline struct usb_request *ss_alloc_ep_req(struct usb_ep *ep, int len)
-{
-	return alloc_ep_req(ep, len);
-}
-
-static void disable_ep(struct usb_composite_dev *cdev, struct usb_ep *ep)
-{
-	int			value;
-
-	value = usb_ep_disable(ep);
-	if (value < 0)
-		DBG(cdev, "disable %s --> %d\n", ep->name, value);
-}
-
-void disable_endpoints(struct usb_composite_dev *cdev,
-		struct usb_ep *in, struct usb_ep *out,
-		struct usb_ep *iso_in, struct usb_ep *iso_out)
-{
-	disable_ep(cdev, in);
-	disable_ep(cdev, out);
-	if (iso_in)
-		disable_ep(cdev, iso_in);
-	if (iso_out)
-		disable_ep(cdev, iso_out);
-}
-
-static int
+static int __init
 sourcesink_bind(struct usb_configuration *c, struct usb_function *f)
 {
 	struct usb_composite_dev *cdev = c->cdev;
 	struct f_sourcesink	*ss = func_to_ss(f);
 	int	id;
-	int ret;
 
 	/* allocate interface ID(s) */
 	id = usb_interface_id(c, f);
 	if (id < 0)
 		return id;
-	source_sink_intf_alt0.bInterfaceNumber = id;
-	source_sink_intf_alt1.bInterfaceNumber = id;
+	source_sink_intf.bInterfaceNumber = id;
 
-	/* allocate bulk endpoints */
+	/* allocate endpoints */
 	ss->in_ep = usb_ep_autoconfig(cdev->gadget, &fs_source_desc);
 	if (!ss->in_ep) {
 autoconf_fail:
-		ERROR(cdev, "%s: can't autoconfigure on %s\n",
+		printk(KERN_NOTICE "%s: can't autoconfigure on %s\n",
 			f->name, cdev->gadget->name);
 		return -ENODEV;
 	}
+	ss->in_ep->driver_data = cdev;	/* claim */
 
 	ss->out_ep = usb_ep_autoconfig(cdev->gadget, &fs_sink_desc);
 	if (!ss->out_ep)
 		goto autoconf_fail;
-
-	/* sanity check the isoc module parameters */
-	if (ss->isoc_interval < 1)
-		ss->isoc_interval = 1;
-	if (ss->isoc_interval > 16)
-		ss->isoc_interval = 16;
-	if (ss->isoc_mult > 2)
-		ss->isoc_mult = 2;
-	if (ss->isoc_maxburst > 15)
-		ss->isoc_maxburst = 15;
-
-	/* fill in the FS isoc descriptors from the module parameters */
-	fs_iso_source_desc.wMaxPacketSize = ss->isoc_maxpacket > 1023 ?
-						1023 : ss->isoc_maxpacket;
-	fs_iso_source_desc.bInterval = ss->isoc_interval;
-	fs_iso_sink_desc.wMaxPacketSize = ss->isoc_maxpacket > 1023 ?
-						1023 : ss->isoc_maxpacket;
-	fs_iso_sink_desc.bInterval = ss->isoc_interval;
-
-	/* allocate iso endpoints */
-	ss->iso_in_ep = usb_ep_autoconfig(cdev->gadget, &fs_iso_source_desc);
-	if (!ss->iso_in_ep)
-		goto no_iso;
-
-	ss->iso_out_ep = usb_ep_autoconfig(cdev->gadget, &fs_iso_sink_desc);
-	if (!ss->iso_out_ep) {
-		usb_ep_autoconfig_release(ss->iso_in_ep);
-		ss->iso_in_ep = NULL;
-no_iso:
-		/*
-		 * We still want to work even if the UDC doesn't have isoc
-		 * endpoints, so null out the alt interface that contains
-		 * them and continue.
-		 */
-		fs_source_sink_descs[FS_ALT_IFC_1_OFFSET] = NULL;
-		hs_source_sink_descs[HS_ALT_IFC_1_OFFSET] = NULL;
-		ss_source_sink_descs[SS_ALT_IFC_1_OFFSET] = NULL;
-	}
-
-	if (ss->isoc_maxpacket > 1024)
-		ss->isoc_maxpacket = 1024;
+	ss->out_ep->driver_data = cdev;	/* claim */
 
 	/* support high speed hardware */
-	hs_source_desc.bEndpointAddress = fs_source_desc.bEndpointAddress;
-	hs_sink_desc.bEndpointAddress = fs_sink_desc.bEndpointAddress;
-
-	/*
-	 * Fill in the HS isoc descriptors from the module parameters.
-	 * We assume that the user knows what they are doing and won't
-	 * give parameters that their UDC doesn't support.
-	 */
-	hs_iso_source_desc.wMaxPacketSize = ss->isoc_maxpacket;
-	hs_iso_source_desc.wMaxPacketSize |= ss->isoc_mult << 11;
-	hs_iso_source_desc.bInterval = ss->isoc_interval;
-	hs_iso_source_desc.bEndpointAddress =
-		fs_iso_source_desc.bEndpointAddress;
-
-	hs_iso_sink_desc.wMaxPacketSize = ss->isoc_maxpacket;
-	hs_iso_sink_desc.wMaxPacketSize |= ss->isoc_mult << 11;
-	hs_iso_sink_desc.bInterval = ss->isoc_interval;
-	hs_iso_sink_desc.bEndpointAddress = fs_iso_sink_desc.bEndpointAddress;
+	if (gadget_is_dualspeed(c->cdev->gadget)) {
+		hs_source_desc.bEndpointAddress =
+				fs_source_desc.bEndpointAddress;
+		hs_sink_desc.bEndpointAddress =
+				fs_sink_desc.bEndpointAddress;
+		f->hs_descriptors = hs_source_sink_descs;
+	}
 
 	/* support super speed hardware */
-	ss_source_desc.bEndpointAddress =
-		fs_source_desc.bEndpointAddress;
-	ss_sink_desc.bEndpointAddress =
-		fs_sink_desc.bEndpointAddress;
-
-	/*
-	 * Fill in the SS isoc descriptors from the module parameters.
-	 * We assume that the user knows what they are doing and won't
-	 * give parameters that their UDC doesn't support.
-	 */
-	ss_iso_source_desc.wMaxPacketSize = ss->isoc_maxpacket;
-	ss_iso_source_desc.bInterval = ss->isoc_interval;
-	ss_iso_source_comp_desc.bmAttributes = ss->isoc_mult;
-	ss_iso_source_comp_desc.bMaxBurst = ss->isoc_maxburst;
-	ss_iso_source_comp_desc.wBytesPerInterval = ss->isoc_maxpacket *
-		(ss->isoc_mult + 1) * (ss->isoc_maxburst + 1);
-	ss_iso_source_desc.bEndpointAddress =
-		fs_iso_source_desc.bEndpointAddress;
-
-	ss_iso_sink_desc.wMaxPacketSize = ss->isoc_maxpacket;
-	ss_iso_sink_desc.bInterval = ss->isoc_interval;
-	ss_iso_sink_comp_desc.bmAttributes = ss->isoc_mult;
-	ss_iso_sink_comp_desc.bMaxBurst = ss->isoc_maxburst;
-	ss_iso_sink_comp_desc.wBytesPerInterval = ss->isoc_maxpacket *
-		(ss->isoc_mult + 1) * (ss->isoc_maxburst + 1);
-	ss_iso_sink_desc.bEndpointAddress = fs_iso_sink_desc.bEndpointAddress;
-
-	ret = usb_assign_descriptors(f, fs_source_sink_descs,
-			hs_source_sink_descs, ss_source_sink_descs, NULL);
-	if (ret)
-		return ret;
+	if (gadget_is_superspeed(c->cdev->gadget)) {
+		ss_source_desc.bEndpointAddress =
+				fs_source_desc.bEndpointAddress;
+		ss_sink_desc.bEndpointAddress =
+				fs_sink_desc.bEndpointAddress;
+		f->ss_descriptors = ss_source_sink_descs;
+	}
 
-	DBG(cdev, "%s speed %s: IN/%s, OUT/%s, ISO-IN/%s, ISO-OUT/%s\n",
+	printk(KERN_NOTICE "%s speed %s: IN/%s, OUT/%s\n",
 	    (gadget_is_superspeed(c->cdev->gadget) ? "super" :
 	     (gadget_is_dualspeed(c->cdev->gadget) ? "dual" : "full")),
-			f->name, ss->in_ep->name, ss->out_ep->name,
-			ss->iso_in_ep ? ss->iso_in_ep->name : "<none>",
-			ss->iso_out_ep ? ss->iso_out_ep->name : "<none>");
+			f->name, ss->in_ep->name, ss->out_ep->name);
 	return 0;
 }
 
 static void
-sourcesink_free_func(struct usb_function *f)
+sourcesink_unbind(struct usb_configuration *c, struct usb_function *f)
 {
-	struct f_ss_opts *opts;
-
-	opts = container_of(f->fi, struct f_ss_opts, func_inst);
-
-	mutex_lock(&opts->lock);
-	opts->refcnt--;
-	mutex_unlock(&opts->lock);
-
-	usb_free_all_descriptors(f);
 	kfree(func_to_ss(f));
 }
+void PrintBlock_usb1(unsigned char* pBuffStar, unsigned int uiBuffLen)
+{
+	unsigned int uiIter;
+	pBuffStar = pBuffStar;
+	printk(KERN_NOTICE "pBuffStar=%p\n", pBuffStar);
+	printk(KERN_NOTICE " %02x", pBuffStar[0]);
+	for (uiIter = 1; uiIter < uiBuffLen; uiIter++){
+		if (uiIter % 16 == 0)
+			printk(KERN_NOTICE "\n");
+		if (uiIter % 512 == 0)
+			printk(KERN_NOTICE "\n");
+		printk(KERN_NOTICE " %02x", pBuffStar[uiIter]);
+	}
+	printk(KERN_NOTICE "\n");
+}
 
 /* optionally require specific source/sink data patterns  */
 static int check_read_data(struct f_sourcesink *ss, struct usb_request *req)
 {
 	unsigned		i;
 	u8			*buf = req->buf;
-	struct usb_composite_dev *cdev = ss->function.config->cdev;
-	int max_packet_size = le16_to_cpu(ss->out_ep->desc->wMaxPacketSize);
-
-	if (ss->pattern == 2)
-		return 0;
-
-	for (i = 0; i < req->actual; i++, buf++) {
-		switch (ss->pattern) {
+	//ERROR(cdev, "note buf[0] = %d\n",*buf);
+	//buf = buf + 2;
+	u32 	*p=(u32 *)buf;
+	u32 	p0 = *((u32 *)p);
+	u32 	pend = p[(req->actual)/4 -1];
+	//PrintBlock_usb1(req->buf, req->actual);
+	
+	printk(KERN_NOTICE "buf0=%x pend=%x p0+len=%x\n",p0,pend,(p0+(req->actual)/4 -1));
+	//for (i = 0; i < req->actual; i++, buf++) {
+	for (i = 0; i < (req->actual)/4; i++, p++) {
+		switch (pattern) {
 
 		/* all-zeroes has no synchronization issues */
 		case 0:
@@ -488,67 +286,79 @@
 		 * each usb transfer request should be.  Resync is done
 		 * with set_interface or set_config.  (We *WANT* it to
 		 * get quickly out of sync if controllers or their drivers
-		 * stutter for any reason, including buffer duplication...)
+		 * stutter for any reason, including buffer duplcation...)
 		 */
 		case 1:
-			if (*buf == (u8)((i % max_packet_size) % 63))
+			//if ((i % 512) == 0)
+			//	buf0 = *buf;
+			//if (*buf == (u8)((buf0 + (i /*% 512*/)) % 63) )
+			if(*((u32 *)p) == p0 + (u32)i)
 				continue;
+			printk(KERN_NOTICE "+%s.%d,%x,%x\n", __FUNCTION__, __LINE__,*((u32 *)p),p0 + (u32)i);
 			break;
 		}
-		ERROR(cdev, "bad OUT byte, buf[%d] = %d\n", i, *buf);
+		//ERROR(cdev, "bad OUT byte, buf[%d] = %d should %d\n", i, *buf,((u8)((buf0 + (i/* % 512*/)) % 63)));
+		printk(KERN_NOTICE "bad OUT byte, buf[%d] = %x should %x\n", i, *((u32 *)buf),(p0 + (u32)i));
+		
+		PrintBlock_usb1(req->buf, req->actual);
+		
+		
+		//return 0;
 		usb_ep_set_halt(ss->out_ep);
 		return -EINVAL;
 	}
+	printk(KERN_NOTICE "buf0=%x\n",*((u32 *)(p-1)));
 	return 0;
 }
+static int check_pattern=0;
 
 static void reinit_write_data(struct usb_ep *ep, struct usb_request *req)
 {
 	unsigned	i;
 	u8		*buf = req->buf;
-	int max_packet_size = le16_to_cpu(ep->desc->wMaxPacketSize);
-	struct f_sourcesink *ss = ep->driver_data;
-
-	switch (ss->pattern) {
+	u32 *p;
+	unsigned	t;
+	t = (req->length + 3) / 4;
+	switch (pattern) {
 	case 0:
 		memset(req->buf, 0, req->length);
 		break;
 	case 1:
+		#if 0
 		for  (i = 0; i < req->length; i++)
-			*buf++ = (u8) ((i % max_packet_size) % 63);
-		break;
-	case 2:
+			*buf++ = (u8) (i % 63);
+		#else
+		p = (u32 *)buf;
+		
+		for(i = check_pattern; i < check_pattern + t;i++)
+			*p++ = (u32)i;
+		check_pattern = i;
+		#endif
 		break;
 	}
 }
 
 static void source_sink_complete(struct usb_ep *ep, struct usb_request *req)
 {
-	struct usb_composite_dev	*cdev;
-	struct f_sourcesink		*ss = ep->driver_data;
-	int				status = req->status;
-
-	/* driver_data will be null if ep has been disabled */
-	if (!ss)
-		return;
-
-	cdev = ss->function.config->cdev;
+	struct f_sourcesink	*ss = ep->driver_data;
+	int			status = req->status;
 
+	printk(KERN_NOTICE "source_sink_complete,s:%d,ep_n:%s\n",status,ep->name);
 	switch (status) {
 
 	case 0:				/* normal completion? */
 		if (ep == ss->out_ep) {
 			check_read_data(ss, req);
-			if (ss->pattern != 2)
-				memset(req->buf, 0x55, req->length);
-		}
+			memset(req->buf, 0x55, req->length);
+		} else
+			reinit_write_data(ep, req);
 		break;
 
 	/* this endpoint is normally active while we're configured */
 	case -ECONNABORTED:		/* hardware forced ep reset */
 	case -ECONNRESET:		/* request dequeued */
 	case -ESHUTDOWN:		/* disconnect from host */
-		VDBG(cdev, "%s gone (%d), %d/%d\n", ep->name, status,
+		printk(KERN_NOTICE "%s gone (%d), %d/%d\n", ep->name, status,
 				req->actual, req->length);
 		if (ep == ss->out_ep)
 			check_read_data(ss, req);
@@ -561,7 +371,7 @@
 					 */
 	default:
 #if 1
-		DBG(cdev, "%s complete --> %d, %d/%d\n", ep->name,
+		printk(KERN_NOTICE "%s complete --> %d, %d/%d\n", ep->name,
 				status, req->actual, req->length);
 #endif
 	case -EREMOTEIO:		/* short read */
@@ -570,65 +380,39 @@
 
 	status = usb_ep_queue(ep, req, GFP_ATOMIC);
 	if (status) {
-		ERROR(cdev, "kill %s:  resubmit %d bytes --> %d\n",
+		printk(KERN_NOTICE "kill %s:  resubmit %d bytes --> %d\n",
 				ep->name, req->length, status);
 		usb_ep_set_halt(ep);
 		/* FIXME recover later ... somehow */
 	}
 }
 
-static int source_sink_start_ep(struct f_sourcesink *ss, bool is_in,
-		bool is_iso, int speed)
+static int source_sink_start_ep(struct f_sourcesink *ss, bool is_in)
 {
 	struct usb_ep		*ep;
 	struct usb_request	*req;
-	int			i, size, qlen, status = 0;
+	int			status;
 
-	if (is_iso) {
-		switch (speed) {
-		case USB_SPEED_SUPER:
-			size = ss->isoc_maxpacket *
-					(ss->isoc_mult + 1) *
-					(ss->isoc_maxburst + 1);
-			break;
-		case USB_SPEED_HIGH:
-			size = ss->isoc_maxpacket * (ss->isoc_mult + 1);
-			break;
-		default:
-			size = ss->isoc_maxpacket > 1023 ?
-					1023 : ss->isoc_maxpacket;
-			break;
-		}
-		ep = is_in ? ss->iso_in_ep : ss->iso_out_ep;
-		qlen = ss->iso_qlen;
-	} else {
-		ep = is_in ? ss->in_ep : ss->out_ep;
-		qlen = ss->bulk_qlen;
-		size = ss->buflen;
-	}
+	ep = is_in ? ss->in_ep : ss->out_ep;
+	req = alloc_ep_req(ep);
+	if (!req)
+		return -ENOMEM;
+
+	req->complete = source_sink_complete;
+	if (is_in)
+		reinit_write_data(ep, req);
+	else
+		memset(req->buf, 0x55, req->length);
 
-	for (i = 0; i < qlen; i++) {
-		req = ss_alloc_ep_req(ep, size);
-		if (!req)
-			return -ENOMEM;
-
-		req->complete = source_sink_complete;
-		if (is_in)
-			reinit_write_data(ep, req);
-		else if (ss->pattern != 2)
-			memset(req->buf, 0x55, req->length);
+	status = usb_ep_queue(ep, req, GFP_ATOMIC);
+	if (status) {
+		struct usb_composite_dev	*cdev;
 
-		status = usb_ep_queue(ep, req, GFP_ATOMIC);
-		if (status) {
-			struct usb_composite_dev	*cdev;
-
-			cdev = ss->function.config->cdev;
-			ERROR(cdev, "start %s%s %s --> %d\n",
-			      is_iso ? "ISO-" : "", is_in ? "IN" : "OUT",
-			      ep->name, status);
-			free_ep_req(ep, req);
-			return status;
-		}
+		cdev = ss->function.config->cdev;
+		printk(KERN_NOTICE "start %s %s --> %d\n",
+				is_in ? "IN" : "OUT",
+				ep->name, status);
+		free_ep_req(ep, req);
 	}
 
 	return status;
@@ -639,20 +423,17 @@
 	struct usb_composite_dev	*cdev;
 
 	cdev = ss->function.config->cdev;
-	disable_endpoints(cdev, ss->in_ep, ss->out_ep, ss->iso_in_ep,
-			ss->iso_out_ep);
-	VDBG(cdev, "%s disabled\n", ss->function.name);
+	disable_endpoints(cdev, ss->in_ep, ss->out_ep);
+	printk(KERN_NOTICE "%s disabled\n", ss->function.name);
 }
 
 static int
-enable_source_sink(struct usb_composite_dev *cdev, struct f_sourcesink *ss,
-		int alt)
+enable_source_sink(struct usb_composite_dev *cdev, struct f_sourcesink *ss)
 {
 	int					result = 0;
-	int					speed = cdev->gadget->speed;
 	struct usb_ep				*ep;
 
-	/* one bulk endpoint writes (sources) zeroes IN (to the host) */
+	/* one endpoint writes (sources) zeroes IN (to the host) */
 	ep = ss->in_ep;
 	result = config_ep_by_speed(cdev->gadget, &(ss->function), ep);
 	if (result)
@@ -662,15 +443,16 @@
 		return result;
 	ep->driver_data = ss;
 
-	result = source_sink_start_ep(ss, true, false, speed);
+	result = source_sink_start_ep(ss, true);
 	if (result < 0) {
 fail:
 		ep = ss->in_ep;
 		usb_ep_disable(ep);
+		ep->driver_data = NULL;
 		return result;
 	}
 
-	/* one bulk endpoint reads (sinks) anything OUT (from the host) */
+	/* one endpoint reads (sinks) anything OUT (from the host) */
 	ep = ss->out_ep;
 	result = config_ep_by_speed(cdev->gadget, &(ss->function), ep);
 	if (result)
@@ -680,77 +462,27 @@
 		goto fail;
 	ep->driver_data = ss;
 
-	result = source_sink_start_ep(ss, false, false, speed);
+	result = source_sink_start_ep(ss, false);
 	if (result < 0) {
-fail2:
-		ep = ss->out_ep;
 		usb_ep_disable(ep);
+		ep->driver_data = NULL;
 		goto fail;
 	}
 
-	if (alt == 0)
-		goto out;
-
-	/* one iso endpoint writes (sources) zeroes IN (to the host) */
-	ep = ss->iso_in_ep;
-	if (ep) {
-		result = config_ep_by_speed(cdev->gadget, &(ss->function), ep);
-		if (result)
-			goto fail2;
-		result = usb_ep_enable(ep);
-		if (result < 0)
-			goto fail2;
-		ep->driver_data = ss;
-
-		result = source_sink_start_ep(ss, true, true, speed);
-		if (result < 0) {
-fail3:
-			ep = ss->iso_in_ep;
-			if (ep)
-				usb_ep_disable(ep);
-			goto fail2;
-		}
-	}
-
-	/* one iso endpoint reads (sinks) anything OUT (from the host) */
-	ep = ss->iso_out_ep;
-	if (ep) {
-		result = config_ep_by_speed(cdev->gadget, &(ss->function), ep);
-		if (result)
-			goto fail3;
-		result = usb_ep_enable(ep);
-		if (result < 0)
-			goto fail3;
-		ep->driver_data = ss;
-
-		result = source_sink_start_ep(ss, false, true, speed);
-		if (result < 0) {
-			usb_ep_disable(ep);
-			goto fail3;
-		}
-	}
-out:
-	ss->cur_alt = alt;
-
-	DBG(cdev, "%s enabled, alt intf %d\n", ss->function.name, alt);
+	printk(KERN_NOTICE "%s enabled\n", ss->function.name);
 	return result;
 }
 
 static int sourcesink_set_alt(struct usb_function *f,
 		unsigned intf, unsigned alt)
 {
-	struct f_sourcesink		*ss = func_to_ss(f);
-	struct usb_composite_dev	*cdev = f->config->cdev;
-
-	disable_source_sink(ss);
-	return enable_source_sink(cdev, ss, alt);
-}
-
-static int sourcesink_get_alt(struct usb_function *f, unsigned intf)
-{
-	struct f_sourcesink		*ss = func_to_ss(f);
+	struct f_sourcesink	*ss = func_to_ss(f);
+	struct usb_composite_dev *cdev = f->config->cdev;
 
-	return ss->cur_alt;
+	/* we know alt is zero */
+	if (!ss->in_ep->driver_data)
+		disable_source_sink(ss);
+	return enable_source_sink(cdev, ss);
 }
 
 static void sourcesink_disable(struct usb_function *f)
@@ -762,17 +494,38 @@
 
 /*-------------------------------------------------------------------------*/
 
-static int sourcesink_setup(struct usb_function *f,
+static int __init sourcesink_bind_config(struct usb_configuration *c)
+{
+	struct f_sourcesink	*ss;
+	int			status;
+
+	ss = kzalloc(sizeof *ss, GFP_KERNEL);
+	if (!ss)
+		return -ENOMEM;
+
+	ss->function.name = "source/sink";
+	ss->function.fs_descriptors = fs_source_sink_descs;
+	ss->function.bind = sourcesink_bind;
+	ss->function.unbind = sourcesink_unbind;
+	ss->function.set_alt = sourcesink_set_alt;
+	ss->function.disable = sourcesink_disable;
+
+	status = usb_add_function(c, &ss->function);
+	if (status)
+		kfree(ss);
+	return status;
+}
+
+static int sourcesink_setup(struct usb_configuration *c,
 		const struct usb_ctrlrequest *ctrl)
 {
-	struct usb_configuration        *c = f->config;
 	struct usb_request	*req = c->cdev->req;
 	int			value = -EOPNOTSUPP;
 	u16			w_index = le16_to_cpu(ctrl->wIndex);
 	u16			w_value = le16_to_cpu(ctrl->wValue);
 	u16			w_length = le16_to_cpu(ctrl->wLength);
 
-	req->length = USB_COMP_EP0_BUFSIZ;
+	req->length = USB_BUFSIZ;
 
 	/* composite driver infrastructure handles everything except
 	 * the two control test requests.
@@ -811,22 +564,21 @@
 
 	default:
 unknown:
-		VDBG(c->cdev,
-			"unknown control req%02x.%02x v%04x i%04x l%d\n",
+		printk(KERN_NOTICE "unknown control req%02x.%02x v%04x i%04x l%d\n",
 			ctrl->bRequestType, ctrl->bRequest,
 			w_value, w_index, w_length);
 	}
 
 	/* respond with data transfer or status phase? */
 	if (value >= 0) {
-		VDBG(c->cdev, "source/sink req%02x.%02x v%04x i%04x l%d\n",
+		printk(KERN_NOTICE "source/sink req%02x.%02x v%04x i%04x l%d\n",
 			ctrl->bRequestType, ctrl->bRequest,
 			w_value, w_index, w_length);
 		req->zero = 0;
 		req->length = value;
 		value = usb_ep_queue(c->cdev->gadget->ep0, req, GFP_ATOMIC);
 		if (value < 0)
-			ERROR(c->cdev, "source/sink response, err %d\n",
+			printk(KERN_NOTICE "source/sinkc response, err %d\n",
 					value);
 	}
 
@@ -834,457 +586,41 @@
 	return value;
 }
 
-static struct usb_function *source_sink_alloc_func(
-		struct usb_function_instance *fi)
-{
-	struct f_sourcesink     *ss;
-	struct f_ss_opts	*ss_opts;
-
-	ss = kzalloc(sizeof(*ss), GFP_KERNEL);
-	if (!ss)
-		return NULL;
-
-	ss_opts =  container_of(fi, struct f_ss_opts, func_inst);
-
-	mutex_lock(&ss_opts->lock);
-	ss_opts->refcnt++;
-	mutex_unlock(&ss_opts->lock);
-
-	ss->pattern = ss_opts->pattern;
-	ss->isoc_interval = ss_opts->isoc_interval;
-	ss->isoc_maxpacket = ss_opts->isoc_maxpacket;
-	ss->isoc_mult = ss_opts->isoc_mult;
-	ss->isoc_maxburst = ss_opts->isoc_maxburst;
-	ss->buflen = ss_opts->bulk_buflen;
-	ss->bulk_qlen = ss_opts->bulk_qlen;
-	ss->iso_qlen = ss_opts->iso_qlen;
-
-	ss->function.name = "source/sink";
-	ss->function.bind = sourcesink_bind;
-	ss->function.set_alt = sourcesink_set_alt;
-	ss->function.get_alt = sourcesink_get_alt;
-	ss->function.disable = sourcesink_disable;
-	ss->function.setup = sourcesink_setup;
-	ss->function.strings = sourcesink_strings;
-
-	ss->function.free_func = sourcesink_free_func;
-
-	return &ss->function;
-}
-
-static inline struct f_ss_opts *to_f_ss_opts(struct config_item *item)
-{
-	return container_of(to_config_group(item), struct f_ss_opts,
-			    func_inst.group);
-}
-
-static void ss_attr_release(struct config_item *item)
-{
-	struct f_ss_opts *ss_opts = to_f_ss_opts(item);
-
-	usb_put_function_instance(&ss_opts->func_inst);
-}
-
-static struct configfs_item_operations ss_item_ops = {
-	.release		= ss_attr_release,
+static struct usb_configuration sourcesink_driver = {
+	.label		= "source/sink",
+	.strings	= sourcesink_strings,
+	.setup		= sourcesink_setup,
+	.bConfigurationValue = 3,
+	.bmAttributes	= USB_CONFIG_ATT_SELFPOWER,
+	/* .iConfiguration = DYNAMIC */
 };
 
-static ssize_t f_ss_opts_pattern_show(struct config_item *item, char *page)
-{
-	struct f_ss_opts *opts = to_f_ss_opts(item);
-	int result;
-
-	mutex_lock(&opts->lock);
-	result = sprintf(page, "%u\n", opts->pattern);
-	mutex_unlock(&opts->lock);
-
-	return result;
-}
-
-static ssize_t f_ss_opts_pattern_store(struct config_item *item,
-				       const char *page, size_t len)
-{
-	struct f_ss_opts *opts = to_f_ss_opts(item);
-	int ret;
-	u8 num;
-
-	mutex_lock(&opts->lock);
-	if (opts->refcnt) {
-		ret = -EBUSY;
-		goto end;
-	}
-
-	ret = kstrtou8(page, 0, &num);
-	if (ret)
-		goto end;
-
-	if (num != 0 && num != 1 && num != 2) {
-		ret = -EINVAL;
-		goto end;
-	}
-
-	opts->pattern = num;
-	ret = len;
-end:
-	mutex_unlock(&opts->lock);
-	return ret;
-}
-
-CONFIGFS_ATTR(f_ss_opts_, pattern);
-
-static ssize_t f_ss_opts_isoc_interval_show(struct config_item *item, char *page)
-{
-	struct f_ss_opts *opts = to_f_ss_opts(item);
-	int result;
-
-	mutex_lock(&opts->lock);
-	result = sprintf(page, "%u\n", opts->isoc_interval);
-	mutex_unlock(&opts->lock);
-
-	return result;
-}
-
-static ssize_t f_ss_opts_isoc_interval_store(struct config_item *item,
-				       const char *page, size_t len)
-{
-	struct f_ss_opts *opts = to_f_ss_opts(item);
-	int ret;
-	u8 num;
-
-	mutex_lock(&opts->lock);
-	if (opts->refcnt) {
-		ret = -EBUSY;
-		goto end;
-	}
-
-	ret = kstrtou8(page, 0, &num);
-	if (ret)
-		goto end;
-
-	if (num > 16) {
-		ret = -EINVAL;
-		goto end;
-	}
-
-	opts->isoc_interval = num;
-	ret = len;
-end:
-	mutex_unlock(&opts->lock);
-	return ret;
-}
-
-CONFIGFS_ATTR(f_ss_opts_, isoc_interval);
-
-static ssize_t f_ss_opts_isoc_maxpacket_show(struct config_item *item, char *page)
-{
-	struct f_ss_opts *opts = to_f_ss_opts(item);
-	int result;
-
-	mutex_lock(&opts->lock);
-	result = sprintf(page, "%u\n", opts->isoc_maxpacket);
-	mutex_unlock(&opts->lock);
-
-	return result;
-}
-
-static ssize_t f_ss_opts_isoc_maxpacket_store(struct config_item *item,
-				       const char *page, size_t len)
-{
-	struct f_ss_opts *opts = to_f_ss_opts(item);
-	int ret;
-	u16 num;
-
-	mutex_lock(&opts->lock);
-	if (opts->refcnt) {
-		ret = -EBUSY;
-		goto end;
-	}
-
-	ret = kstrtou16(page, 0, &num);
-	if (ret)
-		goto end;
-
-	if (num > 1024) {
-		ret = -EINVAL;
-		goto end;
-	}
-
-	opts->isoc_maxpacket = num;
-	ret = len;
-end:
-	mutex_unlock(&opts->lock);
-	return ret;
-}
-
-CONFIGFS_ATTR(f_ss_opts_, isoc_maxpacket);
-
-static ssize_t f_ss_opts_isoc_mult_show(struct config_item *item, char *page)
-{
-	struct f_ss_opts *opts = to_f_ss_opts(item);
-	int result;
-
-	mutex_lock(&opts->lock);
-	result = sprintf(page, "%u\n", opts->isoc_mult);
-	mutex_unlock(&opts->lock);
-
-	return result;
-}
-
-static ssize_t f_ss_opts_isoc_mult_store(struct config_item *item,
-				       const char *page, size_t len)
-{
-	struct f_ss_opts *opts = to_f_ss_opts(item);
-	int ret;
-	u8 num;
-
-	mutex_lock(&opts->lock);
-	if (opts->refcnt) {
-		ret = -EBUSY;
-		goto end;
-	}
-
-	ret = kstrtou8(page, 0, &num);
-	if (ret)
-		goto end;
-
-	if (num > 2) {
-		ret = -EINVAL;
-		goto end;
-	}
-
-	opts->isoc_mult = num;
-	ret = len;
-end:
-	mutex_unlock(&opts->lock);
-	return ret;
-}
-
-CONFIGFS_ATTR(f_ss_opts_, isoc_mult);
-
-static ssize_t f_ss_opts_isoc_maxburst_show(struct config_item *item, char *page)
-{
-	struct f_ss_opts *opts = to_f_ss_opts(item);
-	int result;
-
-	mutex_lock(&opts->lock);
-	result = sprintf(page, "%u\n", opts->isoc_maxburst);
-	mutex_unlock(&opts->lock);
-
-	return result;
-}
-
-static ssize_t f_ss_opts_isoc_maxburst_store(struct config_item *item,
-				       const char *page, size_t len)
-{
-	struct f_ss_opts *opts = to_f_ss_opts(item);
-	int ret;
-	u8 num;
-
-	mutex_lock(&opts->lock);
-	if (opts->refcnt) {
-		ret = -EBUSY;
-		goto end;
-	}
-
-	ret = kstrtou8(page, 0, &num);
-	if (ret)
-		goto end;
-
-	if (num > 15) {
-		ret = -EINVAL;
-		goto end;
-	}
-
-	opts->isoc_maxburst = num;
-	ret = len;
-end:
-	mutex_unlock(&opts->lock);
-	return ret;
-}
-
-CONFIGFS_ATTR(f_ss_opts_, isoc_maxburst);
-
-static ssize_t f_ss_opts_bulk_buflen_show(struct config_item *item, char *page)
-{
-	struct f_ss_opts *opts = to_f_ss_opts(item);
-	int result;
-
-	mutex_lock(&opts->lock);
-	result = sprintf(page, "%u\n", opts->bulk_buflen);
-	mutex_unlock(&opts->lock);
-
-	return result;
-}
-
-static ssize_t f_ss_opts_bulk_buflen_store(struct config_item *item,
-					   const char *page, size_t len)
-{
-	struct f_ss_opts *opts = to_f_ss_opts(item);
-	int ret;
-	u32 num;
-
-	mutex_lock(&opts->lock);
-	if (opts->refcnt) {
-		ret = -EBUSY;
-		goto end;
-	}
-
-	ret = kstrtou32(page, 0, &num);
-	if (ret)
-		goto end;
-
-	opts->bulk_buflen = num;
-	ret = len;
-end:
-	mutex_unlock(&opts->lock);
-	return ret;
-}
-
-CONFIGFS_ATTR(f_ss_opts_, bulk_buflen);
-
-static ssize_t f_ss_opts_bulk_qlen_show(struct config_item *item, char *page)
-{
-	struct f_ss_opts *opts = to_f_ss_opts(item);
-	int result;
-
-	mutex_lock(&opts->lock);
-	result = sprintf(page, "%u\n", opts->bulk_qlen);
-	mutex_unlock(&opts->lock);
-
-	return result;
-}
-
-static ssize_t f_ss_opts_bulk_qlen_store(struct config_item *item,
-					   const char *page, size_t len)
+/**
+ * sourcesink_add - add a source/sink testing configuration to a device
+ * @cdev: the device to support the configuration
+ */
+int __init sourcesink_add(struct usb_composite_dev *cdev, bool autoresume)
 {
-	struct f_ss_opts *opts = to_f_ss_opts(item);
-	int ret;
-	u32 num;
-
-	mutex_lock(&opts->lock);
-	if (opts->refcnt) {
-		ret = -EBUSY;
-		goto end;
-	}
+	int id;
 
-	ret = kstrtou32(page, 0, &num);
-	if (ret)
-		goto end;
-
-	opts->bulk_qlen = num;
-	ret = len;
-end:
-	mutex_unlock(&opts->lock);
-	return ret;
-}
-
-CONFIGFS_ATTR(f_ss_opts_, bulk_qlen);
-
-static ssize_t f_ss_opts_iso_qlen_show(struct config_item *item, char *page)
-{
-	struct f_ss_opts *opts = to_f_ss_opts(item);
-	int result;
+	/* allocate string ID(s) */
+	id = usb_string_id(cdev);
+	if (id < 0)
+		return id;
+	strings_sourcesink[0].id = id;
 
-	mutex_lock(&opts->lock);
-	result = sprintf(page, "%u\n", opts->iso_qlen);
-	mutex_unlock(&opts->lock);
+	source_sink_intf.iInterface = id;
+	sourcesink_driver.iConfiguration = id;
 
-	return result;
-}
+	/* support autoresume for remote wakeup testing */
+	if (autoresume)
+		sourcesink_driver.bmAttributes |= USB_CONFIG_ATT_WAKEUP;
 
-static ssize_t f_ss_opts_iso_qlen_store(struct config_item *item,
-					   const char *page, size_t len)
-{
-	struct f_ss_opts *opts = to_f_ss_opts(item);
-	int ret;
-	u32 num;
-
-	mutex_lock(&opts->lock);
-	if (opts->refcnt) {
-		ret = -EBUSY;
-		goto end;
+	/* support OTG systems */
+	if (gadget_is_otg(cdev->gadget)) {
+		sourcesink_driver.descriptors = otg_desc;
+		sourcesink_driver.bmAttributes |= USB_CONFIG_ATT_WAKEUP;
 	}
 
-	ret = kstrtou32(page, 0, &num);
-	if (ret)
-		goto end;
-
-	opts->iso_qlen = num;
-	ret = len;
-end:
-	mutex_unlock(&opts->lock);
-	return ret;
-}
-
-CONFIGFS_ATTR(f_ss_opts_, iso_qlen);
-
-static struct configfs_attribute *ss_attrs[] = {
-	&f_ss_opts_attr_pattern,
-	&f_ss_opts_attr_isoc_interval,
-	&f_ss_opts_attr_isoc_maxpacket,
-	&f_ss_opts_attr_isoc_mult,
-	&f_ss_opts_attr_isoc_maxburst,
-	&f_ss_opts_attr_bulk_buflen,
-	&f_ss_opts_attr_bulk_qlen,
-	&f_ss_opts_attr_iso_qlen,
-	NULL,
-};
-
-static struct config_item_type ss_func_type = {
-	.ct_item_ops    = &ss_item_ops,
-	.ct_attrs	= ss_attrs,
-	.ct_owner       = THIS_MODULE,
-};
-
-static void source_sink_free_instance(struct usb_function_instance *fi)
-{
-	struct f_ss_opts *ss_opts;
-
-	ss_opts = container_of(fi, struct f_ss_opts, func_inst);
-	kfree(ss_opts);
-}
-
-static struct usb_function_instance *source_sink_alloc_inst(void)
-{
-	struct f_ss_opts *ss_opts;
-
-	ss_opts = kzalloc(sizeof(*ss_opts), GFP_KERNEL);
-	if (!ss_opts)
-		return ERR_PTR(-ENOMEM);
-	mutex_init(&ss_opts->lock);
-	ss_opts->func_inst.free_func_inst = source_sink_free_instance;
-	ss_opts->isoc_interval = GZERO_ISOC_INTERVAL;
-	ss_opts->isoc_maxpacket = GZERO_ISOC_MAXPACKET;
-	ss_opts->bulk_buflen = GZERO_BULK_BUFLEN;
-	ss_opts->bulk_qlen = GZERO_SS_BULK_QLEN;
-	ss_opts->iso_qlen = GZERO_SS_ISO_QLEN;
-
-	config_group_init_type_name(&ss_opts->func_inst.group, "",
-				    &ss_func_type);
-
-	return &ss_opts->func_inst;
+	return usb_add_config(cdev, &sourcesink_driver, sourcesink_bind_config);
 }
-DECLARE_USB_FUNCTION(SourceSink, source_sink_alloc_inst,
-		source_sink_alloc_func);
-
-static int __init sslb_modinit(void)
-{
-	int ret;
-
-	ret = usb_function_register(&SourceSinkusb_func);
-	if (ret)
-		return ret;
-	ret = lb_modinit();
-	if (ret)
-		usb_function_unregister(&SourceSinkusb_func);
-	return ret;
-}
-static void __exit sslb_modexit(void)
-{
-	usb_function_unregister(&SourceSinkusb_func);
-	lb_modexit();
-}
-module_init(sslb_modinit);
-module_exit(sslb_modexit);
-
-MODULE_LICENSE("GPL");
--- a/drivers/usb/gadget/function/f_sourcesink_iso.c	1970-01-01 03:00:00.000000000 +0300
+++ a/drivers/usb/gadget/function/f_sourcesink_iso.c	2018-11-12 06:42:55.000000000 +0300
@@ -0,0 +1,603 @@
+/*
+ * f_sourcesink_iso.c - USB peripheral source/sink configuration driver ,for iso test
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+/* #define VERBOSE_DEBUG */
+//#define INT_TEST
+
+#include <linux/slab.h>
+#include <linux/kernel.h>
+#include <linux/device.h>
+#include <linux/module.h>
+
+#include "g_zero.h"
+#include <linux/usb/gadget_chips.h>
+#include "../u_f.h"
+
+struct f_sourcesink {
+	struct usb_function function;
+
+	struct usb_ep *in_ep;
+	struct usb_ep *out_ep;
+	struct usb_ep *int_in_ep;
+};
+
+static inline struct f_sourcesink *func_to_ss(struct usb_function *f)
+{
+	return container_of(f, struct f_sourcesink, function);
+}
+
+static unsigned pattern;
+module_param(pattern, uint, 0644);
+MODULE_PARM_DESC(pattern, "0 = all zeroes, 1 = mod63 ");
+
+/*-------------------------------------------------------------------------*/
+
+static struct usb_interface_descriptor source_sink_intf = {
+	.bLength = sizeof source_sink_intf,
+	.bDescriptorType = USB_DT_INTERFACE,
+
+	.bNumEndpoints = 3,
+	.bInterfaceClass = USB_CLASS_VENDOR_SPEC,
+	//.bAlternateSetting  = 5,
+	/* .iInterface = DYNAMIC */
+};
+
+/* full speed support: */
+
+static struct usb_endpoint_descriptor fs_source_desc = {
+	.bLength = USB_DT_ENDPOINT_SIZE,
+	.bDescriptorType = USB_DT_ENDPOINT,
+
+	.bEndpointAddress = USB_DIR_IN,
+	#ifdef INT_TEST
+	.bmAttributes = USB_ENDPOINT_XFER_INT,
+	#else
+	.bmAttributes = USB_ENDPOINT_XFER_ISOC,
+	#endif
+	//.wMaxPacketSize =     cpu_to_le16(256),
+	.bInterval = 1,
+};
+
+static struct usb_endpoint_descriptor fs_sink_desc = {
+	.bLength = USB_DT_ENDPOINT_SIZE,
+	.bDescriptorType = USB_DT_ENDPOINT,
+
+	.bEndpointAddress = USB_DIR_OUT,
+	.bmAttributes = USB_ENDPOINT_XFER_ISOC,
+	//.wMaxPacketSize =     cpu_to_le16(256),
+	.bInterval = 1,
+};
+
+static struct usb_endpoint_descriptor fs_int_source_desc = {
+	.bLength = USB_DT_ENDPOINT_SIZE,
+	.bDescriptorType = USB_DT_ENDPOINT,
+
+	.bEndpointAddress = USB_DIR_IN,
+	.bmAttributes = USB_ENDPOINT_XFER_INT,
+	.wMaxPacketSize = cpu_to_le16(32),
+	.bInterval = 4,
+};
+
+static struct usb_descriptor_header *fs_source_sink_descs[] = {
+	(struct usb_descriptor_header *)&source_sink_intf,
+	(struct usb_descriptor_header *)&fs_sink_desc,
+	(struct usb_descriptor_header *)&fs_source_desc,
+	(struct usb_descriptor_header *)&fs_int_source_desc,
+	NULL,
+};
+
+/* high speed support: */
+
+static struct usb_endpoint_descriptor hs_source_desc = {
+	.bLength = USB_DT_ENDPOINT_SIZE,
+	.bDescriptorType = USB_DT_ENDPOINT,
+	#ifdef INT_TEST
+	.bmAttributes = USB_ENDPOINT_XFER_INT,
+	#else
+	.bmAttributes = USB_ENDPOINT_XFER_ISOC,
+	#endif
+	.wMaxPacketSize = cpu_to_le16(256),
+	.bInterval = 1,
+};
+
+static struct usb_endpoint_descriptor hs_sink_desc = {
+	.bLength = USB_DT_ENDPOINT_SIZE,
+	.bDescriptorType = USB_DT_ENDPOINT,
+
+	.bmAttributes = USB_ENDPOINT_XFER_ISOC,
+	.wMaxPacketSize = cpu_to_le16(1024),
+	.bInterval = 1,
+};
+
+static struct usb_endpoint_descriptor hs_int_source_desc = {
+	.bLength = USB_DT_ENDPOINT_SIZE,
+	.bDescriptorType = USB_DT_ENDPOINT,
+
+	.bEndpointAddress = USB_DIR_IN,
+	.bmAttributes = USB_ENDPOINT_XFER_INT,
+	.wMaxPacketSize = cpu_to_le16(32),
+	.bInterval = 8,
+};
+
+static struct usb_descriptor_header *hs_source_sink_descs[] = {
+	(struct usb_descriptor_header *)&source_sink_intf,
+	(struct usb_descriptor_header *)&hs_source_desc,
+	(struct usb_descriptor_header *)&hs_sink_desc,
+	(struct usb_descriptor_header *)&fs_int_source_desc,
+	NULL,
+};
+
+/* super speed support: */
+
+static struct usb_endpoint_descriptor ss_source_desc = {
+	.bLength = USB_DT_ENDPOINT_SIZE,
+	.bDescriptorType = USB_DT_ENDPOINT,
+
+	.bmAttributes = USB_ENDPOINT_XFER_ISOC,
+	//.wMaxPacketSize =     cpu_to_le16(1024),
+	.bInterval = 4,
+};
+
+struct usb_ss_ep_comp_descriptor ss_source_comp_desc = {
+	.bLength = USB_DT_SS_EP_COMP_SIZE,
+	.bDescriptorType = USB_DT_SS_ENDPOINT_COMP,
+	.bMaxBurst = 0,
+	.bmAttributes = 0,
+	.wBytesPerInterval = 0,
+};
+
+static struct usb_endpoint_descriptor ss_sink_desc = {
+	.bLength = USB_DT_ENDPOINT_SIZE,
+	.bDescriptorType = USB_DT_ENDPOINT,
+
+	.bmAttributes = USB_ENDPOINT_XFER_ISOC,
+	//.wMaxPacketSize =     cpu_to_le16(1024),
+	.bInterval = 1,
+};
+
+struct usb_ss_ep_comp_descriptor ss_sink_comp_desc = {
+	.bLength = USB_DT_SS_EP_COMP_SIZE,
+	.bDescriptorType = USB_DT_SS_ENDPOINT_COMP,
+	.bMaxBurst = 0,
+	.bmAttributes = 0,
+	.wBytesPerInterval = 0,
+};
+
+static struct usb_descriptor_header *ss_source_sink_descs[] = {
+	(struct usb_descriptor_header *)&source_sink_intf,
+	(struct usb_descriptor_header *)&ss_source_desc,
+	(struct usb_descriptor_header *)&ss_source_comp_desc,
+	(struct usb_descriptor_header *)&ss_sink_desc,
+	(struct usb_descriptor_header *)&ss_sink_comp_desc,
+	NULL,
+};
+
+/* function-specific strings: */
+
+static struct usb_string strings_sourcesink[] = {
+	[0].s = "source and sink data",
+	{}			/* end of list */
+};
+
+static struct usb_gadget_strings stringtab_sourcesink = {
+	.language = 0x0409,	/* en-us */
+	.strings = strings_sourcesink,
+};
+
+static struct usb_gadget_strings *sourcesink_strings[] = {
+	&stringtab_sourcesink,
+	NULL,
+};
+
+/*-------------------------------------------------------------------------*/
+
+static int __init
+sourcesink_bind(struct usb_configuration *c, struct usb_function *f)
+{
+	struct usb_composite_dev *cdev = c->cdev;
+	struct f_sourcesink *ss = func_to_ss(f);
+	int id;
+
+	/* allocate interface ID(s) */
+	id = usb_interface_id(c, f);
+	if (id < 0)
+		return id;
+	source_sink_intf.bInterfaceNumber = id;	//4;
+
+	/* allocate endpoints */
+	ss->in_ep = usb_ep_autoconfig(cdev->gadget, &fs_source_desc);
+	if (!ss->in_ep) {
+autoconf_fail:
+		printk(KERN_NOTICE "%s: can't autoconfigure on %s\n",
+		      f->name, cdev->gadget->name);
+		return -ENODEV;
+	}
+	ss->in_ep->driver_data = cdev;	/* claim */
+
+	ss->out_ep = usb_ep_autoconfig(cdev->gadget, &fs_sink_desc);
+	if (!ss->out_ep)
+		goto autoconf_fail;
+	ss->out_ep->driver_data = cdev;	/* claim */
+
+	ss->int_in_ep = usb_ep_autoconfig(cdev->gadget, &fs_int_source_desc);
+	if (!ss->int_in_ep)
+		goto autoconf_fail;
+	ss->int_in_ep->driver_data = cdev;	/* claim */
+
+	/* support high speed hardware */
+	if (gadget_is_dualspeed(c->cdev->gadget)) {
+		hs_source_desc.bEndpointAddress =
+		    fs_source_desc.bEndpointAddress;
+		hs_sink_desc.bEndpointAddress = fs_sink_desc.bEndpointAddress;
+		hs_int_source_desc.bEndpointAddress =
+		    fs_int_source_desc.bEndpointAddress;
+		f->hs_descriptors = hs_source_sink_descs;
+	}
+
+	/* support super speed hardware */
+	if (gadget_is_superspeed(c->cdev->gadget)) {
+		ss_source_desc.bEndpointAddress =
+		    fs_source_desc.bEndpointAddress;
+		ss_sink_desc.bEndpointAddress = fs_sink_desc.bEndpointAddress;
+		f->ss_descriptors = ss_source_sink_descs;
+	}
+
+	printk(KERN_NOTICE "%s speed %s: IN/%s, OUT/%s\n",
+	    (gadget_is_superspeed(c->cdev->gadget) ? "super" :
+	     (gadget_is_dualspeed(c->cdev->gadget) ? "dual" : "full")),
+	    f->name, ss->in_ep->name, ss->out_ep->name);
+	return 0;
+}
+
+static void
+sourcesink_unbind(struct usb_configuration *c, struct usb_function *f)
+{
+	kfree(func_to_ss(f));
+}
+
+/* optionally require specific source/sink data patterns  */
+int check_pattern = 0;
+static int check_read_data(struct f_sourcesink *ss, struct usb_request *req)
+{
+	unsigned i;
+	u8 *buf = req->buf;
+
+	for (i = check_pattern; i < req->actual + check_pattern; i++, buf++) {
+		switch (pattern) {
+
+			/* all-zeroes has no synchronization issues */
+		case 0:
+			if (*buf == 0)
+				continue;
+			break;
+
+			/* "mod63" stays in sync with short-terminated transfers,
+			 * OR otherwise when host and gadget agree on how large
+			 * each usb transfer request should be.  Resync is done
+			 * with set_interface or set_config.  (We *WANT* it to
+			 * get quickly out of sync if controllers or their drivers
+			 * stutter for any reason, including buffer duplcation...)
+			 */
+		case 1:
+			if (*buf == (u8) (i % 63))
+				continue;
+			break;
+		}
+		printk(KERN_NOTICE "bad OUT byte, buf[%d] = %d\n", i, *buf);
+		usb_ep_set_halt(ss->out_ep);
+		check_pattern++;
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static void reinit_write_data(struct usb_ep *ep, struct usb_request *req)
+{
+	unsigned i;
+	u8 *buf = req->buf;
+
+	switch (pattern) {
+	case 0:
+		memset(req->buf, 0, req->length);
+		break;
+	case 1:
+		for (i = 0; i < req->length; i++)
+			*buf++ = (u8) (i % 63);
+		break;
+	}
+}
+
+static void source_sink_complete(struct usb_ep *ep, struct usb_request *req)
+{
+	struct f_sourcesink *ss = ep->driver_data;
+	int status = req->status;
+
+	switch (status) {
+
+	case 0:		/* normal completion? */
+		if (ep == ss->out_ep) {
+			check_read_data(ss, req);
+			memset(req->buf, 0x55, req->length);
+		} else
+			reinit_write_data(ep, req);
+		break;
+
+		/* this endpoint is normally active while we're configured */
+	case -ECONNABORTED:	/* hardware forced ep reset */
+	case -ECONNRESET:	/* request dequeued */
+	case -ESHUTDOWN:	/* disconnect from host */
+		printk(KERN_NOTICE "%s gone (%d), %d/%d\n", ep->name, status,
+		     req->actual, req->length);
+		if (ep == ss->out_ep)
+			check_read_data(ss, req);
+		free_ep_req(ep, req);
+		return;
+
+	case -EOVERFLOW:	/* buffer overrun on read means that
+				 * we didn't provide a big enough
+				 * buffer.
+				 */
+	default:
+#if 1
+		printk(KERN_NOTICE "%s complete --> %d, %d/%d\n", ep->name,
+		    status, req->actual, req->length);
+#endif
+	case -EREMOTEIO:	/* short read */
+		break;
+	}
+	printk(KERN_NOTICE "****source_sink_complete &&&&&\n");
+	status = usb_ep_queue(ep, req, GFP_ATOMIC);
+	if (status) {
+		printk(KERN_NOTICE "kill %s:  resubmit %d bytes --> %d\n",
+		      ep->name, req->length, status);
+		usb_ep_set_halt(ep);
+		/* FIXME recover later ... somehow */
+	}
+}
+
+static int source_sink_start_ep(struct f_sourcesink *ss, bool is_in)
+{
+	struct usb_ep *ep;
+	struct usb_request *req;
+	int status;
+
+	ep = is_in ? ss->in_ep : ss->out_ep;
+	req = alloc_ep_req(ep);
+	if (!req)
+		return -ENOMEM;
+
+	req->complete = source_sink_complete;
+	if (is_in)
+		reinit_write_data(ep, req);
+	else
+		memset(req->buf, 0x55, req->length);
+#if 1
+	printk(KERN_NOTICE "is_in = %d ep addr %x\n", is_in, ep->address);
+	status = usb_ep_queue(ep, req, GFP_ATOMIC);
+	if (status) {
+		struct usb_composite_dev *cdev;
+
+		cdev = ss->function.config->cdev;
+		printk(KERN_NOTICE "start %s %s --> %d\n",
+		      is_in ? "IN" : "OUT", ep->name, status);
+		free_ep_req(ep, req);
+	}
+
+	return status;
+#else
+	return 0;
+#endif
+}
+
+static void disable_source_sink(struct f_sourcesink *ss)
+{
+	struct usb_composite_dev *cdev;
+
+	cdev = ss->function.config->cdev;
+	disable_endpoints(cdev, ss->in_ep, ss->out_ep);
+	printk(KERN_NOTICE "%s disabled\n", ss->function.name);
+}
+
+static int
+enable_source_sink(struct usb_composite_dev *cdev, struct f_sourcesink *ss)
+{
+	int result = 0;
+	struct usb_ep *ep;
+
+	/* one endpoint writes (sources) zeroes IN (to the host) */
+	ep = ss->in_ep;
+	result = config_ep_by_speed(cdev->gadget, &(ss->function), ep);
+	if (result)
+		return result;
+	result = usb_ep_enable(ep);
+	if (result < 0)
+		return result;
+	ep->driver_data = ss;
+
+	result = source_sink_start_ep(ss, true);
+	if (result < 0) {
+fail:
+		ep = ss->in_ep;
+		usb_ep_disable(ep);
+		ep->driver_data = NULL;
+		return result;
+	}
+
+	/* one endpoint reads (sinks) anything OUT (from the host) */
+	ep = ss->out_ep;
+	result = config_ep_by_speed(cdev->gadget, &(ss->function), ep);
+	if (result)
+		goto fail;
+	result = usb_ep_enable(ep);
+	if (result < 0)
+		goto fail;
+	ep->driver_data = ss;
+
+	result = source_sink_start_ep(ss, false);
+	if (result < 0) {
+		usb_ep_disable(ep);
+		ep->driver_data = NULL;
+		goto fail;
+	}
+
+	printk(KERN_NOTICE "%s enabled\n", ss->function.name);
+	return result;
+}
+
+static int sourcesink_set_alt(struct usb_function *f,
+			      unsigned intf, unsigned alt)
+{
+	struct f_sourcesink *ss = func_to_ss(f);
+	struct usb_composite_dev *cdev = f->config->cdev;
+
+	/* we know alt is zero */
+	if (!ss->in_ep->driver_data)
+		disable_source_sink(ss);
+	return enable_source_sink(cdev, ss);
+}
+
+static void sourcesink_disable(struct usb_function *f)
+{
+	struct f_sourcesink *ss = func_to_ss(f);
+
+	disable_source_sink(ss);
+}
+
+/*-------------------------------------------------------------------------*/
+
+static int __init sourcesink_bind_config(struct usb_configuration *c)
+{
+	struct f_sourcesink *ss;
+	int status;
+
+	ss = kzalloc(sizeof *ss, GFP_KERNEL);
+	if (!ss)
+		return -ENOMEM;
+
+	ss->function.name = "source/sink";
+	ss->function.fs_descriptors = fs_source_sink_descs;
+	ss->function.bind = sourcesink_bind;
+	ss->function.unbind = sourcesink_unbind;
+	ss->function.set_alt = sourcesink_set_alt;
+	ss->function.disable = sourcesink_disable;
+
+	status = usb_add_function(c, &ss->function);
+	if (status)
+		kfree(ss);
+	return status;
+}
+
+static int sourcesink_setup(struct usb_configuration *c,
+			    const struct usb_ctrlrequest *ctrl)
+{
+	struct usb_request *req = c->cdev->req;
+	int value = -EOPNOTSUPP;
+	u16 w_index = le16_to_cpu(ctrl->wIndex);
+	u16 w_value = le16_to_cpu(ctrl->wValue);
+	u16 w_length = le16_to_cpu(ctrl->wLength);
+
+	req->length = USB_BUFSIZ;
+
+	/* composite driver infrastructure handles everything except
+	 * the two control test requests.
+	 */
+	switch (ctrl->bRequest) {
+
+		/*
+		 * These are the same vendor-specific requests supported by
+		 * Intel's USB 2.0 compliance test devices.  We exceed that
+		 * device spec by allowing multiple-packet requests.
+		 *
+		 * NOTE:  the Control-OUT data stays in req->buf ... better
+		 * would be copying it into a scratch buffer, so that other
+		 * requests may safely intervene.
+		 */
+	case 0x5b:		/* control WRITE test -- fill the buffer */
+		if (ctrl->bRequestType != (USB_DIR_OUT | USB_TYPE_VENDOR))
+			goto unknown;
+		if (w_value || w_index)
+			break;
+		/* just read that many bytes into the buffer */
+		if (w_length > req->length)
+			break;
+		value = w_length;
+		break;
+	case 0x5c:		/* control READ test -- return the buffer */
+		if (ctrl->bRequestType != (USB_DIR_IN | USB_TYPE_VENDOR))
+			goto unknown;
+		if (w_value || w_index)
+			break;
+		/* expect those bytes are still in the buffer; send back */
+		if (w_length > req->length)
+			break;
+		value = w_length;
+		break;
+
+	default:
+unknown:
+		printk(KERN_NOTICE "unknown control req%02x.%02x v%04x i%04x l%d\n",
+		     ctrl->bRequestType, ctrl->bRequest,
+		     w_value, w_index, w_length);
+	}
+
+	/* respond with data transfer or status phase? */
+	if (value >= 0) {
+		printk(KERN_NOTICE "source/sink req%02x.%02x v%04x i%04x l%d\n",
+		     ctrl->bRequestType, ctrl->bRequest,
+		     w_value, w_index, w_length);
+		req->zero = 0;
+		req->length = value;
+		value = usb_ep_queue(c->cdev->gadget->ep0, req, GFP_ATOMIC);
+		if (value < 0)
+			ERROR(c->cdev, "source/sinkc response, err %d\n",
+			      value);
+	}
+
+	/* device either stalls (value < 0) or reports success */
+	return value;
+}
+
+static struct usb_configuration sourcesink_driver = {
+	.label = "source/sink",
+	.strings = sourcesink_strings,
+	.setup = sourcesink_setup,
+	.bConfigurationValue = 1,
+	.bmAttributes = USB_CONFIG_ATT_SELFPOWER,
+	/* .iConfiguration = DYNAMIC */
+};
+
+/**
+ * sourcesink_add - add a source/sink testing configuration to a device
+ * @cdev: the device to support the configuration
+ */
+int __init sourcesink_add(struct usb_composite_dev *cdev, bool autoresume)
+{
+	int id;
+
+	/* allocate string ID(s) */
+	id = usb_string_id(cdev);
+	if (id < 0)
+		return id;
+	strings_sourcesink[0].id = id;
+
+	source_sink_intf.iInterface = id;
+	sourcesink_driver.iConfiguration = id;
+
+	/* support autoresume for remote wakeup testing */
+	if (autoresume)
+		sourcesink_driver.bmAttributes |= USB_CONFIG_ATT_WAKEUP;
+
+	/* support OTG systems */
+	if (gadget_is_otg(cdev->gadget)) {
+		sourcesink_driver.descriptors = otg_desc;
+		sourcesink_driver.bmAttributes |= USB_CONFIG_ATT_WAKEUP;
+	}
+
+	return usb_add_config(cdev, &sourcesink_driver, sourcesink_bind_config);
+}
--- a/drivers/usb/gadget/function/g_zero.h	2018-11-23 10:16:15.965818686 +0300
+++ a/drivers/usb/gadget/function/g_zero.h	2018-11-23 10:31:03.792051348 +0300
@@ -6,6 +6,10 @@
 #ifndef __G_ZERO_H
 #define __G_ZERO_H
 
+#include <linux/usb/composite.h>
+
+#define USB_BUFSIZ	1024
+
 #define GZERO_BULK_BUFLEN	4096
 #define GZERO_QLEN		32
 #define GZERO_ISOC_INTERVAL	4
@@ -13,6 +17,25 @@
 #define GZERO_SS_BULK_QLEN	1
 #define GZERO_SS_ISO_QLEN	8
 
+extern uint buflen;
+
+#ifdef CONFIG_USB_OTG
+static struct usb_otg_descriptor otg_descriptor = {
+	.bLength = sizeof otg_descriptor,
+	.bDescriptorType = USB_DT_OTG,
+
+	/* REVISIT SRP-only hardware is possible, although
+	 * it would not be called "OTG" ...
+	 */
+	.bmAttributes = USB_OTG_SRP | USB_OTG_HNP,
+};
+
+static const struct usb_descriptor_header *otg_desc[] = {
+	(struct usb_descriptor_header *)&otg_descriptor,
+	NULL,
+};
+#endif
+
 struct usb_zero_options {
 	unsigned pattern;
 	unsigned isoc_interval;
@@ -65,8 +88,14 @@
 int lb_modinit(void);
 
 /* common utilities */
+
+
 void disable_endpoints(struct usb_composite_dev *cdev,
-		struct usb_ep *in, struct usb_ep *out,
-		struct usb_ep *iso_in, struct usb_ep *iso_out);
+		       struct usb_ep *in, struct usb_ep *out);
+
+struct usb_request *alloc_ep_req(struct usb_ep *ep);
+
+/* Frees a usb_request previously allocated by alloc_ep_req() */
+void free_ep_req(struct usb_ep *ep, struct usb_request *req);
 
 #endif /* __G_ZERO_H */
--- a/drivers/usb/gadget/Kconfig	2018-11-23 10:16:15.962818864 +0300
+++ a/drivers/usb/gadget/Kconfig	2018-11-23 10:31:03.796051110 +0300
@@ -13,6 +13,8 @@
 # both kinds of controller can also support "USB On-the-Go" (CONFIG_USB_OTG).
 #
 
+if USB_GADGET_ENABLED
+
 menuconfig USB_GADGET
 	tristate "USB Gadget Support"
 	select USB_COMMON
@@ -45,6 +47,24 @@
 
 if USB_GADGET
 
+config GADGET_USB0
+	bool
+	default y if USB_GADGET_PORT0_ENABLED
+
+# Selected by UDC drivers that support high-speed operation.
+config USB_GADGET_DUALSPEED
+	bool
+
+# Deal with ean function transfer data will be lose a packet after set_interface
+config USB_DEVICE_LOSE_PACKET_AFTER_SET_INTERFACE_WORKAROUND
+	bool "Enable Workaround USB Device Lose Packet After Set Interface"
+	depends on USB
+
+# Deal with ep11 auto switch buffer invaild
+config USB_DEVICE_EP11_NOT_AUTO_SWITCH_WORKAROUND
+	bool "Enable Workaround USB Device EP11 Not Auto Switch Ping Pong Buffer"
+	depends on USB
+
 config USB_GADGET_DEBUG
 	bool "Debugging messages (DEVELOPMENT)"
 	depends on DEBUG_KERNEL
@@ -488,3 +508,5 @@
 endchoice
 
 endif # USB_GADGET
+
+endif # USB_GADGET_ENABLED
--- a/drivers/usb/gadget/legacy/Makefile	2018-11-23 10:16:15.967818567 +0300
+++ a/drivers/usb/gadget/legacy/Makefile	2018-11-23 10:31:03.796051110 +0300
@@ -7,38 +7,38 @@
 ccflags-y			+= -I$(srctree)/drivers/usb/gadget/function/
 
 g_zero-y			:= zero.o
-g_audio-y			:= audio.o
-g_ether-y			:= ether.o
-g_serial-y			:= serial.o
-g_midi-y			:= gmidi.o
-gadgetfs-y			:= inode.o
-g_mass_storage-y		:= mass_storage.o
-g_printer-y			:= printer.o
-g_cdc-y				:= cdc2.o
-g_multi-y			:= multi.o
-g_hid-y				:= hid.o
-g_dbgp-y			:= dbgp.o
-g_nokia-y			:= nokia.o
-g_webcam-y			:= webcam.o
-g_ncm-y				:= ncm.o
-g_acm_ms-y			:= acm_ms.o
-g_tcm_usb_gadget-y		:= tcm_usb_gadget.o
+#g_audio-y			:= audio.o
+#g_ether-y			:= ether.o
+#g_serial-y			:= serial.o
+#g_midi-y			:= gmidi.o
+#gadgetfs-y			:= inode.o
+#g_mass_storage-y		:= mass_storage.o
+#g_printer-y			:= printer.o
+#g_cdc-y				:= cdc2.o
+#g_multi-y			:= multi.o
+#g_hid-y				:= hid.o
+#g_dbgp-y			:= dbgp.o
+#g_nokia-y			:= nokia.o
+#g_webcam-y			:= webcam.o
+#g_ncm-y				:= ncm.o
+#g_acm_ms-y			:= acm_ms.o
+#g_tcm_usb_gadget-y		:= tcm_usb_gadget.o
 
 obj-$(CONFIG_USB_ZERO)		+= g_zero.o
-obj-$(CONFIG_USB_AUDIO)		+= g_audio.o
-obj-$(CONFIG_USB_ETH)		+= g_ether.o
-obj-$(CONFIG_USB_GADGETFS)	+= gadgetfs.o
-obj-$(CONFIG_USB_FUNCTIONFS)	+= g_ffs.o
-obj-$(CONFIG_USB_MASS_STORAGE)	+= g_mass_storage.o
-obj-$(CONFIG_USB_G_SERIAL)	+= g_serial.o
-obj-$(CONFIG_USB_G_PRINTER)	+= g_printer.o
-obj-$(CONFIG_USB_MIDI_GADGET)	+= g_midi.o
-obj-$(CONFIG_USB_CDC_COMPOSITE) += g_cdc.o
-obj-$(CONFIG_USB_G_HID)		+= g_hid.o
-obj-$(CONFIG_USB_G_DBGP)	+= g_dbgp.o
-obj-$(CONFIG_USB_G_MULTI)	+= g_multi.o
-obj-$(CONFIG_USB_G_NOKIA)	+= g_nokia.o
-obj-$(CONFIG_USB_G_WEBCAM)	+= g_webcam.o
-obj-$(CONFIG_USB_G_NCM)		+= g_ncm.o
-obj-$(CONFIG_USB_G_ACM_MS)	+= g_acm_ms.o
-obj-$(CONFIG_USB_GADGET_TARGET)	+= tcm_usb_gadget.o
+#obj-$(CONFIG_USB_AUDIO)		+= g_audio.o
+#obj-$(CONFIG_USB_ETH)		+= g_ether.o
+#obj-$(CONFIG_USB_GADGETFS)	+= gadgetfs.o
+#obj-$(CONFIG_USB_FUNCTIONFS)	+= g_ffs.o
+#obj-$(CONFIG_USB_MASS_STORAGE)	+= g_mass_storage.o
+#obj-$(CONFIG_USB_G_SERIAL)	+= g_serial.o
+#obj-$(CONFIG_USB_G_PRINTER)	+= g_printer.o
+#obj-$(CONFIG_USB_MIDI_GADGET)	+= g_midi.o
+#obj-$(CONFIG_USB_CDC_COMPOSITE) += g_cdc.o
+#obj-$(CONFIG_USB_G_HID)		+= g_hid.o
+#obj-$(CONFIG_USB_G_DBGP)	+= g_dbgp.o
+#obj-$(CONFIG_USB_G_MULTI)	+= g_multi.o
+#obj-$(CONFIG_USB_G_NOKIA)	+= g_nokia.o
+#obj-$(CONFIG_USB_G_WEBCAM)	+= g_webcam.o
+#obj-$(CONFIG_USB_G_NCM)		+= g_ncm.o
+#obj-$(CONFIG_USB_G_ACM_MS)	+= g_acm_ms.o
+#obj-$(CONFIG_USB_GADGET_TARGET)	+= tcm_usb_gadget.o
--- a/drivers/usb/gadget/legacy/zero.c	2018-11-23 10:16:15.968818508 +0300
+++ a/drivers/usb/gadget/legacy/zero.c	2018-11-23 10:31:03.797051051 +0300
@@ -28,7 +28,7 @@
  *
  * Why is *this* driver using two configurations, rather than setting up
  * two interfaces with different functions?  To help verify that multiple
- * configuration infrastructure is working correctly; also, so that it can
+ * configuration infrastucture is working correctly; also, so that it can
  * work with low capability USB controllers without four bulk endpoints.
  */
 
@@ -41,19 +41,42 @@
 
 #include <linux/kernel.h>
 #include <linux/slab.h>
+#include <linux/utsname.h>
 #include <linux/device.h>
-#include <linux/module.h>
-#include <linux/err.h>
-#include <linux/usb/composite.h>
+
 
 #include "g_zero.h"
+#include <linux/usb/gadget_chips.h>
+
+/*-------------------------------------------------------------------------*/
+
+/*
+ * Kbuild is not very cooperative with respect to linking separately
+ * compiled library objects into one module.  So for now we won't use
+ * separate compilation ... ensuring init/exit sections work to shrink
+ * the runtime footprint, and giving us at least some parts of what
+ * a "gcc --combine ... part1.c part2.c part3.c ... " build would.
+ */
+#include <linux/usb/composite.h>
+#include "../usbstring.c"
+#include "../config.c"
+#include "../epautoconf.c"
+
+#include "../function/f_sourcesink.c"
+//#include "../function/f_sourcesink_iso.c"
+#include "../function/f_loopback.c"
+
 /*-------------------------------------------------------------------------*/
-USB_GADGET_COMPOSITE_OPTIONS();
 
 #define DRIVER_VERSION		"Cinco de Mayo 2008"
 
 static const char longname[] = "Gadget Zero";
 
+uint buflen = 4096;
+module_param(buflen, uint, 0644);
+EXPORT_SYMBOL_GPL (buflen);
+
+
 /*
  * Normally the "loopback" configuration is second (index 1) so
  * it's not the default.  Here's where to change that order, to
@@ -61,16 +84,7 @@
  * controllers (like original superh) that only support one config.
  */
 static bool loopdefault = 0;
-module_param(loopdefault, bool, S_IRUGO|S_IWUSR);
-
-static struct usb_zero_options gzero_options = {
-	.isoc_interval = GZERO_ISOC_INTERVAL,
-	.isoc_maxpacket = GZERO_ISOC_MAXPACKET,
-	.bulk_buflen = GZERO_BULK_BUFLEN,
-	.qlen = GZERO_QLEN,
-	.ss_bulk_qlen = GZERO_SS_BULK_QLEN,
-	.ss_iso_qlen = GZERO_SS_ISO_QLEN,
-};
+module_param(loopdefault, bool, S_IRUGO | S_IWUSR);
 
 /*-------------------------------------------------------------------------*/
 
@@ -80,11 +94,11 @@
  * Instead:  allocate your own, using normal USB-IF procedures.
  */
 #ifndef	CONFIG_USB_ZERO_HNPTEST
-#define DRIVER_VENDOR_NUM	0x0525		/* NetChip */
-#define DRIVER_PRODUCT_NUM	0xa4a0		/* Linux-USB "Gadget Zero" */
+#define DRIVER_VENDOR_NUM	0x0525	/* NetChip */
+#define DRIVER_PRODUCT_NUM	0xa4a0	/* Linux-USB "Gadget Zero" */
 #define DEFAULT_AUTORESUME	0
 #else
-#define DRIVER_VENDOR_NUM	0x1a0a		/* OTG test device IDs */
+#define DRIVER_VENDOR_NUM	0x1a0a	/* OTG test device IDs */
 #define DRIVER_PRODUCT_NUM	0xbadd
 #define DEFAULT_AUTORESUME	5
 #endif
@@ -93,57 +107,45 @@
  * functional coverage for the "USBCV" test harness from USB-IF.
  * It's always set if OTG mode is enabled.
  */
-static unsigned autoresume = DEFAULT_AUTORESUME;
+unsigned autoresume = DEFAULT_AUTORESUME;
 module_param(autoresume, uint, S_IRUGO);
 MODULE_PARM_DESC(autoresume, "zero, or seconds before remote wakeup");
 
-/* Maximum Autoresume time */
-static unsigned max_autoresume;
-module_param(max_autoresume, uint, S_IRUGO);
-MODULE_PARM_DESC(max_autoresume, "maximum seconds before remote wakeup");
-
-/* Interval between two remote wakeups */
-static unsigned autoresume_interval_ms;
-module_param(autoresume_interval_ms, uint, S_IRUGO);
-MODULE_PARM_DESC(autoresume_interval_ms,
-		"milliseconds to increase successive wakeup delays");
-
-static unsigned autoresume_step_ms;
 /*-------------------------------------------------------------------------*/
 
 static struct usb_device_descriptor device_desc = {
-	.bLength =		sizeof device_desc,
-	.bDescriptorType =	USB_DT_DEVICE,
+	.bLength = sizeof device_desc,
+	.bDescriptorType = USB_DT_DEVICE,
 
-	/* .bcdUSB = DYNAMIC */
-	.bDeviceClass =		USB_CLASS_VENDOR_SPEC,
+	.bcdUSB = cpu_to_le16(0x0200),
+	.bDeviceClass = USB_CLASS_VENDOR_SPEC,
 
-	.idVendor =		cpu_to_le16(DRIVER_VENDOR_NUM),
-	.idProduct =		cpu_to_le16(DRIVER_PRODUCT_NUM),
-	.bNumConfigurations =	2,
+	.idVendor = cpu_to_le16(DRIVER_VENDOR_NUM),
+	.idProduct = cpu_to_le16(DRIVER_PRODUCT_NUM),
+	.bNumConfigurations = 2,
 };
 
-static const struct usb_descriptor_header *otg_desc[2];
-
 /* string IDs are assigned dynamically */
+
+#define STRING_MANUFACTURER_IDX		0
+#define STRING_PRODUCT_IDX		1
+#define STRING_SERIAL_IDX		2
+
+static char manufacturer[50];
+
 /* default serial number takes at least two packets */
 static char serial[] = "0123456789.0123456789.0123456789";
 
-#define USB_GZERO_SS_DESC	(USB_GADGET_FIRST_AVAIL_IDX + 0)
-#define USB_GZERO_LB_DESC	(USB_GADGET_FIRST_AVAIL_IDX + 1)
-
 static struct usb_string strings_dev[] = {
-	[USB_GADGET_MANUFACTURER_IDX].s = "",
-	[USB_GADGET_PRODUCT_IDX].s = longname,
-	[USB_GADGET_SERIAL_IDX].s = serial,
-	[USB_GZERO_SS_DESC].s	= "source and sink data",
-	[USB_GZERO_LB_DESC].s	= "loop input to output",
-	{  }			/* end of list */
+	[STRING_MANUFACTURER_IDX].s = manufacturer,
+	[STRING_PRODUCT_IDX].s = longname,
+	[STRING_SERIAL_IDX].s = serial,
+	{}			/* end of list */
 };
 
 static struct usb_gadget_strings stringtab_dev = {
-	.language	= 0x0409,	/* en-us */
-	.strings	= strings_dev,
+	.language = 0x0409,	/* en-us */
+	.strings = strings_dev,
 };
 
 static struct usb_gadget_strings *dev_strings[] = {
@@ -152,13 +154,57 @@
 };
 
 /*-------------------------------------------------------------------------*/
+struct usb_request *alloc_ep_req(struct usb_ep *ep)
+{
+	struct usb_request *req;
 
-static struct timer_list	autoresume_timer;
+	req = usb_ep_alloc_request(ep, GFP_ATOMIC);
+	if (req) {
+		req->length = buflen;
+		req->buf = kmalloc(buflen, GFP_ATOMIC);
+		if (!req->buf) {
+			usb_ep_free_request(ep, req);
+			req = NULL;
+		}
+	}
+	return req;
+}
+
+void free_ep_req(struct usb_ep *ep, struct usb_request *req)
+{
+	kfree(req->buf);
+	usb_ep_free_request(ep, req);
+}
+
+static void disable_ep(struct usb_composite_dev *cdev, struct usb_ep *ep)
+{
+	int value;
+
+	if (ep->driver_data) {
+		value = usb_ep_disable(ep);
+		if (value < 0)
+			printk(KERN_NOTICE "disable %s --> %d\n", ep->name, value);
+		ep->driver_data = NULL;
+	}
+}
+
+void disable_endpoints(struct usb_composite_dev *cdev,
+		       struct usb_ep *in, struct usb_ep *out)
+{
+	disable_ep(cdev, in);
+	disable_ep(cdev, out);
+}
+
+
+
+/*-------------------------------------------------------------------------*/
+
+static struct timer_list autoresume_timer;
 
 static void zero_autoresume(unsigned long _c)
 {
-	struct usb_composite_dev	*cdev = (void *)_c;
-	struct usb_gadget		*g = cdev->gadget;
+	struct usb_composite_dev *cdev = (void *)_c;
+	struct usb_gadget *g = cdev->gadget;
 
 	/* unconfigured devices can't issue wakeups */
 	if (!cdev->config)
@@ -170,7 +216,7 @@
 	 */
 	if (g->speed != USB_SPEED_UNKNOWN) {
 		int status = usb_gadget_wakeup(g);
-		INFO(cdev, "%s --> %d\n", __func__, status);
+		printk(KERN_NOTICE "%s --> %d\n", __func__, status);
 	}
 }
 
@@ -180,251 +226,115 @@
 		return;
 
 	if (autoresume) {
-		if (max_autoresume &&
-			(autoresume_step_ms > max_autoresume * 1000))
-				autoresume_step_ms = autoresume * 1000;
-
-		mod_timer(&autoresume_timer, jiffies +
-			msecs_to_jiffies(autoresume_step_ms));
-		DBG(cdev, "suspend, wakeup in %d milliseconds\n",
-			autoresume_step_ms);
-
-		autoresume_step_ms += autoresume_interval_ms;
+		mod_timer(&autoresume_timer, jiffies + (HZ * autoresume));
+		printk(KERN_NOTICE "suspend, wakeup in %d seconds\n", autoresume);
 	} else
-		DBG(cdev, "%s\n", __func__);
+		printk(KERN_NOTICE "%s\n", __func__);
 }
 
 static void zero_resume(struct usb_composite_dev *cdev)
 {
-	DBG(cdev, "%s\n", __func__);
+	printk(KERN_NOTICE "%s\n", __func__);
 	del_timer(&autoresume_timer);
 }
 
 /*-------------------------------------------------------------------------*/
 
-static struct usb_configuration loopback_driver = {
-	.label          = "loopback",
-	.bConfigurationValue = 2,
-	.bmAttributes   = USB_CONFIG_ATT_SELFPOWER,
-	/* .iConfiguration = DYNAMIC */
-};
-
-static struct usb_function *func_ss;
-static struct usb_function_instance *func_inst_ss;
-
-static int ss_config_setup(struct usb_configuration *c,
-		const struct usb_ctrlrequest *ctrl)
+static int __init zero_bind(struct usb_composite_dev *cdev)
 {
-	switch (ctrl->bRequest) {
-	case 0x5b:
-	case 0x5c:
-		return func_ss->setup(func_ss, ctrl);
-	default:
-		return -EOPNOTSUPP;
-	}
-}
-
-static struct usb_configuration sourcesink_driver = {
-	.label                  = "source/sink",
-	.setup                  = ss_config_setup,
-	.bConfigurationValue    = 3,
-	.bmAttributes           = USB_CONFIG_ATT_SELFPOWER,
-	/* .iConfiguration      = DYNAMIC */
-};
-
-module_param_named(buflen, gzero_options.bulk_buflen, uint, 0);
-module_param_named(pattern, gzero_options.pattern, uint, S_IRUGO|S_IWUSR);
-MODULE_PARM_DESC(pattern, "0 = all zeroes, 1 = mod63, 2 = none");
-
-module_param_named(isoc_interval, gzero_options.isoc_interval, uint,
-		S_IRUGO|S_IWUSR);
-MODULE_PARM_DESC(isoc_interval, "1 - 16");
-
-module_param_named(isoc_maxpacket, gzero_options.isoc_maxpacket, uint,
-		S_IRUGO|S_IWUSR);
-MODULE_PARM_DESC(isoc_maxpacket, "0 - 1023 (fs), 0 - 1024 (hs/ss)");
-
-module_param_named(isoc_mult, gzero_options.isoc_mult, uint, S_IRUGO|S_IWUSR);
-MODULE_PARM_DESC(isoc_mult, "0 - 2 (hs/ss only)");
-
-module_param_named(isoc_maxburst, gzero_options.isoc_maxburst, uint,
-		S_IRUGO|S_IWUSR);
-MODULE_PARM_DESC(isoc_maxburst, "0 - 15 (ss only)");
-
-static struct usb_function *func_lb;
-static struct usb_function_instance *func_inst_lb;
-
-module_param_named(qlen, gzero_options.qlen, uint, S_IRUGO|S_IWUSR);
-MODULE_PARM_DESC(qlen, "depth of loopback queue");
-
-module_param_named(ss_bulk_qlen, gzero_options.ss_bulk_qlen, uint,
-		S_IRUGO|S_IWUSR);
-MODULE_PARM_DESC(bulk_qlen, "depth of sourcesink queue for bulk transfer");
-
-module_param_named(ss_iso_qlen, gzero_options.ss_iso_qlen, uint,
-		S_IRUGO|S_IWUSR);
-MODULE_PARM_DESC(iso_qlen, "depth of sourcesink queue for iso transfer");
-
-static int zero_bind(struct usb_composite_dev *cdev)
-{
-	struct f_ss_opts	*ss_opts;
-	struct f_lb_opts	*lb_opts;
-	int			status;
+	int gcnum;
+	struct usb_gadget *gadget = cdev->gadget;
+	int id;
 
 	/* Allocate string descriptor numbers ... note that string
 	 * contents can be overridden by the composite_dev glue.
 	 */
-	status = usb_string_ids_tab(cdev, strings_dev);
-	if (status < 0)
-		return status;
-
-	device_desc.iManufacturer = strings_dev[USB_GADGET_MANUFACTURER_IDX].id;
-	device_desc.iProduct = strings_dev[USB_GADGET_PRODUCT_IDX].id;
-	device_desc.iSerialNumber = strings_dev[USB_GADGET_SERIAL_IDX].id;
-
-	setup_timer(&autoresume_timer, zero_autoresume, (unsigned long) cdev);
-
-	func_inst_ss = usb_get_function_instance("SourceSink");
-	if (IS_ERR(func_inst_ss))
-		return PTR_ERR(func_inst_ss);
-
-	ss_opts =  container_of(func_inst_ss, struct f_ss_opts, func_inst);
-	ss_opts->pattern = gzero_options.pattern;
-	ss_opts->isoc_interval = gzero_options.isoc_interval;
-	ss_opts->isoc_maxpacket = gzero_options.isoc_maxpacket;
-	ss_opts->isoc_mult = gzero_options.isoc_mult;
-	ss_opts->isoc_maxburst = gzero_options.isoc_maxburst;
-	ss_opts->bulk_buflen = gzero_options.bulk_buflen;
-	ss_opts->bulk_qlen = gzero_options.ss_bulk_qlen;
-	ss_opts->iso_qlen = gzero_options.ss_iso_qlen;
-
-	func_ss = usb_get_function(func_inst_ss);
-	if (IS_ERR(func_ss)) {
-		status = PTR_ERR(func_ss);
-		goto err_put_func_inst_ss;
-	}
+	id = usb_string_id(cdev);
+	if (id < 0)
+		return id;
+	strings_dev[STRING_MANUFACTURER_IDX].id = id;
+	device_desc.iManufacturer = id;
+
+	id = usb_string_id(cdev);
+	if (id < 0)
+		return id;
+	strings_dev[STRING_PRODUCT_IDX].id = id;
+	device_desc.iProduct = id;
+
+	id = usb_string_id(cdev);
+	if (id < 0)
+		return id;
+	strings_dev[STRING_SERIAL_IDX].id = id;
+	device_desc.iSerialNumber = id;
 
-	func_inst_lb = usb_get_function_instance("Loopback");
-	if (IS_ERR(func_inst_lb)) {
-		status = PTR_ERR(func_inst_lb);
-		goto err_put_func_ss;
-	}
-
-	lb_opts = container_of(func_inst_lb, struct f_lb_opts, func_inst);
-	lb_opts->bulk_buflen = gzero_options.bulk_buflen;
-	lb_opts->qlen = gzero_options.qlen;
-
-	func_lb = usb_get_function(func_inst_lb);
-	if (IS_ERR(func_lb)) {
-		status = PTR_ERR(func_lb);
-		goto err_put_func_inst_lb;
-	}
-
-	sourcesink_driver.iConfiguration = strings_dev[USB_GZERO_SS_DESC].id;
-	loopback_driver.iConfiguration = strings_dev[USB_GZERO_LB_DESC].id;
-
-	/* support autoresume for remote wakeup testing */
-	sourcesink_driver.bmAttributes &= ~USB_CONFIG_ATT_WAKEUP;
-	loopback_driver.bmAttributes &= ~USB_CONFIG_ATT_WAKEUP;
-	sourcesink_driver.descriptors = NULL;
-	loopback_driver.descriptors = NULL;
-	if (autoresume) {
-		sourcesink_driver.bmAttributes |= USB_CONFIG_ATT_WAKEUP;
-		loopback_driver.bmAttributes |= USB_CONFIG_ATT_WAKEUP;
-		autoresume_step_ms = autoresume * 1000;
-	}
-
-	/* support OTG systems */
-	if (gadget_is_otg(cdev->gadget)) {
-		if (!otg_desc[0]) {
-			struct usb_descriptor_header *usb_desc;
-
-			usb_desc = usb_otg_descriptor_alloc(cdev->gadget);
-			if (!usb_desc) {
-				status = -ENOMEM;
-				goto err_conf_flb;
-			}
-			usb_otg_descriptor_init(cdev->gadget, usb_desc);
-			otg_desc[0] = usb_desc;
-			otg_desc[1] = NULL;
-		}
-		sourcesink_driver.descriptors = otg_desc;
-		sourcesink_driver.bmAttributes |= USB_CONFIG_ATT_WAKEUP;
-		loopback_driver.descriptors = otg_desc;
-		loopback_driver.bmAttributes |= USB_CONFIG_ATT_WAKEUP;
-	}
+	setup_timer(&autoresume_timer, zero_autoresume, (unsigned long)cdev);
 
 	/* Register primary, then secondary configuration.  Note that
 	 * SH3 only allows one config...
 	 */
 	if (loopdefault) {
-		usb_add_config_only(cdev, &loopback_driver);
-		usb_add_config_only(cdev, &sourcesink_driver);
+		loopback_add(cdev, autoresume != 0);
+		sourcesink_add(cdev, autoresume != 0);
 	} else {
-		usb_add_config_only(cdev, &sourcesink_driver);
-		usb_add_config_only(cdev, &loopback_driver);
+		sourcesink_add(cdev, autoresume != 0);
+		loopback_add(cdev, autoresume != 0);
 	}
-	status = usb_add_function(&sourcesink_driver, func_ss);
-	if (status)
-		goto err_free_otg_desc;
-
-	usb_ep_autoconfig_reset(cdev->gadget);
-	status = usb_add_function(&loopback_driver, func_lb);
-	if (status)
-		goto err_free_otg_desc;
 
-	usb_ep_autoconfig_reset(cdev->gadget);
-	usb_composite_overwrite_options(cdev, &coverwrite);
+	gcnum = usb_gadget_controller_number(gadget);
+	if (gcnum >= 0)
+		device_desc.bcdDevice = cpu_to_le16(0x0200 + gcnum);
+	else {
+		/* gadget zero is so simple (for now, no altsettings) that
+		 * it SHOULD NOT have problems with bulk-capable hardware.
+		 * so just warn about unrcognized controllers -- don't panic.
+		 *
+		 * things like configuration and altsetting numbering
+		 * can need hardware-specific attention though.
+		 */
+		printk(KERN_NOTICE "%s: controller '%s' not recognized\n",
+			   longname, gadget->name);
+		device_desc.bcdDevice = cpu_to_le16(0x9999);
+	}
 
-	INFO(cdev, "%s, version: " DRIVER_VERSION "\n", longname);
+	printk(KERN_NOTICE "%s, version: " DRIVER_VERSION "\n", longname);
 
-	return 0;
+	snprintf(manufacturer, sizeof manufacturer, "%s %s with %s",
+		 init_utsname()->sysname, init_utsname()->release,
+		 gadget->name);
 
-err_free_otg_desc:
-	kfree(otg_desc[0]);
-	otg_desc[0] = NULL;
-err_conf_flb:
-	usb_put_function(func_lb);
-	func_lb = NULL;
-err_put_func_inst_lb:
-	usb_put_function_instance(func_inst_lb);
-	func_inst_lb = NULL;
-err_put_func_ss:
-	usb_put_function(func_ss);
-	func_ss = NULL;
-err_put_func_inst_ss:
-	usb_put_function_instance(func_inst_ss);
-	func_inst_ss = NULL;
-	return status;
+	return 0;
 }
 
 static int zero_unbind(struct usb_composite_dev *cdev)
 {
 	del_timer_sync(&autoresume_timer);
-	if (!IS_ERR_OR_NULL(func_ss))
-		usb_put_function(func_ss);
-	usb_put_function_instance(func_inst_ss);
-	if (!IS_ERR_OR_NULL(func_lb))
-		usb_put_function(func_lb);
-	usb_put_function_instance(func_inst_lb);
-	kfree(otg_desc[0]);
-	otg_desc[0] = NULL;
-
 	return 0;
 }
 
 static struct usb_composite_driver zero_driver = {
-	.name		= "zero",
-	.dev		= &device_desc,
-	.strings	= dev_strings,
-	.max_speed	= USB_SPEED_SUPER,
-	.bind		= zero_bind,
-	.unbind		= zero_unbind,
-	.suspend	= zero_suspend,
-	.resume		= zero_resume,
+	.name = "zero",
+	.dev = &device_desc,
+	.strings = dev_strings,
+	.max_speed = USB_SPEED_SUPER,
+	.bind   = zero_bind,
+	.unbind = zero_unbind,
+	.suspend = zero_suspend,
+	.resume = zero_resume,
 };
 
-module_usb_composite_driver(zero_driver);
-
 MODULE_AUTHOR("David Brownell");
 MODULE_LICENSE("GPL");
+
+static int __init init(void)
+{
+	return usb_composite_probe(&zero_driver);
+}
+
+module_init(init);
+
+static void __exit cleanup(void)
+{
+	usb_composite_unregister(&zero_driver);
+}
+
+module_exit(cleanup);
--- a/drivers/usb/gadget/Makefile	2018-11-23 10:16:15.962818864 +0300
+++ a/drivers/usb/gadget/Makefile	2018-11-23 10:31:03.788051586 +0300
@@ -6,7 +6,7 @@
 ccflags-y				+= -I$(srctree)/drivers/usb/gadget/udc
 
 obj-$(CONFIG_USB_LIBCOMPOSITE)	+= libcomposite.o
-libcomposite-y			:= usbstring.o config.o epautoconf.o
+#libcomposite-y			:= usbstring.o config.o epautoconf.o
 libcomposite-y			+= composite.o functions.o configfs.o u_f.o
 
-obj-$(CONFIG_USB_GADGET)	+= udc/ function/ legacy/
+obj-$(CONFIG_USB_GADGET)	+= udc/ legacy/
--- a/drivers/usb/gadget/udc/core.c	2018-11-23 10:16:15.970818389 +0300
+++ a/drivers/usb/gadget/udc/core.c	2018-11-23 10:31:03.790051467 +0300
@@ -101,21 +101,7 @@
  */
 int usb_ep_enable(struct usb_ep *ep)
 {
-	int ret = 0;
-
-	if (ep->enabled)
-		goto out;
-
-	ret = ep->ops->enable(ep, ep->desc);
-	if (ret)
-		goto out;
-
-	ep->enabled = true;
-
-out:
-	trace_usb_ep_enable(ep, ret);
-
-	return ret;
+	return ep->ops->enable(ep, ep->desc);
 }
 EXPORT_SYMBOL_GPL(usb_ep_enable);
 
@@ -133,23 +119,7 @@
  */
 int usb_ep_disable(struct usb_ep *ep)
 {
-	int ret = 0;
-
-	if (!ep->enabled)
-		goto out;
-
-	ret = ep->ops->disable(ep);
-	if (ret) {
-		ret = ret;
-		goto out;
-	}
-
-	ep->enabled = false;
-
-out:
-	trace_usb_ep_disable(ep, ret);
-
-	return ret;
+	return ep->ops->disable(ep);
 }
 EXPORT_SYMBOL_GPL(usb_ep_disable);
 
@@ -257,19 +227,7 @@
 int usb_ep_queue(struct usb_ep *ep,
 			       struct usb_request *req, gfp_t gfp_flags)
 {
-	int ret = 0;
-
-	if (WARN_ON_ONCE(!ep->enabled && ep->address)) {
-		ret = -ESHUTDOWN;
-		goto out;
-	}
-
-	ret = ep->ops->queue(ep, req, gfp_flags);
-
-out:
-	trace_usb_ep_queue(ep, req, ret);
-
-	return ret;
+	return ep->ops->queue(ep, req, gfp_flags);
 }
 EXPORT_SYMBOL_GPL(usb_ep_queue);
 
@@ -290,12 +248,7 @@
  */
 int usb_ep_dequeue(struct usb_ep *ep, struct usb_request *req)
 {
-	int ret;
-
-	ret = ep->ops->dequeue(ep, req);
-	trace_usb_ep_dequeue(ep, req, ret);
-
-	return ret;
+	return ep->ops->dequeue(ep, req);
 }
 EXPORT_SYMBOL_GPL(usb_ep_dequeue);
 
@@ -970,8 +923,10 @@
 void usb_gadget_set_state(struct usb_gadget *gadget,
 		enum usb_device_state state)
 {
+#if 0
 	gadget->state = state;
 	schedule_work(&gadget->work);
+#endif
 }
 EXPORT_SYMBOL_GPL(usb_gadget_set_state);
 
@@ -1054,7 +1009,7 @@
  */
 static inline void usb_gadget_udc_stop(struct usb_udc *udc)
 {
-	udc->gadget->ops->udc_stop(udc->gadget);
+	udc->gadget->ops->udc_stop(udc->driver);
 }
 
 /**
@@ -1221,7 +1176,47 @@
  */
 int usb_add_gadget_udc(struct device *parent, struct usb_gadget *gadget)
 {
+#ifdef CONFIG_USB_GADGET_SUNPLUS
+	struct usb_udc		*udc;
+	int			ret = -ENOMEM;
+
+	udc = kzalloc(sizeof(*udc), GFP_KERNEL);
+	if (!udc)
+		goto err1;
+
+	device_initialize(&udc->dev);
+	udc->dev.release = usb_udc_release;
+	udc->dev.class = udc_class;
+	udc->dev.groups = usb_udc_attr_groups;
+	udc->dev.parent = parent;
+	ret = dev_set_name(&udc->dev, "%s", kobject_name(&parent->kobj));
+	if (ret)
+		goto err2;
+
+	udc->gadget = gadget;
+
+	mutex_lock(&udc_lock);
+	list_add_tail(&udc->list, &udc_list);
+
+	ret = device_add(&udc->dev);
+	if (ret)
+		goto err3;
+
+	mutex_unlock(&udc_lock);
+
+	return 0;
+err3:
+	list_del(&udc->list);
+	mutex_unlock(&udc_lock);
+
+err2:
+	put_device(&udc->dev);
+
+err1:
+	return ret;
+#else
 	return usb_add_gadget_udc_release(parent, gadget, NULL);
+#endif
 }
 EXPORT_SYMBOL_GPL(usb_add_gadget_udc);
 
@@ -1288,17 +1283,19 @@
 
 	udc->driver = driver;
 	udc->dev.driver = &driver->driver;
+#if 0
 	udc->gadget->dev.driver = &driver->driver;
 
 	ret = driver->bind(udc->gadget, driver);
 	if (ret)
 		goto err1;
+#endif
 	ret = usb_gadget_udc_start(udc);
 	if (ret) {
 		driver->unbind(udc->gadget);
 		goto err1;
 	}
-	usb_udc_connect_control(udc);
+	/*usb_udc_connect_control(udc);*/
 
 	kobject_uevent(&udc->dev.kobj, KOBJ_CHANGE);
 	return 0;
--- a/drivers/usb/gadget/udc/Kconfig	2018-11-23 10:16:15.968818508 +0300
+++ a/drivers/usb/gadget/udc/Kconfig	2018-11-23 10:31:03.788051586 +0300
@@ -29,6 +29,11 @@
 # Integrated controllers
 #
 
+config USB_GADGET_SUNPLUS
+	tristate "Sunplus Gemini USB Device Controller"
+	select USB_GADGET_DUALSPEED
+	default n
+
 config USB_AT91
 	tristate "Atmel AT91 USB Device Port"
 	depends on ARCH_AT91
--- a/drivers/usb/gadget/udc/Makefile	2018-11-23 10:16:15.968818508 +0300
+++ a/drivers/usb/gadget/udc/Makefile	2018-11-23 10:31:03.789051526 +0300
@@ -7,34 +7,35 @@
 # USB peripheral controller drivers
 #
 obj-$(CONFIG_USB_GADGET)	+= udc-core.o
-obj-$(CONFIG_USB_DUMMY_HCD)	+= dummy_hcd.o
-obj-$(CONFIG_USB_NET2272)	+= net2272.o
-obj-$(CONFIG_USB_NET2280)	+= net2280.o
-obj-$(CONFIG_USB_SNP_CORE)	+= amd5536udc.o
-obj-$(CONFIG_USB_AMD5536UDC)	+= amd5536udc_pci.o
-obj-$(CONFIG_USB_PXA25X)	+= pxa25x_udc.o
-obj-$(CONFIG_USB_PXA27X)	+= pxa27x_udc.o
-obj-$(CONFIG_USB_GOKU)		+= goku_udc.o
-obj-$(CONFIG_USB_OMAP)		+= omap_udc.o
-obj-$(CONFIG_USB_S3C2410)	+= s3c2410_udc.o
-obj-$(CONFIG_USB_AT91)		+= at91_udc.o
-obj-$(CONFIG_USB_ATMEL_USBA)	+= atmel_usba_udc.o
-obj-$(CONFIG_USB_BCM63XX_UDC)	+= bcm63xx_udc.o
-obj-$(CONFIG_USB_FSL_USB2)	+= fsl_usb2_udc.o
-fsl_usb2_udc-y			:= fsl_udc_core.o
-fsl_usb2_udc-$(CONFIG_ARCH_MXC)	+= fsl_mxc_udc.o
-obj-$(CONFIG_USB_M66592)	+= m66592-udc.o
-obj-$(CONFIG_USB_R8A66597)	+= r8a66597-udc.o
-obj-$(CONFIG_USB_RENESAS_USB3)	+= renesas_usb3.o
-obj-$(CONFIG_USB_FSL_QE)	+= fsl_qe_udc.o
-obj-$(CONFIG_USB_S3C_HSUDC)	+= s3c-hsudc.o
-obj-$(CONFIG_USB_LPC32XX)	+= lpc32xx_udc.o
-obj-$(CONFIG_USB_EG20T)		+= pch_udc.o
-obj-$(CONFIG_USB_MV_UDC)	+= mv_udc.o
-mv_udc-y			:= mv_udc_core.o
-obj-$(CONFIG_USB_FUSB300)	+= fusb300_udc.o
-obj-$(CONFIG_USB_FOTG210_UDC)	+= fotg210-udc.o
-obj-$(CONFIG_USB_MV_U3D)	+= mv_u3d_core.o
-obj-$(CONFIG_USB_GR_UDC)	+= gr_udc.o
-obj-$(CONFIG_USB_GADGET_XILINX)	+= udc-xilinx.o
-obj-$(CONFIG_USB_BDC_UDC)	+= bdc/
+obj-$(CONFIG_USB_GADGET_SUNPLUS)	+= sunplus_udc.o
+#obj-$(CONFIG_USB_DUMMY_HCD)	+= dummy_hcd.o
+#obj-$(CONFIG_USB_NET2272)	+= net2272.o
+#obj-$(CONFIG_USB_NET2280)	+= net2280.o
+#obj-$(CONFIG_USB_SNP_CORE)	+= amd5536udc.o
+#obj-$(CONFIG_USB_AMD5536UDC)	+= amd5536udc_pci.o
+#obj-$(CONFIG_USB_PXA25X)	+= pxa25x_udc.o
+#obj-$(CONFIG_USB_PXA27X)	+= pxa27x_udc.o
+#obj-$(CONFIG_USB_GOKU)		+= goku_udc.o
+#obj-$(CONFIG_USB_OMAP)		+= omap_udc.o
+#obj-$(CONFIG_USB_S3C2410)	+= s3c2410_udc.o
+#obj-$(CONFIG_USB_AT91)		+= at91_udc.o
+#obj-$(CONFIG_USB_ATMEL_USBA)	+= atmel_usba_udc.o
+#obj-$(CONFIG_USB_BCM63XX_UDC)	+= bcm63xx_udc.o
+#obj-$(CONFIG_USB_FSL_USB2)	+= fsl_usb2_udc.o
+#fsl_usb2_udc-y			:= fsl_udc_core.o
+#fsl_usb2_udc-$(CONFIG_ARCH_MXC)	+= fsl_mxc_udc.o
+#obj-$(CONFIG_USB_M66592)	+= m66592-udc.o
+#obj-$(CONFIG_USB_R8A66597)	+= r8a66597-udc.o
+#obj-$(CONFIG_USB_RENESAS_USB3)	+= renesas_usb3.o
+#obj-$(CONFIG_USB_FSL_QE)	+= fsl_qe_udc.o
+#obj-$(CONFIG_USB_S3C_HSUDC)	+= s3c-hsudc.o
+#obj-$(CONFIG_USB_LPC32XX)	+= lpc32xx_udc.o
+#obj-$(CONFIG_USB_EG20T)		+= pch_udc.o
+#obj-$(CONFIG_USB_MV_UDC)	+= mv_udc.o
+#mv_udc-y			:= mv_udc_core.o
+#obj-$(CONFIG_USB_FUSB300)	+= fusb300_udc.o
+#obj-$(CONFIG_USB_FOTG210_UDC)	+= fotg210-udc.o
+#obj-$(CONFIG_USB_MV_U3D)	+= mv_u3d_core.o
+#obj-$(CONFIG_USB_GR_UDC)	+= gr_udc.o
+#obj-$(CONFIG_USB_GADGET_XILINX)	+= udc-xilinx.o
+#obj-$(CONFIG_USB_BDC_UDC)	+= bdc/
--- a/drivers/usb/gadget/udc/sunplus_udc.c	1970-01-01 03:00:00.000000000 +0300
+++ a/drivers/usb/gadget/udc/sunplus_udc.c	2018-11-12 06:42:55.000000000 +0300
@@ -0,0 +1,4796 @@
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/dma-mapping.h>
+#include <linux/platform_device.h>
+#include <linux/ioport.h>
+#include <linux/pm.h>
+#include <linux/device.h>
+#include <asm/io.h>
+#include <linux/slab.h>
+#include <linux/semaphore.h>
+#include <asm/delay.h>
+#include <linux/delay.h>
+#include <linux/kthread.h>
+#include <linux/interrupt.h>
+#include <linux/usb/gadget.h>
+#include <mach/io_map.h>
+#include <linux/usb/composite.h>
+#include <linux/usb/otg.h>
+#include <linux/usb/sp_usb.h>
+#include <asm/cacheflush.h>
+#include "../../../../arch/arm/mm/dma.h"
+
+
+#ifdef CONFIG_FIQ_GLUE
+#include <asm/fiq.h>
+#include <asm/fiq_glue.h>
+#include <asm/pgtable.h>
+#include <asm/hardware/gic.h>
+#include <linux/kthread.h>
+#include <linux/freezer.h>
+#include <linux/delay.h>
+#endif
+
+#ifdef ISP_DEBUG
+char *g_hw;
+#include <linux/vmalloc.h>
+
+#include "usb_device.c"
+#endif
+
+#include <linux/vmalloc.h>
+
+#define EP1_DMA
+
+#define ISO_DEBUG_INFO
+#ifdef CONFIG_GADGET_USB0
+#define USB0
+#endif
+//#define INT_TEST
+
+#ifdef CONFIG_USB_ZERO
+#define USBTEST_ZERO
+#endif
+#define MANUAL_EP11
+#define  SW_IRQ
+static u32 is_ncm = 0;
+#ifndef CONFIG_USB_ZERO
+struct tasklet_struct *t_task;
+EXPORT_SYMBOL(t_task);
+#endif
+char sof_n = 0;
+
+static u8 bus_reset_finish_flag = false;
+bool ncm_initialize_finish_flag = false;
+EXPORT_SYMBOL_GPL(ncm_initialize_finish_flag);
+
+void usb_switch(int device);
+
+#include "sunplus_udc.h"
+#include "sunplus_udc_regs.h"
+/*#define ISP_DEBUG*/
+#define VUBUS_CD_POLL	HZ/4
+struct timer_list vbus_polling_timer;
+struct timer_list sof_polling_timer;
+char is_config = 0;
+static u32 sof_value = 0x1000;
+static int irq_num = 45;
+static u32 temp_sof_value;
+static u8 platform_device_handle_flag = false;
+static u8 first_enter_polling_timer_flag = false;
+
+#define IRQ_USB_DEV_PORT0				45
+#define IRQ_USB_DEV_PORT1				48
+#define TO_HOST 						0
+#define TO_DEVICE						1
+#define BUS_RESET_FOR_CHIRP_DELAY		2000	/*ctrl rx singal keep the strongest time */
+#define DMA_FLUSH_TIMEOUT_DELAY			300000
+#define IC_VERSION_A     				0x630
+#define ZERO_TEST_TAG					0x484d434e
+#define ISP_DEBUG_SIZE					(0x8800 * 512)
+
+#define FULL_SPEED_DMA_SIZE				64
+#define HIGH_SPEED_DMA_SIZE				512
+#define UDC_FLASH_BUFFER_SIZE 			(1024*64)
+#define EPC_FIFO_SIZE 					(32)
+#define	DMA_ADDR_INVALID				(~(dma_addr_t)0)
+static u32 bulkep_dma_block_size = 0;
+u32 *trb_c;
+u32 *trb_c_start;
+u32 *trb_c_end;			/*reserve 2 trb:one for remain buf less than ep_fifo_size ;next for link trb */
+u32 *trb_event;
+static char g_flag_ep5;
+u32 ep5_use = 0;
+u32 ep5_e = 0;
+static u32 tog = 1;
+u32 *trb_c_12;
+u32 *trb_c_start_12;
+u32 *trb_c_end_12;
+u32 *trb_event_12;
+static char g_flag_ep12;
+u32 ep12_use = 0;
+u32 ep12_e = 0;
+static u32 tog_12 = 1;
+struct sp_ep_iso {
+	struct list_head queue;
+	int act;
+};
+struct sp_ep_iso ep_iso_5;
+struct sp_ep_iso ep_iso_12;
+char dma_flag = 0;
+char dma_flag_b = 0;
+static u32 dmsg = 0x2;
+u32 nth_len;
+u32 dma_len_ep1;
+u32 dma_len;
+
+struct usb_cdc_ncm_nth16 {
+	__le32 dwSignature;
+	__le16 wHeaderLength;
+	__le16 wSequence;
+	__le16 wBlockLength;
+	__le16 wNdpIndex;
+} __attribute__ ((packed));
+
+module_param(dmsg, uint, 0644);
+static u32 intface_d = 0x0;
+module_param(intface_d, uint, 0644);
+u32 dma_fail = 0x0;
+module_param(dma_fail, uint, 0644);
+static unsigned long time_ns = 0x0;
+module_param(time_ns, ulong, 0644);
+static u32 d_time0 = VUBUS_CD_POLL * 2;
+module_param(d_time0, uint, 0644);
+static u32 d_time1 = 10;
+module_param(d_time1, uint, 0644);
+u32 is_vera = 0x0;
+/*coverity[declared_but_not_referenced]*/
+module_param(is_vera, uint, 0644);
+u32 is_ean = 0;
+/*coverity[declared_but_not_referenced]*/
+module_param(is_ean, uint, 0644);
+EXPORT_SYMBOL_GPL(is_vera);
+EXPORT_SYMBOL_GPL(is_ean);
+EXPORT_SYMBOL_GPL(dma_fail);
+
+
+static const char gadget_name[] = "sp_udc";
+static struct semaphore ep1_ack_sem, ep1_dma_sem;
+static struct semaphore ep12_bulk_out_ack_sem, ep12_bulk_out_nak_sem;
+static struct semaphore ep9_ack_sem;
+static struct semaphore ep11_ack_sem, ep11_dma_sem;
+static struct semaphore ep11_sw_sem;
+
+static void __iomem *base_addr;
+
+static struct sp_udc *the_controller;
+#define DEBUG_DBG(fmt, arg...)		do { if (dmsg&(1<<0)) printk(KERN_DEBUG fmt,##arg); } while (0)
+#define DEBUG_NOTICE(fmt, arg...)	do { if (dmsg&(1<<1)) printk(KERN_NOTICE fmt,##arg); } while (0)
+#define DEBUG_INFO(fmt, arg...)		do { if (dmsg&(1<<2)) printk(KERN_INFO fmt,##arg); } while (0)
+#define DEBUG_ERR(fmt, arg...)		do { printk(KERN_ERR fmt,##arg); } while (0)
+static u32 full_spd = 0;
+static struct sp_udc memory;
+int in_p_num;
+static inline u32 udc_read(u32 reg);
+static inline void udc_write(u32 value, u32 reg);
+void detech_start(void);
+
+
+static void reset_global_value(void)
+{
+	dma_len = 0;
+	dma_flag_b = 0;
+}
+
+static void udc_clean_dcache_range(unsigned int start,unsigned int start_pa,unsigned int size){
+	unsigned long oldIrq;
+	void* vaddr = (void *)start;
+
+	local_irq_save(oldIrq);
+	/* flush L1 cache by range */
+	dmac_flush_range(vaddr,vaddr+size);
+	/* flush L2 cache by range */
+	outer_flush_range(start_pa, start_pa+size);
+	local_irq_restore(oldIrq);
+ }
+
+static void udc_invalidate_dcache_range(unsigned int start,unsigned int start_pa,unsigned int size){
+	unsigned long oldIrq;
+
+	local_irq_save(oldIrq);
+	/* invalidate L1 cache by range */
+	dmac_unmap_area((void *)start,size,2);
+	/* invalidate L2 cache by range */
+	outer_inv_range(start_pa, start_pa+size);
+	local_irq_restore(oldIrq);
+}
+
+static ssize_t show_udc_ctrl(struct device *dev,
+			      struct device_attribute *attr, char *buffer)
+{
+	u32 result = 0;
+
+	struct sp_ep *ep = &memory.ep[1];
+	spin_lock(&ep->lock);
+	result = list_empty(&ep->queue);
+	spin_unlock(&ep->lock);
+
+	DEBUG_NOTICE("ep1 is empty:%d req %d\n", result, in_p_num);
+	DEBUG_NOTICE("dma_len = %d %d\n", dma_len, full_spd);
+	return snprintf(buffer, 3, "%d\n", result);
+}
+
+static ssize_t store_udc_ctrl(struct device *dev,
+			       struct device_attribute *attr,
+			       const char *buffer, size_t count)
+{
+	u32 ret = 0;
+	static char irq_i = 0;
+
+	ret = udc_read(UDLCSET) & SIM_MODE;
+	if (*buffer == 's') {	/*s:switch uphy to divice*/
+		DEBUG_NOTICE("user switch \n");
+		usb_switch(TO_DEVICE);
+		msleep(1);
+		detech_start();
+		return count;
+	} else if (*buffer == '1') { /* support SET_DESC COMMND */
+		ret |= SUPP_SETDESC;
+	} else if (*buffer == 'i') { /*interrupt disable or enable*/
+		if (!irq_i) {
+			disable_irq(irq_num);
+			irq_i = 1;
+		} else {
+			enable_irq(irq_num);
+			irq_i = 0;
+		}
+	} else if (*buffer == 'n') { /*ping pong buffer not auto switch*/
+		is_ncm = 1;
+		udc_write(udc_read(UDEPBPPC) | SOFT_DISC, UDEPBPPC);
+	} else if (*buffer == 'o') { /*ping pong buffer auto switch*/
+		is_ncm = 0;
+		udc_write(udc_read(UDNBIE) | EP11O_IF, UDNBIE);
+		udc_write(udc_read(UDEPBPPC) & 0XFE, UDEPBPPC);
+	} else {
+		ret &= ~SUPP_SETDESC;
+	}
+
+	DEBUG_NOTICE("full_spd = %d %d \n", full_spd, (*buffer - 48));
+	udc_write(ret, UDLCSET);
+	return count;
+}
+
+static DEVICE_ATTR(udc_ctrl, S_IWUSR | S_IRUSR, show_udc_ctrl, store_udc_ctrl);
+
+
+void PrintBlock_usb(u8 *pBuffStar, u32 uiBuffLen)
+{
+	u32 uiIter;
+	pBuffStar = pBuffStar;
+	DEBUG_NOTICE("pBuffStar=%p\n", pBuffStar);
+	DEBUG_NOTICE(" %02x", pBuffStar[0]);
+	for (uiIter = 1; uiIter < uiBuffLen; uiIter++) {
+		if (uiIter % 16 == 0)
+			DEBUG_NOTICE("\n");
+		if (uiIter % 512 == 0)
+			DEBUG_NOTICE("\n");
+		DEBUG_NOTICE(" %02x", pBuffStar[uiIter]);
+	}
+	DEBUG_NOTICE("\n");
+}
+
+static inline struct sp_ep *to_sp_ep(struct usb_ep *ep)
+{
+	return container_of(ep, struct sp_ep, ep);
+}
+
+static inline struct sp_udc *to_sp_udc(struct usb_gadget *gadget)
+{
+	return container_of(gadget, struct sp_udc, gadget);
+}
+
+static inline struct sp_request *to_sp_req(struct usb_request *req)
+{
+	return container_of(req, struct sp_request, req);
+}
+
+static inline u32 udc_read(u32 reg)
+{
+	return readl(base_addr + reg);
+}
+
+static inline void udc_write(u32 value, u32 reg)
+{
+	writel(value, base_addr + reg);
+}
+
+void sp_sem_init(void)
+{
+	sema_init(&ep1_ack_sem, 1);
+	sema_init(&ep1_dma_sem, 1);
+	sema_init(&ep12_bulk_out_ack_sem, 1);
+	sema_init(&ep12_bulk_out_nak_sem, 1);
+	sema_init(&ep9_ack_sem, 1);
+	sema_init(&ep11_ack_sem, 1);
+	sema_init(&ep11_dma_sem, 1);
+	sema_init(&ep11_sw_sem, 1);
+}
+
+void init_ep_spin(void)
+{
+	int i;
+	for (i = 0; i < SP_MAXENDPOINTS; i++) {
+		spin_lock_init(&memory.ep[i].lock);
+	}
+}
+
+static void sp_del_list(struct list_head *mylist, spinlock_t * mylock)
+{
+	spin_lock(mylock);
+	list_del_init(mylist);
+	spin_unlock(mylock);
+}
+
+static void sp_list_add(struct list_head *mylist, struct list_head *head,
+			spinlock_t * mylock)
+{
+	spin_lock(mylock);
+	list_add_tail(mylist, head);
+	spin_unlock(mylock);
+}
+
+static int sp_udc_list_empty(struct list_head *head, spinlock_t * lock)
+{
+	int ret;
+	spin_lock(lock);
+	ret = list_empty(head);
+	spin_unlock(lock);
+	return ret;
+}
+
+static inline int sp_udc_get_ep_fifo_count(int is_pingbuf, u32 ping_c)
+{
+	int tmp = 0;
+
+	if (is_pingbuf) {
+		tmp = udc_read(ping_c);
+	} else {
+		tmp = udc_read(ping_c + 0x4);
+	}
+
+	return (tmp & 0x3ff);
+}
+
+static void ep_iso_debug_dcache(u32 *event,u8 ep_num)
+{
+	u32 trb_use;
+	u32 i = 0;
+
+	struct iso_trb *trb = (struct iso_trb *)event;
+
+	if(ep_num == EP5)
+		trb_use = ep5_use;
+	else
+		trb_use = 32;
+	udc_invalidate_dcache_range((u32)event,
+				   __pa(event),
+				   TRB_NUM * 16);
+	DEBUG_DBG("event\n");
+	for (i = 0; i < trb_use; i++) {
+		if (i % 12 == 0)
+			DEBUG_NOTICE("\n");
+		DEBUG_NOTICE("%x %x,", trb[i].size_cc,
+			     trb[i].cmd);
+	}
+	DEBUG_DBG(" event end\n");
+}
+
+static void ep_iso_done(struct sp_ep *ep, struct sp_request *req,
+			int status)
+{
+#if 0
+	req->req.status = status;
+	sp_del_list(&req->queue, &ep->lock);
+	if (ep->num == EP5)
+		sp_list_add(&req->queue, &ep_iso_5.queue, &ep->lock);
+	else
+		sp_list_add(&req->queue, &ep_iso_12.queue, &ep->lock);
+#endif
+	unsigned halted = ep->halted;
+
+	if (ep->num == EP1 && sp_udc_list_empty(&req->queue, &ep->lock)) {
+		DEBUG_ERR("1double done ep%d\n", ep->num);
+		return;
+	}
+	sp_del_list(&req->queue, &ep->lock);
+	if (likely(req->req.status == -EINPROGRESS))
+		req->req.status = status;
+	else
+		status = req->req.status;
+
+	ep->halted = 1;
+	if (ep->num == EP1)
+		in_p_num++;
+	/*DEBUG_DBG("done ep%d act=%d\n", ep->num, req->req.actual);*/
+	req->req.complete(&ep->ep, &req->req);
+	ep->halted = halted;
+}
+
+static void sp_udc_done(struct sp_ep *ep, struct sp_request *req,
+			    int status)
+{
+	unsigned halted = ep->halted;
+
+	if (ep->num == EP1 && sp_udc_list_empty(&req->queue, &ep->lock)) {
+		DEBUG_ERR("1double done ep%d\n", ep->num);
+		return;
+	}
+	sp_del_list(&req->queue, &ep->lock);
+	if (likely(req->req.status == -EINPROGRESS))
+		req->req.status = status;
+	else
+		status = req->req.status;
+
+	ep->halted = 1;
+	if (ep->num == EP1)
+		in_p_num++;
+	/*DEBUG_DBG("done ep%d act=%d\n", ep->num, req->req.actual);*/
+	req->req.complete(&ep->ep, &req->req);
+	ep->halted = halted;
+}
+
+static void sp_udc_nuke(struct sp_udc *udc, struct sp_ep *ep,
+			    int status)
+{
+	/* Sanity check */
+	DEBUG_DBG(">>> sp_udc_nuke...\n");
+	if (ep->num == EP5 || ep->num == EP12) {
+#ifndef INT_TEST
+		while (!list_empty(&ep_iso_5.queue)) {
+			struct sp_request *req;
+			req = list_entry(ep_iso_5.queue.next, struct sp_request, queue);
+			list_del_init(&req->queue);
+			req->req.status = status;
+			req->req.complete(&ep->ep, &req->req);
+		}
+#endif
+		while (!list_empty(&ep_iso_12.queue)) {
+			struct sp_request *req;
+			req = list_entry(ep_iso_12.queue.next, struct sp_request, queue);
+			list_del_init(&req->queue);
+			req->req.status = status;
+			req->req.complete(&ep->ep, &req->req);
+		}
+	}
+	if (&ep->queue == NULL)
+		return;
+
+	while (!list_empty(&ep->queue)) {
+		struct sp_request *req;
+		req = list_entry(ep->queue.next, struct sp_request, queue);
+		sp_udc_done(ep, req, status);
+	}
+	DEBUG_DBG("<<< sp_udc_nuke...\n");
+}
+
+static void sp_reinit_iap(struct sp_ep *ep, struct sp_request *req,
+			      int status)
+{
+	unsigned halted = ep->halted;
+	req->req.status = status;
+	ep->halted = 1;
+	req->req.complete(&ep->ep, &req->req);
+	ep->halted = halted;
+}
+
+static int sp_udc_set_halt(struct usb_ep *_ep, int value)
+{
+	struct sp_ep *ep = to_sp_ep(_ep);
+	u32 idx;
+	u32 v = 0;
+
+	if (unlikely(!_ep || (!ep->desc && ep->ep.name != ep0name))) {
+		DEBUG_ERR("%s: inval 2\n", __func__);
+		return -EINVAL;
+	}
+
+	DEBUG_DBG(">>>> sp_udc_set_halt\n");
+
+	idx = ep->bEndpointAddress & 0x7F;
+	DEBUG_NOTICE("udc set halt idx=%x val=%x \n", idx, value);
+
+	switch (idx) {
+	case EP1:
+		v = SETEP1STL;
+		break;
+	case EP2:
+		v = SETEP2STL;
+		break;
+	case EP3:
+		v = SETEP3STL;
+		break;
+	case EP4:
+		break;
+	case EP5:
+		break;
+	case EP6:
+		break;
+	case EP7:
+		break;
+	case EP8:
+		v = SETEP8STL;
+		break;
+	case EP9:
+		v = SETEP9STL;
+		break;
+	case EP10:
+		break;
+	case EP11:
+		v = SETEPBSTL;
+		break;
+	default:
+		return -EINVAL;
+	}
+	if ((!value) && v)
+		v = v << 16;
+	DEBUG_ERR("udc set halt v=%x  \n", v);
+	udc_write((udc_read(UDLCSTL) | v), UDLCSTL);
+	ep->halted = value ? 1 : 0;
+	return 0;
+}
+
+static int sp_udc_ep_enable(struct usb_ep *_ep,
+				const struct usb_endpoint_descriptor *desc)
+{
+	struct sp_udc *dev;
+	struct sp_ep *ep;
+	u32 max;
+	u32 tmp;
+	u32 udll_int_en;
+	u32 int_en_reg2;
+
+	ep = to_sp_ep(_ep);
+
+	if (!_ep || !desc || _ep->name == ep0name || desc->bDescriptorType != USB_DT_ENDPOINT){
+		DEBUG_ERR("%s.%d,,%p,%p,%p,%s,%d\n",__FUNCTION__,__LINE__,
+			_ep,desc,ep->desc,_ep->name,desc->bDescriptorType);
+		return -EINVAL;
+	}
+
+	dev = ep->dev;
+	if (!dev->driver || dev->gadget.speed == USB_SPEED_UNKNOWN)
+		return -ESHUTDOWN;
+
+	max = le16_to_cpu(desc->wMaxPacketSize) & 0x1fff;
+
+	_ep->maxpacket = max & 0x7ff;
+	ep->desc = desc;
+	ep->halted = 0;
+	ep->bEndpointAddress = desc->bEndpointAddress;
+
+	udll_int_en = udc_read(UDLIE);
+	int_en_reg2 = udc_read(UDNBIE);
+
+	switch (ep->num) {
+	case EP0:
+		/* enable irqs */
+		udll_int_en |= EP0S_IF;
+		break;
+	case EP1:
+		udll_int_en |= EP1I_IF | EP1N_IF;
+		udc_write(EP_DIR | EP_ENA | RESET_PIPO_FIFO, UDEP12C);
+		break;
+	case EP2:
+		udll_int_en |= EP2N_IF | EP2O_IF;
+		udc_write(EP_ENA /*|RESET_PIPO_FIFO */ , UDEP12C);
+		/*debug for switch buff
+		udc_write(0 ,UDEP2PPC);*/
+		break;
+	case EP3:
+		udll_int_en |= EP3I_IF;
+		/*udc_write((1<<0), UDEP3CTRL);*/
+		break;
+	case EP4:
+		break;
+	case EP5:
+		udll_int_en |= EP5I_IF;
+		udc_write(udc_read(UDCIE) | VIDEO_TRB_IF | VIDEO_ERF_IF, UDCIE);
+		udc_write((1 << 0), UDEP5CTRL);
+		 /*ENABLE*/ trb_c = kzalloc(ALL_TRB_SIZE, GFP_ATOMIC);	/*cmd ring */
+		trb_c_start = trb_c;
+		trb_c_end = trb_c + ((TRB_NUM - 2) * TRB_SIZE) / sizeof(u32);
+		trb_event = kzalloc(ALL_TRB_SIZE, GFP_ATOMIC);	/*event ring */
+		memset(trb_event, 0, TRB_NUM * TRB_SIZE);
+		DEBUG_DBG("01 CRCR=%x s %p end %p\n", udc_read(UDVDMA_CRCR),
+			  trb_c_start, trb_c_end);
+		trb_c = (u32 *) (((u32) (trb_c)) & (~0x3f));
+		DEBUG_DBG("01 CRCR=%x trb_c addr %lu\n", udc_read(UDVDMA_CRCR),
+			  (unsigned long)__pa(trb_c));
+		tog = 1;
+		ep_iso_5.act = 0;
+		INIT_LIST_HEAD(&ep_iso_5.queue);
+		break;
+	case EP6:
+		break;
+	case EP7:
+		udll_int_en |= EP7I_IF;
+		udc_write((1 << 0), UDEP7CTRL);
+		 /*ENABLE*/ break;
+	case EP8:
+		int_en_reg2 |= EP8N_IF | EP8I_IF;
+		udc_write(EP_DIR | EP_ENA | RESET_PIPO_FIFO, UDEP89C);
+		break;
+	case EP9:
+		int_en_reg2 |= EP9N_IF | EP9O_IF;
+		udc_write(EP_ENA /*|RESET_PIPO_FIFO */ , UDEP89C);
+		udc_write(0, UDEP9PPC);
+		break;
+	case EP10:
+		int_en_reg2 |= EP10N_IF | EP10I_IF;
+		udc_write(EP_DIR | EP_ENA | RESET_PIPO_FIFO, UDEPABC);
+		break;
+	case EP11:
+		int_en_reg2 |= EP11N_IF | EP11O_IF;
+		udc_write(EP_ENA | RESET_PIPO_FIFO, UDEPABC);
+#ifdef MANUAL_EP11
+		if (!is_ncm && !is_vera)
+			udc_write(0, UDEPBPPC);
+#endif
+		break;
+	case EP12:
+		udc_write(udc_read(UDCIE) | EPC_TRB_IF | EPC_ERF_IF, UDCIE);
+		udll_int_en |= EPC_FAIL_IF | EPC_OFLOW_IF | EPC_SUCC_IF | EPC_DERR_IF;
+		udc_write(EPC_FAIL_IF | EPC_OFLOW_IF | EPC_SUCC_IF | EPC_DERR_IF, UDLIF);
+		udc_write(0x11, UDEPCS);
+		udc_write((1 << 0), UDEPCCTRL);
+		 /*ENABLE*/ trb_c_12 = kzalloc(ALL_TRB_SIZE, GFP_ATOMIC);	/*cmd ring */
+		trb_c_start_12 = trb_c_12;
+		trb_c_end_12 = trb_c_12 + ((TRB_NUM - 2) * TRB_SIZE) / sizeof(u32);
+		trb_event_12 = kzalloc(ALL_TRB_SIZE, GFP_ATOMIC);	/*event ring */
+		DEBUG_DBG("EPc CRCR=%x s %p end %p\n", udc_read(UDEPCDMA_CRCR),
+			  trb_c_start_12, trb_c_end_12);
+		trb_c_12 = (u32 *) (((u32) (trb_c_12)) & (~0x3f));
+		tog_12 = 1;
+		ep_iso_12.act = 0;
+		INIT_LIST_HEAD(&ep_iso_12.queue);
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	udc_write(udll_int_en, UDLIE);
+	udc_write(int_en_reg2, UDNBIE);
+	DEBUG_DBG("ep_enable UDLIE=%x\n", udc_read(UDLIE));
+	/* print some debug message */
+	tmp = desc->bEndpointAddress;
+	DEBUG_NOTICE("enable %s(%d) ep%x%s-blk max %02x\n", _ep->name, ep->num,
+		     tmp, desc->bEndpointAddress & USB_DIR_IN ? "in" : "out",
+		     max);
+	sp_udc_set_halt(_ep, 0);
+
+	return 0;
+}
+
+static int sp_udc_ep_disable(struct usb_ep *_ep)
+{
+	struct sp_ep *ep = to_sp_ep(_ep);
+	u32 int_udll_ie;
+	u32 int_udn_ie;
+
+	DEBUG_DBG(">>> sp_udc_ep_disable...\n");
+
+	if (!_ep || !ep->desc) {
+		DEBUG_ERR("%s not enabled\n", _ep ? ep->ep.name : NULL);
+		return -EINVAL;
+	}
+
+	DEBUG_DBG("ep_disable: %s\n", _ep->name);
+	ep->desc = NULL;
+	ep->halted = 1;
+
+	sp_udc_nuke(ep->dev, ep, -ESHUTDOWN);
+
+	/* disable irqs */
+	int_udll_ie = udc_read(UDLIE);
+	int_udn_ie = udc_read(UDNBIE);
+	switch (ep->num) {
+	case EP0:
+		int_udll_ie &= ~(EP0I_IF | EP0O_IF | EP0S_IF);
+		break;
+	case EP1:
+		int_udll_ie &= ~(EP1I_IF);
+
+		if (udc_read(UEP12DMACS) & DMA_EN) {
+			dma_len_ep1 = 0;
+			udc_write(udc_read(UEP12DMACS) | DMA_FLUSH, UEP12DMACS);
+			while (!(udc_read(UEP12DMACS) & DMA_FLUSHEND)) {
+				DEBUG_DBG("wait dma 1 flush\n");
+			}
+		}
+		dma_len_ep1 = 0;
+		break;
+	case EP2:
+		int_udll_ie &= ~(EP2O_IF);
+		break;
+	case EP3:
+		int_udll_ie &= ~(EP3I_IF);
+		break;
+	case EP5:
+		int_udll_ie &= ~(EP5I_IF);
+		DEBUG_DBG("event will stop %x\n", udc_read(UDVDMA_CRCR));
+		udc_write(2, UDVDMA_CRCR);	/*stop ring*/
+		g_flag_ep5 = 1;
+#ifdef ISO_DEBUG_INFO
+		ep_iso_debug_dcache(trb_event,EP5);
+#endif
+		ep5_use = 0;
+		ep5_e = 0;
+		kfree(trb_c_start);
+		kfree(trb_event);
+		break;
+	case EP7:
+		int_udll_ie &= ~(EP7I_IF);
+		break;
+	case EP8:
+		int_udn_ie &= ~(EP8I_IF);
+		break;
+	case EP9:
+		int_udn_ie &= ~(EP9O_IF);
+		break;
+	case EP10:
+		break;
+	case EP11:
+		int_udn_ie &= ~(EP11O_IF);
+
+		if (udc_read(UDEPBDMACS) & DMA_EN) {
+			dma_len = 0;
+			dma_flag_b = 0;
+			udc_write(udc_read(UDEPBDMACS) | DMA_FLUSH, UDEPBDMACS);
+			while (!(udc_read(UDEPBDMACS) & DMA_FLUSHEND)) {
+				DEBUG_DBG("wait dma 11 flush\n");
+			}
+		}
+		break;
+	case EP12:
+		udc_write(2, UDEPCDMA_CRCR);	/*stop ring*/
+		g_flag_ep12 = 1;
+		ep12_use = 0;
+		ep12_e = 0;
+#ifdef ISO_DEBUG_INFO
+		ep_iso_debug_dcache(trb_event_12,EP12);
+#endif
+		kfree(trb_c_start_12);
+		kfree(trb_event_12);
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	udc_write(int_udll_ie, UDLIE);
+	udc_write(int_udn_ie, UDNBIE);
+
+	DEBUG_NOTICE("%s disabled\n", _ep->name);
+	DEBUG_DBG("<<< sp_udc_ep_disable...\n");
+	return 0;
+}
+
+static struct usb_request *sp_udc_alloc_request(struct usb_ep *_ep,
+						    gfp_t mem_flags)
+{
+	struct sp_request *req;
+
+	if (!_ep)
+		return NULL;
+
+	req = kzalloc(sizeof(struct sp_request), mem_flags);
+	if (!req)
+		return NULL;
+
+	req->req.dma = DMA_ADDR_INVALID;
+	INIT_LIST_HEAD(&req->queue);
+	return &req->req;
+}
+
+static void sp_udc_free_request(struct usb_ep *_ep,
+				    struct usb_request *_req)
+{
+	struct sp_ep *ep = to_sp_ep(_ep);
+	struct sp_request *req = to_sp_req(_req);
+
+	DEBUG_DBG("%s free rquest\n", _ep->name);
+
+	if (!ep || !_req || (!ep->desc && _ep->name != ep0name))
+		return;
+
+	WARN_ON(!list_empty(&req->queue));
+	kfree(req);
+}
+
+static void clearHwState_UDC(void)
+{
+
+	/*INFO: we don't disable udc interrupt when we are clear udc hw state,
+	 * 1.since when we are clearing, we are in ISR , will not the same interrupt reentry problem.
+	 * 2.after we finish clearing , we will go into udc ISR again, if there are interrupts occur while we are clearing ,we want to catch them
+	 *  immediately
+	 */
+	/*===== check udc DMA state, and flush it =======*/
+	int tmp = 0;
+	if (udc_read(UDEP2DMACS) & DMA_EN) {
+		dma_flag = 0;
+		udc_write(udc_read(UDEP2DMACS) | DMA_FLUSH, UDEP2DMACS);
+		while (!(udc_read(UDEP2DMACS) & DMA_FLUSHEND)) {
+			tmp++;
+			if (tmp > DMA_FLUSH_TIMEOUT_DELAY) {
+				DEBUG_INFO("##");
+				tmp = 0;
+			}
+		}
+	}
+
+	/*Disable Interrupt */
+	/*Clear linker layer Interrupt source */
+	udc_write(0xefffffff, UDLIF);
+	/*EP0 control status*/
+	udc_write(CLR_EP0_OUT_VLD, UDEP0CS);	/*clear ep0 out vld=1, clear set ep0 in vld=0, set ctl dir to OUT direction=0*/
+	udc_write(0x0, UDEP0CS);
+
+	/*udc_write(CLR_EP_OVLD| RESET_PIPO_FIFO ,UDEP1SCS);*/
+	udc_write(CLR_EP_OVLD | RESET_PIPO_FIFO, UDEP12C);
+
+	/*Clear Stall Status */
+	udc_write((CLREPBSTL | CLREPASTL | CLREP9STL | CLREP8STL | CLREP3STL |
+		   CLREP2STL | CLREP1STL | CLREP0STL), UDLCSTL);
+
+}
+
+static int vbusInt_handle(void)
+{
+	DEBUG_INFO(">>> vbusInt_handle...\n");
+	/*host present */
+	if (udc_read(UDCCS) & VBUS) {
+		/*IF soft discconect ->force connect */
+		if (udc_read(UDLCSET) & SOFT_DISC)
+			udc_write(udc_read(UDLCSET) & 0xFE, UDLCSET);
+	} else {		/*host absent */
+		/*soft connect ->force disconnect */
+		if (!(udc_read(UDLCSET) & SOFT_DISC))
+			udc_write(udc_read(UDLCSET) | SOFT_DISC, UDLCSET);
+		clearHwState_UDC();
+	}
+
+	DEBUG_INFO("<<< vbusInt_handle...\n");
+	return 0;
+}
+
+static int sp_udc_readep0s_fifo_crq(struct usb_ctrlrequest *crq)
+{
+	unsigned char *outbuf = (unsigned char *)crq;
+
+	DEBUG_INFO("read ep0 fifi crq ,len= %d\n", udc_read(UDEP0DC));
+	memcpy((unsigned char *)outbuf, (char *)(UDEP0SDP + base_addr), 4);
+	memcpy((unsigned char *)(outbuf + 4), (char *)(UDEP0SDP + base_addr), 4);
+
+	return 8;
+}
+
+static int sp_udc_write_ep0_fifo(struct sp_ep *ep,
+				     struct sp_request *req);
+static int sp_udc_read_ep0_fifo(struct sp_ep *ep,
+				    struct sp_request *req);
+
+static int sp_udc_get_status(struct sp_udc *dev,
+				 struct usb_ctrlrequest *crq)
+{
+	u16 status = 0;
+	u8 ep_num = crq->wIndex & 0x7F;
+	struct sp_ep *ep = &memory.ep[ep_num];
+
+	switch (crq->bRequestType & USB_RECIP_MASK) {
+	case USB_RECIP_INTERFACE:
+		break;
+
+	case USB_RECIP_DEVICE:
+		status = dev->devstatus;
+		break;
+
+	case USB_RECIP_ENDPOINT:
+		if (ep_num > 14 || crq->wLength > 2)
+			return 1;
+		status = ep->halted;
+		break;
+
+	default:
+		return 1;
+	}
+
+	udc_write(EP0_DIR | CLR_EP0_OUT_VLD, UDEP0CS);
+	udc_write(((1 << 2) - 1), UDEP0VB);
+	memcpy((char *)(base_addr + UDEP0DP), (char *)(&status), 4);
+	udc_write(udc_read(UDLIE) | EP0I_IF, UDLIE);
+	udc_write(SET_EP0_IN_VLD | EP0_DIR, UDEP0CS);
+
+	return 0;
+}
+
+static void sp_udc_handle_ep0s_idle(struct sp_udc *dev,
+					struct sp_ep *ep,
+					struct usb_ctrlrequest *crq, u32 ep0csr)
+{
+	int len;
+	int ret;
+	DEBUG_INFO(">>>sp_udc_handle_ep0s_idle...\n");
+	/* start control request? */
+	sp_udc_nuke(dev, ep, -EPROTO);
+
+	len = sp_udc_readep0s_fifo_crq(crq);
+	DEBUG_INFO("len  = %d\n", len);
+	if (len != sizeof(*crq)) {
+		DEBUG_ERR("setup begin: fifo READ ERROR"
+			  " wanted %d bytes got %d. Stalling out...\n",
+			  sizeof(*crq), len);
+		udc_write((udc_read(UDLCSTL) | SETEP0STL), UDLCSTL);	/* error send stall;*/
+		return;
+	}
+
+	DEBUG_DBG("bRequest = %x bRequestType %x, %x,%x, wLength = %d\n",
+		  crq->bRequest, crq->bRequestType, crq->wValue, crq->wIndex,
+		  crq->wLength);
+
+	/* cope with automagic for some standard requests. */
+	dev->req_std = (crq->bRequestType & USB_TYPE_MASK)
+	    == USB_TYPE_STANDARD;
+	dev->req_config = 0;
+	dev->req_pending = 1;
+
+	switch (crq->bRequest) {
+	case USB_REQ_GET_DESCRIPTOR:
+		DEBUG_INFO("start get descriptor after bus reset\n");
+		bus_reset_finish_flag = true;
+		{
+			u32 DescType = ((crq->wValue) >> 8);
+			if (DescType == 0x1) {
+				if (udc_read(UDLCSET) & CURR_SPEED) {
+					DEBUG_DBG("DESCRIPTOR SPeed = USB_SPEED_FULL\n");
+					dev->gadget.speed = USB_SPEED_FULL;
+					bulkep_dma_block_size = FULL_SPEED_DMA_SIZE;
+				} else {
+					DEBUG_DBG("DESCRIPTOR SPeed = USB_SPEED_HIGH\n");
+					dev->gadget.speed = USB_SPEED_HIGH;
+					bulkep_dma_block_size = HIGH_SPEED_DMA_SIZE;
+				}
+			}
+		}
+		break;
+	case USB_REQ_SET_CONFIGURATION:
+		DEBUG_INFO(" ******* USB_REQ_SET_CONFIGURATION ... \n");
+		dev->req_config = 1;
+		udc_write(udc_read(UDLCADDR) | (crq->wValue) << 16, UDLCADDR);
+		is_config = 1;
+		break;
+
+	case USB_REQ_SET_INTERFACE:
+		DEBUG_INFO("***** USB_REQ_SET_INTERFACE **** \n");
+		dev->req_config = 1;
+		if (intface_d) {
+			crq->wValue = 0;	/*interface namber */
+			crq->wIndex = 0;	/*altersetting */
+		}
+#ifdef CONFIG_USB_DEVICE_LOSE_PACKET_AFTER_SET_INTERFACE_WORKAROUND
+		udc_write(udc_read(UDLCADDR) | (1 << 18), UDLCADDR);
+#endif
+		break;
+
+	case USB_REQ_SET_ADDRESS:
+		DEBUG_INFO("USB_REQ_SET_ADDRESS ... \n");
+		break;
+
+	case USB_REQ_GET_STATUS:
+		DEBUG_INFO("USB_REQ_GET_STATUS ... \n");
+		if (dev->req_std) {
+			if (!sp_udc_get_status(dev, crq)) {
+				return;
+			}
+		}
+		break;
+
+	case USB_REQ_CLEAR_FEATURE:
+		break;
+
+	case USB_REQ_SET_FEATURE:
+		break;
+
+	default:
+		break;
+	}
+
+	if (crq->bRequestType & USB_DIR_IN) {
+		dev->ep0state = EP0_IN_DATA_PHASE;
+	} else {
+		dev->ep0state = EP0_OUT_DATA_PHASE;
+		/*udc_write(CLR_EP0_OUT_VLD, UDEP0CS);*/
+		DEBUG_NOTICE("ep0 fifo %x\n", udc_read(UDEP0CS));
+		udc_write(0, UDEP0CS);
+	}
+	/* deliver the request to the gadget driver */
+	ret = dev->driver->setup(&dev->gadget, crq);	/*android_setup composite_setup*/
+
+	if (crq->bRequest == USB_REQ_SET_ADDRESS) {
+
+		ret = 0;
+		dev->ep0state = EP0_IDLE;
+	}
+
+	if (ret < 0) {
+		if (dev->req_config) {
+			DEBUG_ERR("config change %02x fail %d?\n",
+				  crq->bRequest, ret);
+			return;
+		}
+
+		if (ret == -EOPNOTSUPP)
+			DEBUG_ERR("Operation not supported\n");
+		else
+			DEBUG_ERR("dev->driver->setup failed. (%d)\n", ret);
+
+		udelay(5);
+		udc_write(0x1, UDLCSTL);	/*set ep0 stall*/
+		dev->ep0state = EP0_IDLE;
+	} else if (dev->req_pending) {
+		DEBUG_INFO("dev->req_pending... what now?\n");
+		dev->req_pending = 0;
+		/*MSC reset command */
+		if (crq->bRequest == 0xff) {
+			/*ep1SetHalt = 0;
+			   ep2SetHalt = 0;*/
+		}
+	}
+
+	DEBUG_INFO("ep0state *** %s\n", ep0states[dev->ep0state]);
+}
+
+static void sp_udc_handle_ep0s(struct sp_udc *dev)
+{
+	u32 ep0csr;
+	struct sp_ep *ep = &dev->ep[0];
+	struct usb_ctrlrequest crq;
+	struct usb_composite_dev *cdev = get_gadget_data(&dev->gadget);
+	struct usb_request *req_g = NULL;
+	struct sp_request *req = NULL;
+
+	if (!cdev) {
+		DEBUG_DBG("cdev invalid\n");
+		return;
+	}
+	req_g = cdev->req;
+	req = to_sp_req(req_g);
+	if (!req) {
+		DEBUG_DBG("req invalid\n");
+		return;
+	}
+	ep0csr = udc_read(UDEP0CS);
+
+	switch (dev->ep0state) {
+	case EP0_IDLE:
+		DEBUG_DBG("EP0_IDLE_PHASE ... what now?\n");
+		sp_udc_handle_ep0s_idle(dev, ep, &crq, ep0csr);
+		break;
+
+	case EP0_IN_DATA_PHASE:
+		DEBUG_DBG("EP0_IN_DATA_PHASE ... what now?\n");
+		if (req->req.length != req->req.actual) {
+			if(1 == sp_udc_write_ep0_fifo(ep, req)){
+				udc_write(udc_read(UDLIE) & (~EP0I_IF), UDLIE);
+				udc_write(udc_read(UDEP0CS) & (~EP_DIR), UDEP0CS);
+				ep->dev->ep0state = EP0_IDLE;
+				DEBUG_DBG("ep0 in done\n");
+				sp_udc_done(ep, req, 0);
+			}
+		} else {
+			udc_write(udc_read(UDLIE) & (~EP0I_IF), UDLIE);
+			udc_write(udc_read(UDEP0CS) & (~EP_DIR), UDEP0CS);
+			ep->dev->ep0state = EP0_IDLE;
+			DEBUG_DBG("ep0 in done\n");
+			sp_udc_done(ep, req, 0);
+		}
+		break;
+	case EP0_OUT_DATA_PHASE:
+		DEBUG_DBG("EP0_OUT_DATA_PHASE *** what now?\n");
+		if (req->req.length != req->req.actual) {
+			if(1 == sp_udc_read_ep0_fifo(ep, req)){
+				udc_write(udc_read(UDLIE) & (~EP0O_IF), UDLIE);
+				udc_write(udc_read(UDEP0CS) | EP_DIR, UDEP0CS);
+				ep->dev->ep0state = EP0_IDLE;
+				sp_udc_done(ep, req, 0);
+				DEBUG_NOTICE("****ep0 out done\n");
+			}
+		} else {
+			udc_write(udc_read(UDLIE) & (~EP0O_IF), UDLIE);
+			udc_write(udc_read(UDEP0CS) | EP_DIR, UDEP0CS);
+			ep->dev->ep0state = EP0_IDLE;
+			sp_udc_done(ep, req, 0);
+			DEBUG_NOTICE("****ep0 out done\n");
+		}
+		break;
+
+	case EP0_END_XFER:
+		DEBUG_INFO("EP0_END_XFER ... what now?\n");
+		dev->ep0state = EP0_IDLE;
+		break;
+
+	case EP0_STALL:
+		DEBUG_INFO("EP0_STALL ... what now?\n");
+		dev->ep0state = EP0_IDLE;
+		break;
+	}
+}
+
+static inline int sp_udc_read_fifo_packet(int fifo, u8 * buf, int length,
+					      int regoffset)
+{
+	int n = 0;
+	int m = 0;
+	int i = 0;
+	char testbuf[4];
+
+	n = length / 4;
+	m = length % 4;
+	writel(0xF, base_addr + regoffset);
+	for (i = 0; i < n; i++) {
+		*((u32 *) (buf + (i * 4))) =
+		    *(u32 *) (base_addr + fifo);
+	}
+	if (m > 0) {
+		udc_write(((1 << m) - 1), regoffset);
+		memset(testbuf, 0, 4);
+		memcpy((char *)testbuf, (char *)(base_addr + fifo), 4);
+		memcpy((char *)(buf + (i * 4)), (char *)testbuf, m);
+	}
+	return length;
+}
+
+static inline int sp_udc_write_packet(int fifo, struct sp_request *req,
+					  unsigned max, int offset)
+{
+	unsigned len = min(req->req.length - req->req.actual, max);
+	u8 *buf = req->req.buf + req->req.actual;
+	int n = 0;
+	int m = 0;
+	int i = 0;
+
+	n = len / 4;
+	m = len % 4;
+
+	if (n > 0) {
+		udc_write(0xF, offset);
+		for (i = 0; i < n; i++) {
+			*(u32 *) (base_addr + fifo) =
+			    *((u32 *) (buf + (i * 4)));
+		}
+	}
+
+	if (m > 0) {
+		udc_write(((1 << m) - 1), offset);
+		memcpy((char *)(base_addr + fifo), (char *)(buf + n * 4), 4);
+	}
+
+	return len;
+}
+
+static inline int sp_udc_read_fifo0_packet(int fifo, u8 * buf, int length,
+					       int regoffset)
+{
+	int n = 0;
+	int m = 0;
+	int i = 0;
+	char testbuf[4];
+
+	n = length / 4;
+	m = length % 4;
+
+	writel(0xF, base_addr + regoffset);
+	for (i = 0; i < n; i++) {
+		*((u32 *) (buf + (i * 4))) =
+		    *(u32 *) (base_addr + fifo);
+	}
+	if (m > 0) {
+		udc_write(((1 << m) - 1), regoffset);
+		memset(testbuf, 0, 4);
+		memcpy((char *)testbuf, (char *)(base_addr + fifo), 4);
+		memcpy((char *)(buf + (i * 4)), (char *)testbuf, m);
+	}
+
+	return length;
+}
+
+static int sp_udc_write_ep0_fifo(struct sp_ep *ep,
+				     struct sp_request *req)
+{
+	unsigned count;
+	int is_last;
+	u32 idx;
+
+	idx = ep->bEndpointAddress & 0x7F;
+	if (idx != 0) {
+		DEBUG_ERR("write ep0 idx error\n");
+		return -1;
+	}
+
+	udc_write(EP0_DIR | CLR_EP0_OUT_VLD, UDEP0CS);
+	count = sp_udc_write_packet(UDEP0DP, req, ep->ep.maxpacket, UDEP0VB);
+	udc_write(udc_read(UDLIE) | EP0I_IF, UDLIE);
+	udc_write(SET_EP0_IN_VLD | EP0_DIR, UDEP0CS);
+	req->req.actual += count;
+	if (count != ep->ep.maxpacket)
+		is_last = 1;
+	else if (req->req.length == req->req.actual && !req->req.zero)
+		is_last = 1;
+	else
+		is_last = 0;
+	DEBUG_DBG("Written ep%d %d.%d of %d b [last %d,z %d]\n", idx, count,
+		  req->req.actual, req->req.length, is_last, req->req.zero);
+
+	return is_last;
+}
+
+static int sp_udc_read_ep0_fifo(struct sp_ep *ep,
+				    struct sp_request *req)
+{
+	u8 *buf;
+	unsigned bufferspace, count;
+	u32 idx;
+	u8 ep0_len = 64;
+	unsigned avail;
+	int is_last;
+
+	if (!req->req.length)
+		return 1;
+	idx = ep->bEndpointAddress & 0x7F;
+	buf = req->req.buf + req->req.actual;
+	bufferspace = req->req.length - req->req.actual;
+	if (!bufferspace) {
+		DEBUG_ERR("%s: buffer full!\n", __func__);
+		return -1;
+	}
+	DEBUG_DBG("\tread before %x\n", udc_read(UDEP0CS));
+	udc_write(udc_read(UDEP0CS) & (~EP0_DIR), UDEP0CS);	/*read direction*/
+
+	ep0_len = udc_read(UDEP0DC);
+	DEBUG_DBG("******** maxpacketsize is %d length:%d data in ep0 buff:%d\n",
+	     ep->ep.maxpacket, req->req.length, ep0_len);
+	if (ep0_len > ep->ep.maxpacket)
+		avail = ep->ep.maxpacket;
+	else
+		avail = ep0_len;
+	if (req->req.length > 0) {
+		count = sp_udc_read_fifo0_packet(UDEP0DP, buf, avail, UDEP0VB);
+		udc_write(udc_read(UDEP0CS) | CLR_EP0_OUT_VLD, UDEP0CS);
+		DEBUG_DBG("\t%x\n", udc_read(UDEP0CS));
+		req->req.actual += count;
+		if (count != ep->ep.maxpacket)
+			is_last = 1;
+		else if (req->req.length == req->req.actual && !req->req.zero)
+			is_last = 1;
+		else
+			is_last = 0;
+	} else {
+		is_last = 0;
+		count = 0;
+		req->req.actual = 0;
+	}
+	PrintBlock_usb(buf, 4);
+
+	if (!req->req.actual && !count)
+		is_last = 0;
+	/* Only ep0 debug messages are interesting */
+	if (idx == 0) {
+		DEBUG_DBG("Read ep%d read:%d actual:%d length:%d[last %d,z %d]\n",
+		     idx, count, req->req.actual, req->req.length, is_last,
+		     req->req.zero);
+	}
+	if (is_last) {
+		udc_write(udc_read(UDLIE) | EP0I_IF, UDLIE);
+		udc_write(SET_EP0_IN_VLD | EP0_DIR, UDEP0CS);
+	}
+	return is_last;
+}
+
+#ifdef EP2_ENABLE
+static int sp_udc_ep2_bulkout_pio(struct sp_ep *ep,
+				      struct sp_request *req,
+				      int is_pingbuf)
+{
+	u8 *buf;
+	u32 count, avail;
+	int is_last = 0;
+
+	DEBUG_INFO(">>>%x %s...%p len=%d actual=%d\n", udc_read(UDEP2FS),
+		   __FUNCTION__, req->req.buf, req->req.length,
+		   req->req.actual);
+
+	buf = req->req.buf + req->req.actual;
+	count = sp_udc_get_ep_fifo_count(is_pingbuf, UDEP2PIC);
+	if (!count) {
+		if ((udc_read(UDEP2FS) & 0x6) == 0x6) {
+			udc_write(udc_read(UDEP12C) | CLR_EP_OVLD, UDEP12C);
+			DEBUG_DBG("clear ep2 0\n");
+		}
+		DEBUG_DBG("rx count == 0 is_last = %d %x\n", is_last,
+			  udc_read(UDEP2FS));
+		if (req->req.actual) {
+			DEBUG_DBG("rx 0 len packet end req!\n");
+#ifndef LEN_PARSE		/*not define for adb */
+			is_last = 1;
+			sp_udc_done(ep, req, 0);
+#endif
+		}
+		return is_last;
+	}
+
+	if (count > ep->ep.maxpacket)
+		avail = ep->ep.maxpacket;
+	else
+		avail = count;
+
+	/*read data form ping or pong buffer according to UDEP12PPC[2] */
+	sp_udc_read_fifo_packet(UDEP2FDP, buf, avail, UDEP2VB);
+	DEBUG_DBG("read after %x %x :", udc_read(UDEP2FS), udc_read(UDEP12C));
+	DEBUG_DBG("%2x %2x %2x %2x\n", buf[0], buf[1], buf[2], buf[3]);
+	udc_write(udc_read(UDEP12C) | CLR_EP_OVLD, UDEP12C);
+
+	if (req->req.actual == 0) {
+		if (is_ean)
+			nth_len = (buf[4] << 24) + (buf[5] << 16) + (buf[6] << 8) + (buf[7]) + 8;
+		else
+			nth_len = ((struct usb_cdc_ncm_nth16 *)buf)->wBlockLength;
+		DEBUG_DBG("\t\t nth_len=%d\n", nth_len);
+	}
+	req->req.actual += avail;
+
+	if (count < ep->ep.maxpacket) {
+		is_last = 1;
+		/* overflowed this request?  flush extra data */
+		if (count != avail) {
+			req->req.status = -EOVERFLOW;
+			avail -= count;
+			DEBUG_NOTICE("[%s:%d], overflow [%d]\n", __FUNCTION__,
+				     __LINE__, avail);
+		}
+	} else if (req->req.length <= req->req.actual
+		   || avail < ep->ep.maxpacket)
+		is_last = 1;
+	else {
+		is_last = 0;
+	}
+	DEBUG_DBG("len=%d act=%d count=%d is_last=%d\n", req->req.length,
+		  req->req.actual, count, is_last);
+	if (is_last) {
+		sp_udc_done(ep, req, 0);
+	}
+
+	return is_last;
+}
+#endif
+static int sp_udc_ep9_bulkout_pio(struct sp_ep *ep,
+				      struct sp_request *req,
+				      int is_pingbuf)
+{
+	u8 *buf;
+	u32 count;
+	u32 avail;
+	int is_last = 0;
+
+	DEBUG_INFO(">>>ep9_bulkout_pio...%p len=%d actual=%d\n", req->req.buf,
+		   req->req.length, req->req.actual);
+
+	buf = req->req.buf + req->req.actual;
+	count = sp_udc_get_ep_fifo_count(is_pingbuf, UDEP9PIC);
+	if (!count) {
+		if ((udc_read(UDEP9FS) & 0x6) == 0x6)
+			udc_write(udc_read(UDEP89C) | CLR_EP_OVLD, UDEP89C);
+		DEBUG_DBG("rx count == 0 is_last = %d\n", is_last);
+		if (req->req.actual) {
+			DEBUG_DBG("rx 0 len packet end req!\n");
+#ifndef LEN_PARSE		/*not define for adb */
+			is_last = 1;
+			sp_udc_done(ep, req, 0);
+#endif
+		}
+		return is_last;
+	}
+
+	if (count > ep->ep.maxpacket)
+		avail = ep->ep.maxpacket;
+	else
+		avail = count;
+
+	/*read data form ping or pong buffer according to UDEP12PPC[2] */
+	sp_udc_read_fifo_packet(UDEP9FDP, buf, avail, UDEP9VB);
+/*   DEBUG_DBG("read after %x %x :",udc_read(UDEP9FS),udc_read(UDEP89C));
+      DEBUG_DBG("%2x %2x %2x %2x\n",buf[0],buf[1],buf[2],buf[3]);*/
+	udc_write(udc_read(UDEP89C) | CLR_EP_OVLD, UDEP89C);
+
+	req->req.actual += avail;
+	if (count < ep->ep.maxpacket) {
+		is_last = 1;
+		/* overflowed this request?  flush extra data */
+		if (count != avail) {
+			req->req.status = -EOVERFLOW;
+			avail -= count;
+			DEBUG_NOTICE("[%s:%d], overflow [%d]\n", __FUNCTION__,
+				     __LINE__, avail);
+		}
+	} else if (req->req.length <= req->req.actual
+		   || avail < ep->ep.maxpacket)
+		is_last = 1;
+	else {
+		is_last = 0;
+	}
+	DEBUG_DBG("len=%d act=%d count=%d is_last=%d\n", req->req.length,
+		  req->req.actual, count, is_last);
+	if (is_last) {
+		sp_udc_done(ep, req, 0);
+	}
+
+	return is_last;
+}
+
+static int sp_udc_ep11_bulkout_pio(struct sp_ep *ep,
+				       struct sp_request *req,
+				       int is_pingbuf)
+{
+	u8 *buf;
+	u32 count;
+	u32 avail;
+	int is_last = 0;
+
+	DEBUG_INFO(">>>%x %s...%p len=%d actual=%d\n", udc_read(UDEPBFS),
+		   __FUNCTION__, req->req.buf, req->req.length,
+		   req->req.actual);
+
+	buf = req->req.buf + req->req.actual;
+	count = sp_udc_get_ep_fifo_count(is_pingbuf, UDEPBPIC);
+	if (!count) {
+		if ((udc_read(UDEPBFS) & 0x6) == 0x6) {
+			udc_write(udc_read(UDEPABC) | CLR_EP_OVLD, UDEPABC);
+			DEBUG_DBG("clear ep11 0\n");
+		}
+		DEBUG_DBG("rx count == 0 is_last = %d %x\n", is_last,
+			  udc_read(UDEPBFS));
+		if (req->req.actual) {
+			DEBUG_DBG("rx 0 len packet end req!\n");
+#ifndef LEN_PARSE		/*not define for adb */
+			is_last = 1;
+			sp_udc_done(ep, req, 0);
+#endif
+		}
+		return is_last;
+	}
+
+	if (count > ep->ep.maxpacket)
+		avail = ep->ep.maxpacket;
+	else
+		avail = count;
+
+	/*read data form ping or pong buffer according to UDEP12PPC[2] */
+	DEBUG_DBG("count=%d avail=%d\n", count, avail);
+	sp_udc_read_fifo_packet(UDEPBFDP, buf, avail, UDEPBVB);
+	DEBUG_DBG("read after %x %x :", udc_read(UDEPBFS), udc_read(UDEPABC));
+	DEBUG_DBG("count=%d avail=%d\n", count, avail);
+	udc_write(udc_read(UDEPABC) | CLR_EP_OVLD, UDEPABC);
+
+	if (req->req.actual == 0) {
+		if (is_ean)
+			nth_len = (buf[4] << 24) + (buf[5] << 16) + (buf[6] << 8) + (buf[7]) + 8;
+		else
+			nth_len = ((struct usb_cdc_ncm_nth16 *)buf)->wBlockLength;
+		DEBUG_DBG("\t\t nth_len=%d\n", nth_len);
+	}
+#if defined(USBTEST_ZERO) || defined(USB_MASS_STORAGE)
+	//nth_len = req->req.length;
+#endif
+	req->req.actual += avail;
+
+	if (count < ep->ep.maxpacket) {
+		is_last = 1;
+		/* overflowed this request?  flush extra data */
+		if (count != avail) {
+			req->req.status = -EOVERFLOW;
+			avail -= count;
+			DEBUG_NOTICE("[%s:%d], overflow [%d]\n", __FUNCTION__,
+				     __LINE__, avail);
+		}
+	} else if (req->req.length <= req->req.actual
+		   || avail < ep->ep.maxpacket || nth_len == req->req.actual)
+		is_last = 1;
+	else {
+		is_last = 0;
+	}
+	DEBUG_DBG("len=%d act=%d count=%d is_last=%d\n", req->req.length,
+		  req->req.actual, count, is_last);
+	if (is_last) {
+		sp_udc_done(ep, req, 0);
+	}
+
+	return is_last;
+}
+
+#ifdef EP1_DMA
+static int sp_udc_ep1_bulkin_dma(struct sp_ep *ep,
+				     struct sp_request *req)
+{
+	u8 *buf;
+	int dma_xferlen;
+	int actual_length = 0;
+
+	DEBUG_DBG(">>>%s\n", __FUNCTION__);
+	if (req->req.dma == DMA_ADDR_INVALID) {
+		req->req.dma = dma_map_single(ep->dev->gadget.dev.parent, req->req.buf, dma_len_ep1, (ep->bEndpointAddress & USB_DIR_IN)
+				   ? DMA_TO_DEVICE : DMA_FROM_DEVICE);
+	}
+	buf = (u8 *) (req->req.dma + req->req.actual + actual_length);
+
+	dma_xferlen = min(dma_len_ep1 - req->req.actual - actual_length, (unsigned)UDC_FLASH_BUFFER_SIZE);
+	DEBUG_DBG("%p dma_xferlen = %d %d\n", buf, dma_xferlen, dma_len_ep1);
+	actual_length = dma_xferlen;
+	if (dma_xferlen > 4096)
+		DEBUG_NOTICE("dma in len err %d\n", dma_xferlen);
+	/*udc_write(dma_xferlen, UEP12DMACS);*/
+	udc_write(dma_xferlen | DMA_COUNT_ALIGN, UEP12DMACS);
+	udc_write((u32) buf, UEP12DMADA);
+	udc_write(udc_read(UEP12DMACS) | DMA_EN, UEP12DMACS);
+
+	if (udc_read(UEP12DMACS) & DMA_EN) {
+		udc_write(udc_read(UDLIE) | EP1_DMA_IF, UDLIE);
+		return 0;
+	}
+	udc_write(EP1_DMA_IF, UDLIF);
+
+	req->req.actual += actual_length;
+	DEBUG_DBG("req->req.actual = %d %x\n", req->req.actual,
+		  udc_read(UEP12DMACS));
+	if (req->req.dma != DMA_ADDR_INVALID) {
+		dma_unmap_single(ep->dev->gadget.dev.parent, req->req.dma,
+				 dma_len_ep1,
+				 (ep->bEndpointAddress & USB_DIR_IN)
+				 ? DMA_TO_DEVICE : DMA_FROM_DEVICE);
+		req->req.dma = DMA_ADDR_INVALID;
+	}
+	dma_len_ep1 = 0;
+	DEBUG_DBG("<<< %s\n", __FUNCTION__);
+	return 1;
+}
+#endif
+static int sp_udc_ep12_bulkout_dma(struct sp_ep *ep,
+				       struct sp_request *req);
+#ifdef EP2_DMA
+static int sp_udc_ep2_bulkout_pio_with_dma(struct sp_ep *ep,
+					       struct sp_request *req,
+					       int is_pingbuf)
+{
+	u8 *buf;
+	u32 count;
+	u32 avail;
+	int is_last = 0;
+	struct usb_cdc_ncm_nth16 *pnth_header;
+
+	DEBUG_INFO(">>>%x sp3502_udc_ep2_bulkout_pio...%p len=%d actual=%d\n",
+		   udc_read(UDEP2FS), req->req.buf, req->req.length,
+		   req->req.actual);
+	buf = req->req.buf + req->req.actual;
+	count = sp_udc_get_ep_fifo_count(is_pingbuf, UDEP2PIC);
+	if (!count) {
+		if ((udc_read(UDEP2FS) & 0x6) == 0x6) {
+			udc_write(udc_read(UDEP12C) | CLR_EP_OVLD, UDEP12C);
+			DEBUG_DBG("clear ep2 0\n");
+		}
+		DEBUG_DBG("rx count == 0 is_last = %d\n", is_last);
+		if (req->req.actual) {
+			DEBUG_DBG("rx 0 len packet end req!\n");
+		}
+		return is_last;
+	}
+
+	if (count > ep->ep.maxpacket)
+		avail = ep->ep.maxpacket;
+	else
+		avail = count;
+
+	sp_udc_read_fifo_packet(UDEP2FDP, buf, avail, UDEP2VB);
+	udc_write(udc_read(UDEP12C) | CLR_EP_OVLD, UDEP12C);
+	if (req->req.actual == 0) {
+		pnth_header = (struct usb_cdc_ncm_nth16 *)buf;
+		if (is_ean)
+			nth_len = (buf[4] << 24) + (buf[5] << 16) + (buf[6] << 8) + (buf[7]) + 8;
+		else
+			nth_len = ((struct usb_cdc_ncm_nth16 *)buf)->wBlockLength;
+		DEBUG_DBG("\t\t nth_len=%d\n", nth_len);
+	}
+#ifdef USBTEST_ZERO
+	/*nth_len = req->req.length;*/
+	nth_len = 1536;
+	req->req.length = 1536;
+#endif
+
+#ifndef USBTEST_ZERO
+	if (!req->req.actual) {
+		if (!is_ean && *(u32 *) buf != ZERO_TEST_TAG) {
+			DEBUG_NOTICE("note wei\n");
+			return 0;
+		}
+	}
+#endif
+
+	req->req.actual += avail;
+	DEBUG_DBG("ep2 fifo status %x act=%d", udc_read(UDEP2FS),
+		  req->req.actual);
+	if (count < ep->ep.maxpacket) {
+		is_last = 1;
+		/* overflowed this request?  flush extra data */
+		if (count != avail) {
+			req->req.status = -EOVERFLOW;
+			avail -= count;
+			DEBUG_ERR("[%s:%d], overflow [%d]\n", __FUNCTION__,
+				  __LINE__, avail);
+		}
+	} else if (req->req.length <= req->req.actual
+		   || avail < ep->ep.maxpacket)
+		is_last = 1;
+	else {
+		is_last = 0;
+		if (nth_len == req->req.actual) {
+			is_last = 1;
+		}
+	}
+	DEBUG_DBG("len=%d nth_len=%d act=%d count=%d is_last=%d\n",
+		  req->req.length, nth_len, req->req.actual, count, is_last);
+	if (is_last) {
+		sp_udc_done(ep, req, 0);
+		return 1;
+	}
+
+	dma_len = nth_len - bulkep_dma_block_size - (nth_len % bulkep_dma_block_size);
+	DEBUG_DBG("dma_len=%d %d\n", dma_len, bulkep_dma_block_size);
+	if (dma_len / bulkep_dma_block_size) {
+		if (!sp_udc_ep12_bulkout_dma(ep, req))
+			return -1;
+		if (req->req.length == req->req.actual
+		    || (req->req.actual == nth_len)) {
+			/*PrintBlock_usb(req->req.buf,req->req.actual);*/
+			sp_udc_done(ep, req, 0);
+			return 1;
+		}
+	}
+
+	return is_last;
+}
+#endif
+static int sp_udc_ep11_bulkout_dma(struct sp_ep *ep,
+				       struct sp_request *req);
+
+static int sp_udc_ep11_bulkout_pio_with_dma(struct sp_ep *ep,
+						struct sp_request *req,
+						int is_pingbuf)
+{
+	u8 *buf;
+	u32 count;
+	u32 avail;
+	u32 count2;
+	int is_last = 0;
+
+	DEBUG_INFO(">>>%x %s...%p len=%d actual=%d\n", udc_read(UDEPBFS),
+		   __FUNCTION__, req->req.buf, req->req.length,
+		   req->req.actual);
+	buf = req->req.buf + req->req.actual;
+	{
+		count = sp_udc_get_ep_fifo_count((udc_read(UDEPBPPC) & CURR_BUFF), UDEPBPIC);
+		count2 = sp_udc_get_ep_fifo_count(!(udc_read(UDEPBPPC) & CURR_BUFF), UDEPBPIC);
+		if (!count) {
+			if ((udc_read(UDEPBFS) & 0x6) == 0x6) {
+				udc_write(udc_read(UDEPABC) | CLR_EP_OVLD, UDEPABC);
+				DEBUG_DBG("clear ep11 0\n");
+			}
+			DEBUG_DBG("rx count == 0 is_last = %d\n", is_last);
+			DEBUG_DBG("is_ncm = %d \n", is_ncm);
+			if (req->req.actual) {
+				DEBUG_DBG("rx 0 len packet end req!\n");
+			}
+			return is_last;
+		}
+
+		if (count > ep->ep.maxpacket)
+			avail = ep->ep.maxpacket;
+		else
+			avail = count;
+
+		sp_udc_read_fifo_packet(UDEPBFDP, buf, avail, UDEPBVB);
+		udc_write(udc_read(UDEPABC) | CLR_EP_OVLD, UDEPABC);
+	}
+	if (req->req.actual == 0) {
+		if (is_ean)
+			nth_len = (buf[4] << 24) + (buf[5] << 16) + (buf[6] << 8) + (buf[7]) + 8;
+		else
+			nth_len = ((struct usb_cdc_ncm_nth16 *)buf)->wBlockLength;
+		if (nth_len == 16384)
+			DEBUG_NOTICE("nth = 16k\n");
+		DEBUG_DBG("\t\t count %d nth_len=%d count2 %d %d\n", count,
+			  nth_len, count2, is_pingbuf);
+	}
+#ifdef USBTEST_ZERO
+	nth_len = req->req.length;
+#endif
+
+#ifndef USBTEST_ZERO
+	if (0) {
+		if (!is_ean && *(u32 *) buf != ZERO_TEST_TAG) {
+			/*udc_write(udc_read(UDEPBPPC) | 1, UDEPBPPC);
+			dma_fail = 1;*/
+			PrintBlock_usb(buf, avail);
+			DEBUG_ERR("**********note wei\n");
+			return 0;
+		}
+	}
+#endif
+
+	req->req.actual += avail;
+	DEBUG_DBG("ep11 fifo status %x act=%d", udc_read(UDEPBFS),
+		  req->req.actual);
+	if (count < ep->ep.maxpacket) {
+		is_last = 1;
+		/* overflowed this request?  flush extra data */
+		if (count != avail) {
+			req->req.status = -EOVERFLOW;
+			avail -= count;
+			DEBUG_ERR("[%s:%d], overflow [%d]\n", __FUNCTION__,
+				  __LINE__, avail);
+		}
+	} else if (req->req.length <= req->req.actual
+		   || avail < ep->ep.maxpacket)
+		is_last = 1;
+	else {
+		is_last = 0;
+		if (nth_len == req->req.actual) {
+			is_last = 1;
+		}
+	}
+	DEBUG_DBG("len=%d nth_len=%d act=%d count=%d is_last=%d\n",
+		  req->req.length, nth_len, req->req.actual, count, is_last);
+	if (is_last) {
+		sp_udc_done(ep, req, 0);
+		return 1;
+	}
+
+	dma_len = nth_len - bulkep_dma_block_size - (nth_len % bulkep_dma_block_size);
+	DEBUG_DBG("dma_len=%d %d\n", dma_len, bulkep_dma_block_size);
+	if (dma_len / bulkep_dma_block_size) {
+		if (!sp_udc_ep11_bulkout_dma(ep, req))
+			return -1;
+		if (req->req.length == req->req.actual
+		    || (req->req.actual == nth_len)) {
+			sp_udc_done(ep, req, 0);
+			return 1;
+		}
+	}
+
+	return is_last;
+}
+
+#ifdef EP1_DMA
+static int sp_ep1_bulkin_dma(struct sp_ep *ep,
+				 struct sp_request *req)
+{
+	u32 count;
+	int is_last = 0;
+
+	DEBUG_DBG(">>>%s\n", __FUNCTION__);
+	if (dma_len_ep1) {
+		return 0;
+	}
+
+	udc_write(udc_read(UDLIE) & (~EP1I_IF), UDLIE);
+
+	if (req->req.actual)
+		goto _TX_BULK_IN_DATA;
+	/* DMA Mode */
+	dma_len_ep1 = req->req.length - (req->req.length % bulkep_dma_block_size);
+	if (dma_len_ep1 == bulkep_dma_block_size) {
+		dma_len_ep1 = 0;
+		goto _TX_BULK_IN_DATA;
+	}
+	if (dma_len_ep1) {
+		DEBUG_DBG("ep1 bulk in dma mode,zero=%d\n", req->req.zero);
+		if (!sp_udc_ep1_bulkin_dma(ep, req))
+			return 0;
+		/*else if(req->req.length == req->req.actual){
+		   is_last = 1;
+		   goto done_dma;} */
+		else if (req->req.length == req->req.actual && !req->req.zero) {
+			is_last = 1;
+			goto done_dma;
+		} else if (udc_read(UDEP12FS) & 0x1) {
+			DEBUG_DBG("ep1 dma->pio wait write!\n");
+			goto done_dma;
+		} else {
+			udc_write(udc_read(UDLIE) & (~EP1I_IF), UDLIE);
+
+			udc_write(EP1N_IF, UDLIF);
+			count = sp_udc_write_packet(UDEP12FDP, req, ep->ep.maxpacket, UDEP12VB);
+			udc_write(udc_read(UDEP12C) | SET_EP_IVLD, UDEP12C);
+			req->req.actual += count;
+			sp_udc_done(ep, req, 0);
+			DEBUG_DBG("ep1 dma->pio write!\n");
+			udc_write(udc_read(UDLIE) | EP1I_IF, UDLIE);
+			return 1;
+		}
+	}
+
+_TX_BULK_IN_DATA:
+	udc_write(EP1N_IF, UDLIF);
+	if (!(udc_read(UDEP12FS) & 0x1)) {
+		count = sp_udc_write_packet(UDEP12FDP, req, ep->ep.maxpacket, UDEP12VB);
+	} else {
+		DEBUG_DBG("A?? %x\n", udc_read(UDEP12FS));
+		if (!(udc_read(UDEP12FS) & 0x1))
+			goto _TX_BULK_IN_DATA;
+		return is_last;
+	}
+	/*if(count < ep->ep.maxpacket){
+	   udc_write(EP1I_IF, UDLIF);
+	   } */
+	udc_write(udc_read(UDEP12C) | SET_EP_IVLD, UDEP12C);
+	req->req.actual += count;
+	DEBUG_DBG("ep1 buf=%p count=%d len=%d\n", req->req.buf, count,
+		  req->req.length);
+	if (count != ep->ep.maxpacket)
+		is_last = 1;
+	else if (req->req.length == req->req.actual && !req->req.zero)
+		is_last = 1;
+	else
+		is_last = 0;
+
+done_dma:
+	if (is_last) {
+		sp_udc_done(ep, req, 0);
+	} else if (!(udc_read(UDEP12FS) & 0x1))
+		goto _TX_BULK_IN_DATA;
+
+	udc_write(udc_read(UDLIE) | EP1I_IF, UDLIE);
+	DEBUG_DBG(" <<<%s...\n", __FUNCTION__);
+	return is_last;
+}
+#endif
+static int sp_ep1_bulkin(struct sp_ep *ep, struct sp_request *req)
+{
+	u32 count;
+	int is_last = 0;
+	int is_ping;
+
+	DEBUG_DBG(">>>%s\n", __FUNCTION__);
+	udc_write(udc_read(UDLIE) & (~EP1I_IF), UDLIE);
+
+	/* PIO Mode */
+_TX_BULK_IN_DATA:
+	udc_write(EP1N_IF, UDLIF);
+	if (!(udc_read(UDEP12FS) & EP_IVLD)) {
+		is_ping = udc_read(UDEP12PPC) & CURR_BUFF;
+		count = sp_udc_write_packet(UDEP12FDP, req, ep->ep.maxpacket, UDEP12VB);
+	} else {
+		DEBUG_DBG("1?? %x %d\n", udc_read(UDEP12FS), sp_udc_get_ep_fifo_count(udc_read(UDEP12PPC) & CURR_BUFF, UDEP12PIC));
+		if ((!(udc_read(UDEP12FS) & 0x1)) && !(sp_udc_get_ep_fifo_count(udc_read(UDEP12PPC) & CURR_BUFF, UDEP12PIC))) {
+			DEBUG_DBG("note ep1_bulkin...\n");
+			goto _TX_BULK_IN_DATA;
+		}
+		udc_write(udc_read(UDLIE) | EP1I_IF, UDLIE);
+		return is_last;
+	}
+	udc_write(udc_read(UDEP12C) | SET_EP_IVLD, UDEP12C);
+	req->req.actual += count;
+	DEBUG_DBG("ep1 act=%d count=%d len=%d %d ep:%x\n", req->req.actual,
+		  count, req->req.length, udc_read(UDEP12FS),
+		  udc_read(UDEP2FS));
+	if (count != ep->ep.maxpacket)
+		is_last = 1;
+	else if (req->req.length == req->req.actual && !req->req.zero)
+		is_last = 1;
+	else
+		is_last = 0;
+
+	if (is_last) {
+		sp_udc_done(ep, req, 0);
+	} else
+	    if (!sp_udc_get_ep_fifo_count
+		(udc_read(UDEP12PPC) & CURR_BUFF, UDEP12PIC))
+		goto _TX_BULK_IN_DATA;
+
+	udc_write(udc_read(UDLIE) | EP1I_IF, UDLIE);
+	DEBUG_DBG(" <<< %s...\n", __FUNCTION__);
+	return is_last;
+}
+
+static int sp_ep8_bulkin(struct sp_ep *ep, struct sp_request *req)
+{
+	u32 count;
+	int is_last = 0;
+	int is_ping;
+
+	DEBUG_DBG(">>> sp_ep8_bulkin...\n");
+	udc_write(udc_read(UDNBIE) & (~EP8I_IF), UDNBIE);
+
+	/* PIO Mode */
+_TX_BULK_IN8_DATA:
+	/*udc_write(EP8N_IF, UDNBIE);*/
+	if (!(udc_read(UDEP89FS) & EP_IVLD)) {
+		is_ping = udc_read(UDEP89PPC) & CURR_BUFF;
+		count = sp_udc_write_packet(UDEP89FDP, req, ep->ep.maxpacket, UDEP89VB);
+	} else {
+		DEBUG_DBG("8?? %x %d\n", udc_read(UDEP89FS), sp_udc_get_ep_fifo_count(udc_read(UDEP89PPC) & CURR_BUFF, UDEP89PIC));
+		if ((!(udc_read(UDEP89FS) & 0x1)) && !(sp_udc_get_ep_fifo_count(udc_read(UDEP89PPC) & CURR_BUFF, UDEP89PIC))) {
+			DEBUG_DBG(">>> note \n");
+			goto _TX_BULK_IN8_DATA;
+		}
+		return is_last;
+	}
+	udc_write(udc_read(UDEP89C) | SET_EP_IVLD, UDEP89C);
+	req->req.actual += count;
+	DEBUG_DBG("ep8 act=%d count=%d len=%d %x\n", req->req.actual, count,
+		  req->req.length, udc_read(UDEP89FS));
+	if (count != ep->ep.maxpacket)
+		is_last = 1;
+	else if (req->req.length == req->req.actual && !req->req.zero)
+		is_last = 1;
+	else
+		is_last = 0;
+
+	if (is_last) {
+		sp_udc_done(ep, req, 0);
+	} else if ((!(udc_read(UDEP89FS) & 0x1))
+		   && (is_ping != (udc_read(UDEP89PPC) & CURR_BUFF)))
+		goto _TX_BULK_IN8_DATA;
+
+	udc_write(udc_read(UDNBIE) | EP8I_IF, UDNBIE);
+	DEBUG_DBG(" <<< sp_ep8_bulkin...\n");
+	return is_last;
+}
+
+static int sp_udc_ep12_bulkout_dma(struct sp_ep *ep,
+				       struct sp_request *req)
+{
+	u8 *buf;
+	int actual_length = 0;
+	int cur_length = dma_len;
+	int dma_xferlen;
+	int is_error = 0;
+	unsigned long t;
+
+	udc_write(udc_read(UDCIE) & (~EP2_DMA_IF), UDCIE);
+	dma_flag = 2;
+	DEBUG_DBG(">>> sp_udc_ep12_bulkout_dma...\n");
+	DEBUG_DBG("12length=%d 12actual=%d\n", req->req.length,
+		  req->req.actual);
+
+	if (req->req.dma == DMA_ADDR_INVALID) {
+		req->req.dma = dma_map_single(ep->dev->gadget.dev.parent, (u8 *) req->req.buf + req->req.actual /*+ bulkep_dma_block_size */ ,
+				   cur_length + 512,	/*512 for debug dma*/
+				   (ep->bEndpointAddress & USB_DIR_IN)
+				   ? DMA_TO_DEVICE : DMA_FROM_DEVICE);
+	}
+	/*if(!(udc_read(UDEP2DMACS) & DMA_FLUSHEND))*/
+	DEBUG_DBG("%x cur_length=%d actual_length=%d\n", udc_read(UDEP2DMACS),
+		  cur_length, actual_length);
+	while (actual_length < cur_length) {
+		/*sp_udc_dma_int_en(USB_DMA_EP2_BULK_OUT, 1);*/
+		buf = (u8 *) (req->req.dma /*+ req->req.actual - bulkep_dma_block_size */  + actual_length);
+		dma_xferlen = min(cur_length - actual_length, (int)UDC_FLASH_BUFFER_SIZE);
+		DEBUG_DBG("bulkout dma_xferlen = %d dma_addr %p req buf %p %x\n", dma_xferlen, buf, (u8 *) req->req.buf, udc_read(UDEP2DMACS));
+		udc_write(udc_read(UDEP2DMACS) | DMA_COUNT_ALIGN | DMA_WRITE | dma_xferlen, UDEP2DMACS);
+		udc_write((u32) buf, UDEP2DMADA);
+		/*udc_write(udc_read(UDCIE) | CIE_DMA_IE , UDCIE);*/
+		udc_write(udc_read(UDEP2DMACS) | DMA_EN, UDEP2DMACS);
+		/*clear flag */
+		/*udc_write(EP12C_ENABLE_BULK, UDC_EP12C_OFST);*/
+		DEBUG_DBG("************Wait DMA Finish***************** %x\n",
+			  udc_read(UDEP2DMACS));
+
+		t = jiffies;
+		if ((udc_read(UDEP2DMACS) & DMA_EN)
+		    || (!(udc_read(UDCIF) & EP2_DMA_IF))
+		    || (udc_read(UDEP2DMACS) & 0x3fffff)) {
+			udc_write(udc_read(UDCIE) | EP2_DMA_IF, UDCIE);
+			if (!(udc_read(UDEP2DMACS) & DMA_EN))
+				DEBUG_ERR("dma%d staus %x\n", ep->num,
+					  udc_read(UDEP2DMACS));
+			return 0;
+		}
+		udc_write(EP2_DMA_IF, UDCIF);
+		while ((udc_read(UDEP2DMACS) & DMA_EN) != 0) {
+			if (time_after(jiffies, t + 10 * HZ)) {	/**/
+				req->req.status = -ECONNRESET;
+				sp_udc_done(ep, req, -ECONNRESET);
+				is_error = 1;
+				DEBUG_ERR("cur_length=%d req->req.actual=%d\n",
+					  cur_length, req->req.actual);
+				DEBUG_ERR("[%s:%d] DMA Error [0x%x]\n",
+					  __FUNCTION__, __LINE__,
+					  udc_read(UDEP2DMACS));
+				break;
+			}
+			/*if((udc_read(UDEP2FS)&0x22) == 0x20)
+			      udc_write(udc_read(UDEP2PPC) | SWITCH_BUFF ,UDEP2PPC);*/
+		}
+		DEBUG_DBG("EP2_DMA_IF = %x\n", udc_read(UDCIF) & EP2_DMA_IF);
+		udc_write(EP2_DMA_IF, UDCIF);
+		DEBUG_DBG("DMA_EN disable\n");
+		actual_length += dma_xferlen;
+		DEBUG_DBG("disable\n");
+	}
+
+	DEBUG_DBG("cur_length=%d actual_length=%d\n", cur_length,
+		  actual_length);
+	req->req.actual += actual_length;
+	cur_length -= actual_length;
+	DEBUG_DBG("cur_length=%d req->req.actual=%d\n", cur_length,
+		  req->req.actual);
+
+	if (req->req.dma != DMA_ADDR_INVALID) {
+		dma_unmap_single(ep->dev->gadget.dev.parent, req->req.dma,
+				 cur_length, (ep->bEndpointAddress & USB_DIR_IN)
+				 ? DMA_TO_DEVICE : DMA_FROM_DEVICE);
+		req->req.dma = DMA_ADDR_INVALID;
+	}
+	DEBUG_DBG("<<< sp_udc_ep12_bulkout_dma...\n");
+
+	DEBUG_DBG("DD %x\n", udc_read(UDEP2DMACS));
+	dma_flag = 0;
+	dma_len = 0;
+	return 1;
+}
+
+static int sp_udc_ep11_bulkout_dma(struct sp_ep *ep,
+				       struct sp_request *req)
+{
+	u8 *buf;
+	int actual_length = 0;
+	int cur_length = dma_len;
+	int dma_xferlen;
+	int is_error = 0;
+	unsigned long t;
+
+	udc_write(udc_read(UDCIE) & (~EPB_DMA_IF), UDCIE);
+	dma_flag_b = 11;
+	DEBUG_DBG("11length=%d 11actual=%d\n", req->req.length,
+		  req->req.actual);
+	if (req->req.dma == DMA_ADDR_INVALID) {
+		req->req.dma = dma_map_single(ep->dev->gadget.dev.parent, (u8 *) req->req.buf + req->req.actual ,
+				   cur_length,
+				   (ep->bEndpointAddress & USB_DIR_IN)
+				   ? DMA_TO_DEVICE : DMA_FROM_DEVICE);
+	}
+
+	DEBUG_DBG("cur_length=%d actual_length=%d\n", cur_length,
+		  actual_length);
+	while (actual_length < cur_length) {
+		buf = (u8 *) (req->req.dma + actual_length);
+		dma_xferlen = min(cur_length - actual_length, (int)UDC_FLASH_BUFFER_SIZE);
+		/*DEBUG_DBG("bulkout dma_xferlen = %d %d dma_addr %p req buf %p %x\n", dma_xferlen,nth_len, buf, (u8 *) req->req.buf, udc_read(UDEPBDMACS));
+		DEBUG_DBG("bulkout dma_xferlen = %d dma_addr %p req buf %p %x\n", dma_xferlen, buf, (u8 *) req->req.buf, udc_read(UDEPBDMACS));
+		udc_write(udc_read(UDEPBDMACS) | DMA_COUNT_ALIGN | DMA_WRITE | dma_xferlen, UDEPBDMACS);*/
+		udc_write((u32) buf, UDEPBDMADA);
+		if ((udc_read(UDEPBDMACS) & 0xff000000) == 0x58000000)
+			DEBUG_DBG("dma --staus 0x%x\n", udc_read(UDEPBDMACS));
+		/*udc_write(udc_read(UDEPBDMACS) | DMA_EN, UDEPBDMACS);*/
+		udc_write((udc_read(UDEPBDMACS) & (~DMA_COUNT_MASK)) |
+			  DMA_COUNT_ALIGN | DMA_WRITE | dma_xferlen | DMA_EN,
+			  UDEPBDMACS);
+		/*clear flag */
+		/*verB DMA bug*/
+		if (!down_trylock(&ep11_sw_sem)) {
+			if ((udc_read(UDEPBFS) & 0x22) == 0x20)
+				udc_write(udc_read(UDEPBPPC) | SWITCH_BUFF, UDEPBPPC);
+			up(&ep11_sw_sem);
+		}
+		DEBUG_DBG("dma staus %x\n", udc_read(UDEPBDMACS));
+		DEBUG_DBG("************Wait DMA Finish***************** %x\n",
+			  udc_read(UDEPBDMACS));
+		t = jiffies;
+#ifdef SW_IRQ
+		if (!is_ncm && ((udc_read(UDEPBDMACS) & DMA_EN)
+				|| (!(udc_read(UDCIF) & EPB_DMA_IF))
+				|| (udc_read(UDEPBDMACS) & 0x3fffff))) {
+			udc_write(udc_read(UDCIE) | EPB_DMA_IF, UDCIE);
+#ifdef MANUAL_EP11
+			udc_write(udc_read(UDNBIE) | EP11O_IF, UDNBIE);
+			/*if((udc_read(UDEPBFS)&0x22) == 0x20){
+			   udc_write(udc_read(UDEPBPPC) | SWITCH_BUFF ,UDEPBPPC);
+			   } */
+#endif
+			if (!(udc_read(UDEPBDMACS) & DMA_EN))
+				DEBUG_ERR("dma%d staus %x\n", ep->num,
+					  udc_read(UDEPBDMACS));
+			return 0;
+		}
+#endif
+		if (is_ncm && ((udc_read(UDEPBDMACS) & DMA_EN)
+			       || (!(udc_read(UDCIF) & EPB_DMA_IF))
+			       || (udc_read(UDEPBDMACS) & 0x3fffff))) {
+			udc_write(udc_read(UDCIE) | EPB_DMA_IF, UDCIE);
+
+			if (!(udc_read(UDEPBDMACS) & DMA_EN))
+				DEBUG_DBG("dma%d staus %x\n", ep->num,
+					  udc_read(UDEPBDMACS));
+			return 0;
+		}
+		while ((udc_read(UDEPBDMACS) & DMA_EN) != 0) {
+			if (time_after(jiffies, t + 10 * HZ)) {	/**/
+				req->req.status = -ECONNRESET;
+				sp_udc_done(ep, req, -ECONNRESET);
+				is_error = 1;
+				DEBUG_ERR("cur_length=%d req->req.actual=%d\n",
+					  cur_length, req->req.actual);
+				DEBUG_ERR("[%s:%d] DMA Error [0x%x]\n",
+					  __FUNCTION__, __LINE__,
+					  udc_read(UDEPBDMACS));
+				break;
+			}
+		}
+		DEBUG_DBG("EP11_DMA_IF = %x\n", udc_read(UDCIF) & EPB_DMA_IF);
+		udc_write(EPB_DMA_IF, UDCIF);
+		actual_length += dma_xferlen;
+	}
+
+	req->req.actual += actual_length;
+	cur_length -= actual_length;
+
+	if (req->req.dma != DMA_ADDR_INVALID) {
+		dma_unmap_single(ep->dev->gadget.dev.parent, req->req.dma,
+				 cur_length, (ep->bEndpointAddress & USB_DIR_IN)
+				 ? DMA_TO_DEVICE : DMA_FROM_DEVICE);
+		req->req.dma = DMA_ADDR_INVALID;
+	}
+	DEBUG_DBG("DD %x\n", udc_read(UDEPBDMACS));
+	dma_flag_b = 0;
+	dma_len = 0;
+	return 1;
+}
+
+static int sp_ep2_bulkout_dma(struct sp_ep *ep,
+				  struct sp_request *req)
+{
+	int is_pingbuf = 0;
+	int ret = 0;
+	udc_write(udc_read(UDLIE) & (~EP2O_IF), UDLIE);
+	udc_write(udc_read(UDLIE) & (~EP2N_IF), UDLIE);
+
+	nth_len = req->req.length;
+	dma_len = nth_len;
+	if (!sp_udc_ep12_bulkout_dma(ep, req))
+		return 0;
+	dma_flag = 0;
+	sp_udc_done(ep, req, 0);
+	is_pingbuf = 0;
+	ret = 0;
+
+	udc_write(udc_read(UDLIE) | EP2O_IF, UDLIE);
+	udc_write(udc_read(UDLIE) | EP2N_IF, UDLIE);
+	DEBUG_DBG("<<<%s...\n", __FUNCTION__);
+	return 1;
+}
+
+static int sp_ep11_bulkout_dma(struct sp_ep *ep,
+				   struct sp_request *req)
+{
+	int is_pingbuf = 0;
+	int ret = 0;
+	udc_write(udc_read(UDNBIE) & (~EP11O_IF), UDNBIE);
+	udc_write(udc_read(UDNBIE) & (~EP11N_IF), UDNBIE);
+
+_RX_BULKOUT_DATA_AGAIN:
+#ifdef MANUAL_EP11
+	if (!is_ncm && !(udc_read(UDEPBFS) & 0x22)) {
+		DEBUG_DBG("ep11 fifo not valid %x\n", udc_read(UDEPBFS));
+		udc_write(udc_read(UDNBIE) | EP11O_IF, UDNBIE);
+		udc_write(udc_read(UDNBIE) | EP11N_IF, UDNBIE);
+		return 0;
+	}
+	if (!is_ncm && !down_trylock(&ep11_sw_sem)) {
+		/*if (!sp_udc_get_ep_fifo_count((udc_read(UDEPBPPC) & CURR_BUFF) ? 1 : 0, UDEPBPIC) && !(udc_read(UDEPBFS) & 0x2))
+		      udc_write(udc_read(UDEPBPPC) | SWITCH_BUFF, UDEPBPPC);*/
+		if ((udc_read(UDEPBFS) & 0x22) == 0x20) {
+			udc_write(udc_read(UDEPBPPC) | SWITCH_BUFF, UDEPBPPC);
+		}
+		up(&ep11_sw_sem);
+	}
+#endif
+	is_pingbuf = (udc_read(UDEPBPPC) & CURR_BUFF) ? 1 : 0;
+	if (req->req.actual == 0
+	    || ((nth_len - req->req.actual) < bulkep_dma_block_size)) {
+		ret = sp_udc_ep11_bulkout_pio_with_dma(ep, req, is_pingbuf);
+		if (ret == 0) {
+			if (udc_read(UDEPBFS) & 0x22 && !dma_len)
+				goto _RX_BULKOUT_DATA_AGAIN;
+			else if (dma_len) {
+				DEBUG_DBG("bb dma=%d\n", dma_len);
+				return 0;
+			}
+			udc_write(udc_read(UDNBIE) | EP11O_IF, UDNBIE);
+			udc_write(udc_read(UDNBIE) | EP11N_IF, UDNBIE);
+
+			DEBUG_DBG("<<< sp3502_ep11_bulkout @#$ ...\n");
+			return 0;
+		} else if (ret == -1) {
+			return 0;
+		}
+	} else {
+		DEBUG_DBG("why len=%d act=%d dma_len=%d count=%d\n", nth_len,
+			  req->req.actual, dma_len,
+			  sp_udc_get_ep_fifo_count(is_pingbuf, UDEPBPIC));
+		return 0;
+	}
+	udc_write(udc_read(UDNBIE) | EP11O_IF, UDNBIE);
+	udc_write(udc_read(UDNBIE) | EP11N_IF, UDNBIE);
+	DEBUG_DBG("<<<%s...\n", __FUNCTION__);
+	return 1;
+}
+
+static int sp_ep9_bulkout_not_auto(struct sp_ep *ep,
+				       struct sp_request *req)
+{
+	int is_pingbuf = 0;
+
+	udc_write(udc_read(UDNBIE) & (~EP9O_IF), UDNBIE);
+	udc_write(udc_read(UDNBIE) & (~EP9N_IF), UDNBIE);
+
+_RX_BULKOUT_DATA_AGAIN_9:
+	if ((!sp_udc_get_ep_fifo_count(0, UDEP9PIC)
+	     && !sp_udc_get_ep_fifo_count(1, UDEP9PIC))
+	    && !(udc_read(UDEP9FS) & 0x22)) {
+		DEBUG_NOTICE("ep2 fifo not valid\n");
+		udc_write(udc_read(UDNBIE) | EP9O_IF, UDNBIE);
+		udc_write(udc_read(UDNBIE) | EP9N_IF, UDNBIE);
+		return 0;
+	}
+	is_pingbuf = (udc_read(UDEP9PPC) & CURR_BUFF) ? 1 : 0;
+	if (!sp_udc_get_ep_fifo_count(is_pingbuf, UDEP9PIC)
+	    && !(udc_read(UDEP9FS) & 0x2))
+		udc_write(udc_read(UDEP9PPC) | SWITCH_BUFF, UDEP9PPC);
+	if (sp_udc_ep9_bulkout_pio(ep, req, is_pingbuf) == 0) {
+
+		DEBUG_INFO(">>>>9 _RX_BULKOUT_DATA_AGAIN <<<<\n");
+		if (udc_read(UDEP9FS) & 0x22)
+			goto _RX_BULKOUT_DATA_AGAIN_9;
+		udc_write(udc_read(UDNBIE) | EP9O_IF, UDNBIE);
+		udc_write(udc_read(UDNBIE) | EP9N_IF, UDNBIE);
+		DEBUG_DBG("<<< %s RET 0\n", __FUNCTION__);
+		return 0;
+	}
+	udc_write(udc_read(UDNBIE) | EP9O_IF, UDNBIE);
+	udc_write(udc_read(UDNBIE) | EP9N_IF, UDNBIE);
+	DEBUG_DBG("<<< %s...\n", __FUNCTION__);
+	return 1;
+}
+
+static int sp_ep11_bulkout(struct sp_ep *ep, struct sp_request *req)
+{
+	int is_pingbuf = 0;
+
+	udc_write(udc_read(UDNBIE) & (~EP11O_IF), UDNBIE);
+	udc_write(udc_read(UDNBIE) & (~EP11N_IF), UDNBIE);
+
+_RX_BULKOUT_DATA_AGAIN_11:
+	if (!(udc_read(UDEPBFS) & 0x2)) {
+		DEBUG_DBG("ep11 fifo not valid\n");
+#ifdef CONFIG_USB_DEVICE_EP11_NOT_AUTO_SWITCH_WORKAROUND
+		if ((udc_read(UDEPBFS) & 0x22) == 0x20) {
+			udc_write(udc_read(UDEPBPPC) | SWITCH_BUFF, UDEPBPPC);
+		} else
+#endif
+		{
+			udc_write(udc_read(UDNBIE) | EP11O_IF, UDNBIE);
+			udc_write(udc_read(UDNBIE) | EP11N_IF, UDNBIE);
+			return 0;
+		}
+	}
+	is_pingbuf = (udc_read(UDEPBPPC) & CURR_BUFF) ? 1 : 0;
+	if (sp_udc_ep11_bulkout_pio(ep, req, is_pingbuf) == 0) {
+
+		DEBUG_INFO(">>>>11 _RX_BULKOUT_DATA_AGAIN <<<<\n");
+		if (udc_read(UDEPBFS) & 0x22)
+			goto _RX_BULKOUT_DATA_AGAIN_11;
+		udc_write(udc_read(UDNBIE) | EP11O_IF, UDNBIE);
+		udc_write(udc_read(UDNBIE) | EP11N_IF, UDNBIE);
+		DEBUG_DBG("<<< %s***\n", __FUNCTION__);
+		return 0;
+	}
+	udc_write(udc_read(UDNBIE) | EP11O_IF, UDNBIE);
+	udc_write(udc_read(UDNBIE) | EP11N_IF, UDNBIE);
+	DEBUG_DBG("<<< %s...\n", __FUNCTION__);
+	return 1;
+}
+
+static int sp_ep7_iso_in(struct sp_ep *ep, struct sp_request *req)
+{
+	u32 *trb;
+	struct iso_trb *trb_s;
+	DEBUG_DBG("ep7 iso %d %d\n", req->req.length, req->req.actual);
+	/*allocate the memory for all rings */
+	trb = kzalloc(ALL_TRB_SIZE, GFP_ATOMIC);	/*don't forget kfree */
+	DEBUG_DBG("00 UDADMA_CRCR=%x %p\n", udc_read(UDADMA_CRCR), trb);
+	trb = (u32 *) (((u32) (trb)) & (~0x3f));
+	udc_write(2, UDADMA_CRCR);
+	DEBUG_DBG("01 UDADMA_CRCR=%x %p\n", udc_read(UDADMA_CRCR), trb);
+	udc_write((((u32) (trb)) & RCS_0), UDADMA_CRCR);
+	udc_write((u32) trb, UDADMA_ERBAR);
+	udc_write(((u32) trb) + 4, UDADMA_ERDPR);
+
+	trb_s = (struct iso_trb *)trb;
+	/* TODO:should be dma addr*/
+	if (req->req.dma == DMA_ADDR_INVALID) {
+		req->req.dma = dma_map_single(ep->dev->gadget.dev.parent, (u8 *) req->req.buf, req->req.length, (ep->bEndpointAddress & USB_DIR_IN)
+				   ? DMA_TO_DEVICE : DMA_FROM_DEVICE);
+	}
+	trb_s->ptr = req->req.dma;	/*NOTE:should DMA addr */
+	trb_s->size_cc = 16;
+	trb_s->cmd = RCS_0 | TRB_NORMAL | TRB_IN;
+
+	udc_write(DMA_EN | 1, UDADMA_RCSR);
+	DEBUG_DBG("UDADMA_RTR will trig %x\n", udc_read(UDADMA_RTR));
+
+	udc_write(1, UDADMA_RTR);
+	return 0;
+}
+
+static void fill_trb(struct iso_trb *trb, u32 buf, u32 size, u32 flag)
+{
+	trb->ptr = __pa(buf);
+	trb->size_cc = size;
+	trb->cmd = flag;
+}
+
+int fifo_size_ep5 = 32;
+u32 cnt;
+u8 *d_p;
+u8 mo = 0;
+#define CRP_MASK	(0xffffffc0)
+#define CRP_MASK_	(0xfc0)
+
+static int sp_ep5_iso_in(struct sp_ep *ep, struct sp_request *req)
+{
+	int i = 0;
+	int count = 0;
+	u32 toggle;
+	struct sp_request *req_5;
+	int crcr_i;
+	struct iso_trb *trb_s;
+
+	if (!g_flag_ep5) {	/*debug*/
+		g_flag_ep5++;
+		DEBUG_DBG("gadget audio debug\n");
+		return 0;
+	}
+	/*udc_write(DMA_EN, UDVDMA_RCSR);*/
+	DEBUG_DBG("ep5 iso %d %d\n", req->req.length, req->req.actual);
+	if (g_flag_ep5 == 1) {
+		cnt = 0;
+		udc_write((((u32) (__pa(trb_c))) | RCS_1), UDVDMA_CRCR);
+		DEBUG_DBG("02 CRCR=%x trb_event %lu\n", udc_read(UDVDMA_CRCR),
+			  (unsigned long)__pa(trb_event));
+		udc_write(__pa(trb_event), UDVDMA_ERBAR);
+		udc_write(__pa(trb_event + 4 * (TRB_NUM - 1)), UDVDMA_ERDPR);
+		g_flag_ep5++;
+	}
+#ifdef ISO_DEBUG_INFO
+
+	if (!req->req.actual) {
+		u32 *p = (u32 *) req->req.buf;
+		for (i = 0; i < req->req.length / 4; i++) {
+			*p++ = cnt++;
+		}
+	}
+	udc_clean_dcache_range((u32)req->req.buf,
+			      (u32)__pa(req->req.buf),
+			      req->req.length);
+
+#endif
+
+ep5_start:
+	trb_s = (struct iso_trb *)trb_c;
+	toggle = ((trb_s->cmd) & RCS_1) ? 0 : RCS_1;
+	i = ((u32 *) trb_s - trb_c_start) / 4;
+	count = ep5_use;
+	crcr_i = (udc_read(UDVDMA_CRCR) & CRP_MASK_) / TRB_SIZE;
+	if (crcr_i <= i)
+		ep5_use = i - crcr_i;
+	else
+		ep5_use = (TRB_NUM - 0) - (crcr_i - i);
+	DEBUG_DBG("before i %d  used %d %d\n", i, ep5_use, crcr_i);
+	if (ep5_use == 0 && (udc_read(UDVDMA_CRCR) & CRR))
+		ep5_use = (TRB_NUM - 0);
+	else if (g_flag_ep5 == 2 && ep5_use == (TRB_NUM - 0)
+		 && !(udc_read(UDVDMA_CRCR) & CRR))
+		ep5_use = 0;
+
+	count = count - ep5_use;
+
+	if (sp_udc_list_empty(&ep_iso_5.queue, &memory.ep[5].lock)) {
+		req_5 = NULL;
+		DEBUG_DBG("ep5 queue iso is NULL!!!!!!!!!!!!\n");
+	} else
+		req_5 = list_entry(ep_iso_5.queue.next, struct sp_request, queue);
+	ep_iso_5.act += fifo_size_ep5 * count;
+	if (req_5 && ep_iso_5.act >= req_5->req.length) {
+		ep_iso_5.act -= req_5->req.length;
+		req_5->req.status = -EINPROGRESS;
+		sp_udc_done(&memory.ep[5], req_5, 0);
+
+	}
+
+	if (ep5_use >= (TRB_NUM - 0)) {
+		DEBUG_DBG("not fill trb ep5_use=%d %p %x\n", ep5_use, trb_s,
+			  udc_read(UDVDMA_CRCR));
+		goto fill_done0;
+	}
+	DEBUG_DBG("toggle=%d ep5_use %d i%d\n", toggle, ep5_use, i);
+	while (i < (TRB_NUM - 0) && ep5_use < (TRB_NUM - 0) && req->req.actual < req->req.length) {
+		trb_s->rfu = 1;
+		count = min((int)(req->req.length - req->req.actual), fifo_size_ep5);
+		if (i % 16 == 14)
+			fill_trb(trb_s, (u32) (req->req.buf + req->req.actual),
+				 count, toggle | TRB_NORMAL | TRB_IN | TRB_IOC);
+		else
+			fill_trb(trb_s, (u32) (req->req.buf + req->req.actual),
+				 count, toggle | TRB_NORMAL | TRB_IN);
+		trb_s++;
+		req->req.actual += count;
+		i++;
+		ep5_use++;
+	}
+	DEBUG_DBG("i %d  used %d\n", i, ep5_use);
+
+	trb_c = (u32 *) trb_s;
+	if (i == (TRB_NUM - 0)) {
+		trb_c = trb_c_start;
+		toggle |= TRB_TC;
+		trb_s->rfu = 1;
+		fill_trb(trb_s, (u32) trb_c, 0, toggle | TRB_LINK | TRB_IN);
+		DEBUG_DBG("trb i=%d toggle %d\n", i + 1, toggle);
+	}
+	if (trb_c == trb_c_start && ep5_use < (TRB_NUM - 0)
+	    && req->req.actual < req->req.length) {
+		goto ep5_start;
+	}
+	DEBUG_DBG("trb_c %p  trb_c_start %p\n", trb_c, trb_c_start);
+
+fill_done0:
+	udc_clean_dcache_range((u32)trb_c_start, __pa(trb_c_start),
+			      ALL_TRB_SIZE);
+	if (udc_read(UDVDMA_CRCR) & CRR)
+		goto fill_done;
+	/*if (g_flag_ep5 == 2){
+		DEBUG_DBG("fill trb num\n");*/
+	g_flag_ep5++;
+	udc_write(DMA_EN | (TRB_NUM - 0), UDVDMA_RCSR);
+	DEBUG_DBG("UDADMA_RTR will trig %x\n", udc_read(UDVDMA_RTR));
+
+	udc_write(1, UDVDMA_RTR);
+	DEBUG_DBG("%x\n", udc_read(UDVDMA_RTR));
+	DEBUG_DBG("%x\n", udc_read(UDVDMA_RTR));
+	DEBUG_DBG("hw %x %x %x %x \n", udc_read(0xb0), udc_read(0xb4),
+		  udc_read(0xb8), udc_read(0xbc));
+	DEBUG_DBG("UDADMA_RTR after trig %x CRCR %x\n", udc_read(UDVDMA_RTR),
+		  udc_read(UDVDMA_CRCR));
+	DEBUG_DBG("act may %x len %x \n", req->req.actual, req->req.length);
+fill_done:
+	if (req->req.actual >= req->req.length) {
+		DEBUG_DBG("ep5 done=1\n");
+		ep_iso_done(ep, req, 1);
+		return 1;
+	} else {
+		DEBUG_DBG("ep5 done=0\n");
+		return 0;
+	}
+}
+
+static int sp_epc_iso_out(struct sp_ep *ep, struct sp_request *req)
+{
+	int i = 0;
+	int count = 0;
+	u32 toggle;
+	struct iso_trb *trb_s;
+
+	DEBUG_DBG("epc iso l %d a %d\n", req->req.length, req->req.actual);
+	if (!g_flag_ep12) {	/*debug*/
+		g_flag_ep12++;
+		DEBUG_NOTICE("epc gadget debug\n");
+		return 0;
+	}
+#ifdef ISO_DEBUG_INFO
+	if (!req->req.actual) {
+		memset(req->req.buf, 0xfa, req->req.length);
+		udc_clean_dcache_range((u32)req->req.buf,
+				      __pa(req->req.buf), req->req.length);
+	}
+#endif
+	if (g_flag_ep12 == 1) {
+		udc_write((((u32) (__pa(trb_c_12))) | RCS_1), UDEPCDMA_CRCR);
+		DEBUG_DBG("02 CRCR=%x trb_event %lu\n", udc_read(UDEPCDMA_CRCR),
+			  (unsigned long)__pa(trb_event_12));
+		udc_write(__pa(trb_event_12), UDEPCDMA_ERBAR);
+		udc_write(__pa(trb_event_12), UDEPCDMA_ERDPR);
+		g_flag_ep12++;
+	}
+ep12_start:
+	trb_s = (struct iso_trb *)trb_c_12;
+	toggle = ((trb_s->cmd) & RCS_1) ? 0 : RCS_1;
+	i = ((u32 *) trb_s - trb_c_start_12) / 4;
+	ep12_use = (((u32) trb_s + 0x1000 - (udc_read(UDEPCDMA_CRCR) & CRP_MASK)) / TRB_SIZE) % TRB_NUM;
+	if (!ep12_use && (udc_read(UDEPCDMA_CRCR) & CRR))
+		ep12_use = 256;
+	if (ep12_use >= 255) {
+		DEBUG_DBG("not fill trb ep12_use=%d %p %x\n", ep12_use, trb_s,
+			  udc_read(UDEPCDMA_CRCR));
+		goto fill_done0;
+	}
+	DEBUG_DBG("i %d toggle=%d used %d\n", i, toggle, ep12_use);
+	while (i < 255 && ep12_use < 255 && req->req.actual < req->req.length) {
+		trb_s->rfu = 1;
+		count = min((int)(req->req.length - req->req.actual), (int)EPC_FIFO_SIZE);
+		if (i % 16 == 14)
+			fill_trb(trb_s, (u32) (req->req.buf + req->req.actual),
+				 count, toggle | TRB_NORMAL | TRB_IOC);
+		else
+			fill_trb(trb_s, (u32) (req->req.buf + req->req.actual),
+				 count, toggle | TRB_NORMAL);
+		trb_s++;
+		req->req.actual += count;
+		i++;
+		ep12_use++;
+	}
+	DEBUG_DBG("i %d  used %d\n", i, ep12_use);
+	trb_c_12 = (u32 *) trb_s;
+	if (i == 255) {
+		trb_c_12 = trb_c_start_12;
+		toggle |= TRB_TC;
+		trb_s->rfu = 1;
+		fill_trb(trb_s, (u32) trb_c_12, 0, toggle | TRB_LINK);
+		DEBUG_DBG("i=%d toggle %d\n", i + 1, toggle);
+	}
+	if (trb_c_12 == trb_c_start_12 && ep12_use < 255
+	    && req->req.actual < req->req.length) {
+		goto ep12_start;
+	}
+	DEBUG_DBG("trb_c %p  trb_c_start %p\n", trb_c_12, trb_c_start_12);
+fill_done0:
+	udc_clean_dcache_range((u32)trb_c_start_12,
+			      __pa(trb_c_start_12), ALL_TRB_SIZE);
+	if (udc_read(UDEPCDMA_CRCR) & CRR)
+		goto fill_done;
+	udc_write(DMA_EN | (TRB_NUM - 1), UDEPCDMA_RCSR);
+	DEBUG_DBG("UDADMA_RTR will trig %x\n", udc_read(UDEPCDMA_RTR));
+	DEBUG_DBG("UDADMA_RTR after trig %x CRCR %x\n", udc_read(UDEPCDMA_RTR),
+		  	udc_read(UDEPCDMA_CRCR));
+	DEBUG_DBG("act may %x len %x \n", req->req.actual, req->req.length);
+fill_done:
+	if (req->req.actual == req->req.length) {
+		DEBUG_DBG("epC done=1\n");
+		ep_iso_done(ep, req, 1);
+		return 1;
+	} else {
+		DEBUG_DBG("epC done=0\n");
+		return 0;
+	}
+}
+
+#if 0
+static void event_ring_show(void)
+{
+	struct iso_trb *trb_event;
+
+	trb_event = (struct iso_trb *)udc_read(UDVDMA_ERDPR);
+	DEBUG_DBG("trb %x\n", *((u32 *) (__va(trb_event))));
+}
+#endif
+
+#ifdef INT_TEST
+static void iso_complete(struct usb_ep *ep, struct usb_request *req);
+#endif
+static int sp_ep3_int_in(struct sp_ep *ep, struct sp_request *req)
+{
+	int count;
+#ifdef INT_TEST
+	static int vary_len = 0;
+	vary_len++;
+	if (vary_len == 65)
+		vary_len = 1;
+	ep->ep.maxpacket = vary_len;	/* int test */
+#endif
+	count = sp_udc_write_packet(UDEP3DATA, req, ep->ep.maxpacket, UDEP3VB);
+	udc_write((1 << 0) | (1 << 3), UDEP3CTRL);
+	req->req.actual += count;
+	if (req->req.actual == req->req.length)
+#ifdef INT_TEST
+		iso_complete(&ep->ep, &req->req);
+#else
+		sp_udc_done(ep, req, 0);
+#endif
+	return 1;
+}
+
+static void ep1_handle(struct sp_udc *dev)
+{
+	struct sp_ep *ep = &memory.ep[1];
+	struct sp_request *req;
+	int ret = 0;
+
+	DEBUG_DBG(">>> %s\n", __FUNCTION__);
+	if (dma_len_ep1)
+		return;
+	do {
+		if (down_trylock(&ep1_ack_sem)) {
+			DEBUG_DBG("[%s:%d] error [0x%x]\n", __FUNCTION__,
+				  __LINE__, udc_read(UDEP12FS));
+			udc_write(0, UDEP1INAKCN);
+			return;
+		}
+		if (sp_udc_list_empty(&ep->queue, &ep->lock)) {
+			up(&ep1_ack_sem);
+			DEBUG_DBG( "null 1 unlock >>\n");
+			req = NULL;
+			DEBUG_DBG("ep1 req is NULL!\n");
+			return;
+		} else
+			req = list_entry(ep->queue.next, struct sp_request, queue);
+
+		if ((udc_read(UDEP12FS) & 0x1) != 0x1 && req) {
+#ifdef EP1_DMA
+			if (is_vera)
+				ret = sp_ep1_bulkin(ep, req);
+			else
+				ret = sp_ep1_bulkin_dma(ep, req);
+#else
+			ret = sp_ep1_bulkin(ep, req);
+#endif
+		}
+		up(&ep1_ack_sem);
+		DEBUG_DBG("1 unlock >>\n");
+	} while (ret && ((udc_read(UDEP12FS) & 0x1) != 0x1));
+
+	DEBUG_DBG("<<< %s\n", __FUNCTION__);
+	return;
+}
+
+#ifdef CONFIG_USB_SUNPLUS_EP1
+static void sp_udc_ep1_work(void)
+{
+	struct sp_ep *ep = &memory.ep[1];
+	struct sp_request *req;
+	int ret = 0;
+
+	DEBUG_DBG(">>> %s\n", __FUNCTION__);
+	do {
+		if (down_trylock(&ep1_ack_sem)) {
+			DEBUG_DBG("[%s:%d] error [0x%x]\n", __FUNCTION__,
+				  __LINE__, udc_read(UDEP12FS));
+			udc_write(0, UDEP1INAKCN);
+			return;
+		}
+
+		if (sp_udc_list_empty(&ep->queue, &ep->lock)) {
+			up(&ep1_ack_sem);
+			DEBUG_DBG("null 1 unlock >>\n");
+			req = NULL;
+			DEBUG_DBG("ep1 req is NULL!\n");
+			/*udc_write(udc_read(UDLIE)|EP1I_IF, UDLIE);*/
+			return;
+		} else
+			req = list_entry(ep->queue.next, struct sp_request, queue);
+
+		if (((udc_read(UDEP12FS) & 0x1) != 0x1) && req) {
+#ifdef EP1_DMA
+			if (is_vera)
+				ret = sp_ep1_bulkin(ep, req);
+			else
+				ret = sp_ep1_bulkin_dma(ep, req);
+#else
+			ret = sp_ep1_bulkin(ep, req);
+#endif
+		}
+		up(&ep1_ack_sem);
+		DEBUG_DBG("1 unlock >>\n");
+	} while (ret && ((udc_read(UDEP12FS) & 0x1) != 0x1));
+
+	DEBUG_DBG("<<< %s\n", __FUNCTION__);
+	return;
+}
+
+#endif
+
+static void ep2_handle(struct sp_udc *dev)
+{
+	struct sp_ep *ep = &memory.ep[2];
+	struct sp_request *req;
+	int ret = 0;
+
+	if (dma_flag)
+		return;
+	do {
+		if (sp_udc_list_empty(&ep->queue, &ep->lock)) {
+			req = NULL;
+			DEBUG_DBG("\tep2 req is NULL\t!\n");
+			udc_write(udc_read(UDLIE) | EP2O_IF, UDLIE);
+			udc_write(udc_read(UDLIE) | EP2N_IF, UDLIE);
+			return;
+		} else
+			req = list_entry(ep->queue.next, struct sp_request, queue);
+
+		DEBUG_DBG("length=0x%x actual=0x%x\n",req->req.length,req->req.actual);
+		DEBUG_DBG("ep2 lock >>>\t!\n");
+		if (down_trylock(&ep12_bulk_out_ack_sem)) {
+			DEBUG_DBG("[%s:%d] error [0x%x]\n", __FUNCTION__,
+				  __LINE__, udc_read(UDEP2FS));
+			return;
+		}
+		ret = sp_ep2_bulkout_dma(ep, req);	/*test dma use*/
+		up(&ep12_bulk_out_ack_sem);
+		DEBUG_DBG("\t<<< ep2 unlock! ret=%d\n", ret);
+	} while (ret && (udc_read(UDEP2FS) & 0x22));
+	return;
+}
+
+static void ep9_handle(struct sp_udc *dev)
+{
+	struct sp_ep *ep = &memory.ep[9];
+	struct sp_request *req;
+	int ret = 0;
+
+	do {
+		if (sp_udc_list_empty(&ep->queue, &ep->lock)) {
+			req = NULL;
+			DEBUG_DBG("\tep9 req is NULL\t!\n");
+			udc_write(udc_read(UDNBIE) | EP9O_IF, UDNBIE);
+			udc_write(udc_read(UDNBIE) | EP9N_IF, UDNBIE);
+			return;
+		} else
+			req = list_entry(ep->queue.next, struct sp_request, queue);
+
+		DEBUG_DBG("length=0x%x actual=0x%x\n",req->req.length,req->req.actual);
+		DEBUG_DBG("ep9 lock >>>\t!\n");
+		if (down_trylock(&ep9_ack_sem)) {
+			DEBUG_DBG("[%s:%d] error [0x%x]\n", __FUNCTION__,
+				  __LINE__, udc_read(UDEP9FS));
+			return;
+		}
+		ret = sp_ep9_bulkout_not_auto(ep, req);
+		up(&ep9_ack_sem);
+		DEBUG_DBG("\t<<< ep9 unlock! ret=%d fs %x\n", ret,
+			  udc_read(UDEP9FS));
+	} while (ret && (udc_read(UDEP9FS) & 0x22));
+	return;
+}
+
+static void ep11_handle(struct sp_udc *dev)
+{
+	struct sp_ep *ep = &memory.ep[11];
+	struct sp_request *req;
+	int ret = 0;
+
+	if (dma_flag_b)
+		return;
+	do {
+		DEBUG_DBG("ep11 lock >>>\t!\n");
+		if (down_trylock(&ep11_ack_sem)) {
+			DEBUG_DBG("[%s:%d] error [0x%x]\n", __FUNCTION__, __LINE__, udc_read(UDEPBFS));
+			udc_write(udc_read(UDNBIE) | EP11N_IF, UDNBIE);
+			udc_write(0, UDEPBONAKCN);
+			return;
+		}
+		if (sp_udc_list_empty(&ep->queue, &ep->lock)) {
+			req = NULL;
+			up(&ep11_ack_sem);
+			DEBUG_DBG("\tep11 req is NULL\t!\n");
+			udc_write(udc_read(UDNBIE) | EP11O_IF, UDNBIE);
+			udc_write(udc_read(UDNBIE) | EP11N_IF, UDNBIE);
+			return;
+		} else
+			req = list_entry(ep->queue.next, struct sp_request, queue);
+		if (dma_fail) {
+			ret = sp_ep11_bulkout(ep, req);
+		} else {
+			ret = sp_ep11_bulkout_dma(ep, req);
+		}
+
+		up(&ep11_ack_sem);
+		DEBUG_DBG("\t<<< ep11 unlock! ret=%d\n", ret);
+	} while (ret && (udc_read(UDEPBFS) & 0x22));
+	return;
+}
+
+static void sp_udc_ep9_work(struct work_struct *work)
+{
+	struct sp_udc *udc = the_controller;
+
+	if(udc){
+		ep9_handle(udc);
+	}
+
+	return;
+}
+
+
+
+#ifdef CONFIG_USB_SUNPLUS_EP11
+static void sp_udc_ep11_work(void)
+{
+	struct sp_ep *ep = &memory.ep[11];
+	struct sp_request *req;
+	int ret = 0;
+
+	if (dma_flag_b) {
+#ifdef MANUAL_EP11
+		if (!is_ncm && !is_vera) {
+			if (!down_trylock(&ep11_sw_sem)) {
+
+				if ((udc_read(UDEPBFS) & 0x22) == 0x20) {
+					if ((udc_read(UDEPBDMACS) & (UDC_FLASH_BUFFER_SIZE - 1)) > 0)	/*verB DMA bug*/
+						udc_write(udc_read(UDEPBPPC) | SWITCH_BUFF, UDEPBPPC);
+				} else {
+					/*udc_write(1 ,UDEPBONAKCN);*/
+				}
+				up(&ep11_sw_sem);
+			}
+		}
+#endif
+		return;
+	}
+	do {
+		DEBUG_DBG("ep11 lock >>>\t!\n");
+		if (down_trylock(&ep11_ack_sem)) {
+			DEBUG_DBG("[%s:%d] error [0x%x]\n", __FUNCTION__, __LINE__, udc_read(UDEPBFS));
+			udc_write(udc_read(UDNBIE) | EP11N_IF, UDNBIE);
+			udc_write(0, UDEPBONAKCN);
+			return;
+		}
+		if (sp_udc_list_empty(&ep->queue, &ep->lock)) {
+			req = NULL;
+			up(&ep11_ack_sem);
+			DEBUG_DBG("\tep11 req is NULL\t!\n");
+			udc_write(udc_read(UDNBIE) | EP11O_IF, UDNBIE);
+			udc_write(udc_read(UDNBIE) | EP11N_IF, UDNBIE);
+			return;
+		} else
+			req = list_entry(ep->queue.next, struct sp_request, queue);
+
+
+		if (dma_fail) {
+			ret = sp_ep11_bulkout(ep, req);
+		} else {
+			ret = sp_ep11_bulkout_dma(ep, req);
+		}
+		up(&ep11_ack_sem);
+		DEBUG_DBG("\t<<< ep11 unlock! ret=%d\n", ret);
+	} while (ret && (udc_read(UDEPBFS) & 0x22));
+	return;
+}
+#endif
+static void debug_ep_out(void)
+{
+	struct sp_ep *ep = &memory.ep[9];
+	struct sp_request *req;
+	int ret = 0;
+
+	if (sp_udc_list_empty(&ep->queue, &ep->lock)) {
+		req = NULL;
+		DEBUG_DBG("\tep9 req is NULL\t!\n");
+		udc_write(udc_read(UDNBIE) | EP9O_IF, UDNBIE);
+		udc_write(udc_read(UDNBIE) | EP9N_IF, UDNBIE);
+		return;
+	} else
+		req = list_entry(ep->queue.next, struct sp_request, queue);
+
+	DEBUG_DBG("ep9 lock >>>\t!\n");
+	if (down_trylock(&ep9_ack_sem)) {
+		DEBUG_DBG("[%s:%d] error [0x%x]\n", __FUNCTION__, __LINE__,
+			  udc_read(UDEP9FS));
+		return;
+	}
+	ret = (udc_read(UDEP9PPC) & CURR_BUFF) ? 1 : 0;
+	DEBUG_DBG("ep out debug %d %x %x\n", ret,
+		  sp_udc_get_ep_fifo_count(0, UDEP9PIC),
+		  sp_udc_get_ep_fifo_count(1, UDEP9PIC));
+	up(&ep9_ack_sem);
+	DEBUG_DBG("\t<<< ep9 unlock! ret=%d fs %x\n", ret, udc_read(UDEP9FS));
+	return;
+}
+
+static void ep1_dma_handle(struct sp_udc *dev)
+{
+	struct sp_ep *ep = &memory.ep[1];
+	struct sp_request *req;
+	int ret;
+	if (down_trylock(&ep1_dma_sem)) {
+		DEBUG_ERR("[%s:%d] error\n", __FUNCTION__, __LINE__);
+		return;
+	}
+	if (sp_udc_list_empty(&ep->queue, &ep->lock)) {
+		req = NULL;
+		up(&ep1_dma_sem);
+		DEBUG_ERR("\tep1_dma req is NULL\t!\n");
+		return;
+	} else
+		req = list_entry(ep->queue.next, struct sp_request, queue);
+	if (req->req.actual != 0) {
+		DEBUG_ERR("WHY ep1\n");
+		if (req->req.actual != req->req.length) {
+			up(&ep1_dma_sem);
+			return;
+		}
+	}
+	req->req.actual += dma_len_ep1;
+	if (req->req.dma != DMA_ADDR_INVALID) {
+		dma_unmap_single(ep->dev->gadget.dev.parent, req->req.dma, dma_len_ep1,
+				(ep->bEndpointAddress & USB_DIR_IN)
+				 ? DMA_TO_DEVICE : DMA_FROM_DEVICE);
+
+		req->req.dma = DMA_ADDR_INVALID;
+	}
+
+	if (req->req.length == req->req.actual && !req->req.zero) {
+		sp_udc_done(ep, req, 0);
+		dma_len_ep1 = 0;
+		if (!(udc_read(UDEP12FS) & 0x1)){
+			ep1_handle(dev);
+		}
+		DEBUG_DBG("ep1 dma: %d\n", udc_read(UDEP12FS));
+		up(&ep1_dma_sem);
+		return;
+	}
+	if (!(udc_read(UDEP12FS) & 0x1)) {
+		udc_write(EP1N_IF, UDLIF);
+		ret = sp_udc_write_packet(UDEP12FDP, req, ep->ep.maxpacket, UDEP12VB);
+		udc_write(udc_read(UDEP12C) | SET_EP_IVLD, UDEP12C);
+		req->req.actual += ret;
+		sp_udc_done(ep, req, 0);
+		DEBUG_DBG("DMA->write fifo by pio count=%d!\n", ret);
+	} else {
+		DEBUG_DBG("\twait DMA->write fifo by pio!\n\n");
+	}
+	dma_len_ep1 = 0;
+	up(&ep1_dma_sem);
+	udc_write(udc_read(UDLIE) | EP1I_IF | EP1N_IF, UDLIE);
+	return;
+}
+
+static void ep2_dma_handle(struct sp_udc *dev)
+{
+	struct sp_ep *ep = &memory.ep[2];
+	struct sp_request *req;
+
+	if (down_trylock(&ep12_bulk_out_nak_sem)) {
+		DEBUG_ERR("[%s:%d] error\n", __FUNCTION__, __LINE__);
+		return;
+	}
+	if (sp_udc_list_empty(&ep->queue, &ep->lock)) {
+		req = NULL;
+		DEBUG_DBG("\tep2_dma req is NULL\t!\n");
+		up(&ep12_bulk_out_nak_sem);
+		return;
+	} else
+		req = list_entry(ep->queue.next, struct sp_request, queue);
+	if (nth_len - req->req.actual < bulkep_dma_block_size) {
+		up(&ep12_bulk_out_nak_sem);
+		return;
+	}
+	if (!req->req.actual)
+		DEBUG_ERR("why act=0?\n");
+	req->req.actual += dma_len;
+	dma_len = 0;
+	if (req->req.dma != DMA_ADDR_INVALID) {
+		dma_unmap_single(ep->dev->gadget.dev.parent, req->req.dma, (req->req.length - req->req.actual), (ep->bEndpointAddress & USB_DIR_IN)
+				 ? DMA_TO_DEVICE : DMA_FROM_DEVICE);
+		req->req.dma = DMA_ADDR_INVALID;
+	}
+
+	udc_write(udc_read(UDCIE) & (~EP2_DMA_IF), UDCIE);
+	if (req->req.length == req->req.actual || req->req.actual == nth_len) {
+		sp_udc_done(ep, req, 0);
+	}
+	dma_flag = 0;
+	up(&ep12_bulk_out_nak_sem);
+	udc_write(udc_read(UDLIE) | EP2O_IF, UDLIE);
+	udc_write(udc_read(UDLIE) | EP2N_IF, UDLIE);
+
+	if (udc_read(UDEP2FS) & 0x22) {
+		ep2_handle(dev);
+	}
+	DEBUG_DBG("DMA finished!...\n");
+	return;
+}
+
+#if 0
+static void ep11_dma_work(struct work_struct *work)
+{
+	struct sp_ep *ep = &memory.ep[11];
+	struct sp_request *req;
+
+	if (down_trylock(&ep11_dma_sem)) {
+		DEBUG_ERR("[%s:%d] error\n", __FUNCTION__, __LINE__);
+		return;
+	}
+	if (sp_udc_list_empty(&ep->queue, &ep->lock)) {
+		req = NULL;
+		DEBUG_DBG("\tep11_dma req is NULL\t!\n");
+		up(&ep11_dma_sem);
+		return;
+	} else
+		req = list_entry(ep->queue.next, struct sp_request, queue);
+	if (nth_len - req->req.actual < bulkep_dma_block_size) {
+		up(&ep11_dma_sem);
+		return;
+	}
+	if (!req->req.actual)
+		DEBUG_ERR("why act=0?\n");
+
+	req->req.actual += dma_len;
+	dma_len = 0;
+	dma_flag_b = 0;
+	if (req->req.dma != DMA_ADDR_INVALID) {
+		dma_unmap_single(ep->dev->gadget.dev.parent, req->req.dma,
+				(req->req.length - req->req.actual),
+				(ep->bEndpointAddress & USB_DIR_IN)
+				 ? DMA_TO_DEVICE : DMA_FROM_DEVICE);
+
+		req->req.dma = DMA_ADDR_INVALID;
+	}
+
+	udc_write(udc_read(UDCIE) & (~EPB_DMA_IF), UDCIE);
+	if (req->req.length == req->req.actual || req->req.actual == nth_len) {
+		sp_udc_done(ep, req, 0);
+	}
+
+	up(&ep11_dma_sem);
+	udc_write(udc_read(UDNBIE) | EP11O_IF, UDNBIE);
+	udc_write(udc_read(UDNBIE) | EP11N_IF, UDNBIE);
+
+	if (udc_read(UDEPBFS) & 0x22) {
+		ep11_handle(NULL);
+	}
+	DEBUG_DBG("DMA 11 finished!...\n");
+	return;
+}
+#endif
+
+static void ep11_dma_handle(struct sp_udc *dev)
+{
+	struct sp_ep *ep = &memory.ep[11];
+	struct sp_request *req;
+
+	DEBUG_INFO("<<< %s\n", __FUNCTION__);
+	if (down_trylock(&ep11_dma_sem)) {
+		DEBUG_ERR("[%s:%d] error\n", __FUNCTION__, __LINE__);
+		return;
+	}
+	if (sp_udc_list_empty(&ep->queue, &ep->lock)) {
+		req = NULL;
+		DEBUG_DBG("\tep11_dma req is NULL\t!\n");
+		up(&ep11_dma_sem);
+		return;
+	} else
+		req = list_entry(ep->queue.next, struct sp_request, queue);
+	if (nth_len - req->req.actual < bulkep_dma_block_size) {
+		up(&ep11_dma_sem);
+		return;
+	}
+	if (!req->req.actual)
+		DEBUG_ERR("why act=0?\n");
+
+	req->req.actual += dma_len;
+	if (req->req.dma != DMA_ADDR_INVALID) {
+		dma_unmap_single(ep->dev->gadget.dev.parent, req->req.dma, (req->req.length - req->req.actual), (ep->bEndpointAddress & USB_DIR_IN)
+				 ? DMA_TO_DEVICE : DMA_FROM_DEVICE);
+		req->req.dma = DMA_ADDR_INVALID;
+	}
+
+	udc_write(udc_read(UDCIE) & (~EPB_DMA_IF), UDCIE);
+	if (req->req.length == req->req.actual || req->req.actual == nth_len) {
+		sp_udc_done(ep, req, 0);
+	}
+	dma_len = 0;
+	dma_flag_b = 0;
+	up(&ep11_dma_sem);
+	udc_write(udc_read(UDNBIE) | EP11O_IF, UDNBIE);
+	udc_write(udc_read(UDNBIE) | EP11N_IF, UDNBIE);
+
+	if (udc_read(UDEPBFS) & 0x22) {
+#ifdef CONFIG_USB_SUNPLUS_EP11
+		sp_udc_ep11_work();
+#else
+		ep11_handle(dev);
+#endif
+	}
+	DEBUG_INFO(">>> %s\n", __FUNCTION__);
+	return;
+}
+
+static void ep3_handle(struct sp_udc *dev)
+{
+	struct sp_ep *ep = &memory.ep[3];
+	struct sp_request *req;
+	if (list_empty(&ep->queue)) {
+		req = NULL;
+		DEBUG_DBG("ep3 req is NULL!!!!!!!!!!!!\n");
+		return;
+	} else
+		req = list_entry(ep->queue.next, struct sp_request, queue);
+	DEBUG_DBG("length=0x%x actual=0x%x \n", req->req.length,
+		  req->req.actual);
+	sp_ep3_int_in(ep, req);
+	return;
+}
+
+static void sp_udc_ep3_work(struct work_struct *work)
+{
+	struct sp_udc *udc = the_controller;
+
+	if(udc){
+		ep3_handle(udc);
+	}
+
+	return;
+}
+
+static void ep5_event_handle(void)
+{
+	int i = 0;
+	struct iso_trb *trb = (struct iso_trb *)trb_event;
+	struct sp_request *req;
+
+	if (sp_udc_list_empty(&ep_iso_5.queue, &memory.ep[5].lock)) {
+		req = NULL;
+		DEBUG_DBG("ep5 queue iso is NULL!!!!!!!!!!!!\n");
+	} else
+		req = list_entry(ep_iso_5.queue.next, struct sp_request, queue);
+	udc_invalidate_dcache_range((u32)trb_event, __pa(trb_event), TRB_NUM * 16);
+	do {
+		if ((trb[ep5_e].cmd & RCS_1) == tog) {
+			ep5_e++;
+			i++;
+		} else {
+			DEBUG_DBG("%d not %x %x\n", ep5_e, tog,
+				  (trb[ep5_e].cmd & RCS_1));
+		}
+
+		if (ep5_e == (TRB_NUM - 0)) {
+			ep5_e = 0;
+			if (i)
+				tog = tog ? 0 : 1;
+		}
+	} while (((trb[ep5_e].cmd & RCS_1) == tog) && i < 91);
+	DEBUG_DBG("e%d i%d trb event tog %x C %x\n", ep5_e, i, tog,
+		  (trb[ep5_e].cmd & RCS_1));
+
+	if (ep5_e)
+		udc_write(__pa(trb_event + ep5_e * 4), UDVDMA_ERDPR);
+}
+
+static void ep5_handle(struct sp_udc *dev)
+{
+	struct sp_ep *ep = &memory.ep[5];
+	struct sp_request *req;
+
+	ep5_event_handle();
+
+	if (sp_udc_list_empty(&ep->queue, &ep->lock)) {
+		req = NULL;
+		DEBUG_DBG("ep5 req is NULL!!!!!!!!!!!!\n");
+		return;
+	} else
+		req = list_entry(ep->queue.next, struct sp_request, queue);
+	DEBUG_DBG("ep5_handle length=0x%x actual=0x%x \n", req->req.length,
+		  req->req.actual);
+	if (sp_udc_list_empty(&ep_iso_5.queue, &memory.ep[5].lock)) {
+		DEBUG_DBG("test ep5 queue iso is NULL!!!!!!!!!!!!\n");
+	} else
+		DEBUG_DBG("test ep5 queue iso\n");
+	sp_ep5_iso_in(ep, req);
+	return;
+}
+
+static void epc_event_handle(void)
+{
+	struct iso_trb *trb = (struct iso_trb *)trb_event_12;
+	struct sp_request *req;
+	int i = 0;
+	if (list_empty(&ep_iso_12.queue)) {
+		req = NULL;
+		DEBUG_DBG("epc queue iso is NULL!!!!!!!!!!!!\n");
+	} else
+		req = list_entry(ep_iso_12.queue.next, struct sp_request, queue);
+	udc_invalidate_dcache_range((u32)trb_event_12, __pa(trb_event_12), TRB_NUM * 16);
+	do {
+		if ((trb[ep12_e].cmd & RCS_1) == tog_12) {
+			ep12_e++;
+			i++;
+			ep_iso_12.act += EPC_FIFO_SIZE;
+			if (req && ep_iso_12.act >= req->req.length) {
+				ep_iso_12.act = 0;
+				req->req.status = -EINPROGRESS;
+				udc_invalidate_dcache_range((u32)req->
+							   req.buf,
+							   __pa(req->req.buf),
+							   req->req.length);
+				PrintBlock_usb(req->req.buf, req->req.length);
+				/*PrintBlock_usb(req->req.buf+512*7, 512);*/
+				sp_udc_done(&memory.ep[12], req, 0);
+			}
+		} else {
+			DEBUG_DBG("epC %d not %x %x a %d\n", ep12_e, tog_12,
+				  (trb[ep12_e].cmd & RCS_1), ep_iso_12.act);
+			if (req)
+				DEBUG_DBG("epC buf %p\n", req->req.buf);
+		}
+
+		if (ep12_e == TRB_NUM - 1) {
+			ep12_e = 0;
+			if (i)
+				tog_12 = tog_12 ? 0 : 1;
+		}
+	} while ((trb[ep12_e].cmd & RCS_1) == tog_12);
+	DEBUG_DBG("epc e%d trb event tog %x C %x\n", ep12_e, tog_12,
+		  (trb[ep12_e].cmd & RCS_1));
+	if (ep12_e)
+		udc_write(__pa(trb_event_12 + ep12_e * 4), UDEPCDMA_ERDPR);
+}
+
+static void epc_handle(struct sp_udc *dev)
+{
+	struct sp_ep *ep = &memory.ep[12];
+	struct sp_request *req;
+	epc_event_handle();
+	if (list_empty(&ep->queue)) {
+		req = NULL;
+		DEBUG_DBG("epc req is NULL!!!!!!!!!!!!\n");
+		return;
+	} else
+		req = list_entry(ep->queue.next, struct sp_request, queue);
+	DEBUG_DBG("length=0x%x actual=0x%x \n", req->req.length,
+		  req->req.actual);
+	/*udc_invalidate_dcache_range((u32)req->req.buf, __pa(req->req.buf), req->req.length);
+	PrintBlock_usb(req->req.buf,512);*/
+	sp_epc_iso_out(ep, req);
+	return;
+}
+
+#ifdef INT_TEST
+static void iso_complete(struct usb_ep *ep, struct usb_request *req)
+{
+	DEBUG_NOTICE("iso_complete\n");
+}
+
+#define ISO_LEN 16384
+static struct usb_request *alloc_ep_req(struct usb_ep *ep)
+{
+	struct usb_request *req;
+
+	req = usb_ep_alloc_request(ep, GFP_ATOMIC);
+	if (req) {
+		req->length = ISO_LEN;
+		req->buf = kmalloc(ISO_LEN, GFP_ATOMIC);
+		if (!req->buf) {
+			usb_ep_free_request(ep, req);
+			req = NULL;
+		}
+	}
+	return req;
+}
+
+static struct sp_request *new_req(struct sp_ep *ep)
+{
+	struct usb_request *req;
+	unsigned i;
+	u8 *buf;
+	req = alloc_ep_req(&ep->ep);
+	req->complete = iso_complete;
+
+	buf = req->buf;
+	for (i = 0; i < req->length; i++)
+		*buf++ = (u8) (i % 63);
+	return to_sp_req(req);
+}
+#endif
+#ifdef INT_TEST
+static void ep3_handle_test(struct sp_udc *dev)
+{
+	struct sp_ep *ep = &memory.ep[3];
+	struct sp_request *req;
+	if (list_empty(&ep->queue)) {
+		DEBUG_ERR("ep3 req is NULL ! create req ! !!!!!!\n");
+		req = new_req(ep);
+		list_add_tail(&req->queue, &ep->queue);
+	}
+	req = list_entry(ep->queue.next, struct sp_request, queue);
+	DEBUG_DBG("%x length=0x%x actual=0x%x \n", udc_read(UDEP3CTRL),
+		  req->req.length, req->req.actual);
+	sp_ep3_int_in(ep, req);
+	return;
+}
+#endif
+
+static void ep8_handle(struct sp_udc *dev)
+{
+	struct sp_ep *ep = &memory.ep[8];
+	struct sp_request *req;
+	if (sp_udc_list_empty(&ep->queue, &ep->lock)) {
+		req = NULL;
+		DEBUG_DBG("ep8 req is NULL!\n");
+		return;
+	} else
+		req = list_entry(ep->queue.next, struct sp_request, queue);
+	if (udc_read(UDEP89FS) != 0x11)
+		sp_ep8_bulkin(ep, req);
+	return;
+}
+
+static irqreturn_t sp_udc_irq(int irq, void *_dev)
+{
+	u32 udc_irq_flags;
+	u32 udc_irq_en1;
+	u32	udc_irq_en2;
+	u32 udc_epnb_irq_flags;
+	/*u32 udc_epnb_irq_en;*/
+	u32 irq_en1_flags;
+	u32 irq_en2_flags;
+	unsigned long flags;
+	struct sp_udc *dev = (struct sp_udc *)_dev;
+
+	spin_lock_irqsave(&dev->lock, flags);
+
+	udc_irq_flags = udc_read(UDCIF);
+	udc_irq_en1 = udc_read(UDCIE);
+	udc_irq_en2 = udc_read(UDLIF);
+
+	udc_epnb_irq_flags = udc_read(UDNBIF);
+	/*udc_epnb_irq_en = udc_read(UDNBIE);*/
+
+	/*DEBUG_DBG(">irq IF:0x%x IE:0x%x udc IF:0x%x IE=0x%x\n",
+		udc_read(UDLIF), udc_read(UDLIE), udc_read(UDCIF), udc_read(UDCIE));*/
+	irq_en1_flags = udc_irq_flags & udc_irq_en1;
+	irq_en2_flags = udc_read(UDLIE) & udc_irq_en2;
+	if (irq_en2_flags & RESET_RELEASE_IF) {
+		udc_write(RESET_RELEASE_IF, UDLIF);
+		DEBUG_NOTICE("reset end irq\n");
+	}
+	/* force disconnect interrupt */
+	if (irq_en1_flags & VBUS_IF) {
+		DEBUG_DBG("vbus_irq[%x]\n",udc_read(UDLCSET));
+		udc_write(VBUS_IF, UDCIF);
+		vbusInt_handle();
+	}
+	if (irq_en1_flags & VIDEO_TRB_IF) {
+		DEBUG_DBG("IRQ:VIDEO_TRB_IF\n");
+		udc_write(VIDEO_TRB_IF, UDCIF);
+		DEBUG_DBG("CRCR %x base %x dequeue %x\n", udc_read(UDVDMA_CRCR),
+			  udc_read(UDVDMA_ERBAR), udc_read(UDVDMA_ERDPR));
+		ep5_handle(dev);
+	} else if (irq_en1_flags & VIDEO_ERF_IF) {
+		DEBUG_DBG("IRQ:ep5 event ring full\n");
+		udc_write(VIDEO_ERF_IF, UDCIF);
+		DEBUG_DBG("CRCR %x base %x  dequeue %x\n",
+			  udc_read(UDVDMA_CRCR), udc_read(UDVDMA_ERBAR),
+			  udc_read(UDVDMA_ERDPR));
+	}
+	if (irq_en2_flags & EPC_OFLOW_IF) {
+		udc_write(1, UDEPCDMA_RTR);
+		udc_write(EPC_OFLOW_IF, UDLIF);
+		DEBUG_DBG("EPC_OFLOW_IF CRCR %x %x %x\n",
+			  udc_read(UDEPCDMA_CRCR), udc_read(UDEPCDMA_RCSR),
+			  udc_read(UDEPCDMA_RTR));
+		udc_write(udc_read(UDLIE) & (~EPC_OFLOW_IF), UDLIE);
+	} else if (irq_en2_flags & EPC_SUCC_IF) {
+		udc_write(EPC_SUCC_IF, UDLIF);
+		udc_write(udc_read(UDLIE) & (~EPC_SUCC_IF), UDLIE);
+		DEBUG_DBG("EPC_SUCC_IF CRCR %x %x %x\n",
+			  udc_read(UDEPCDMA_CRCR), udc_read(UDEPCDMA_RCSR),
+			  udc_read(UDEPCDMA_RTR));
+		epc_handle(dev);
+	}			/*else */
+	if (irq_en1_flags & EPC_TRB_IF) {
+		DEBUG_DBG("IRQ:EPC_TRB_IF\n");
+		udc_write(EPC_TRB_IF, UDCIF);
+		DEBUG_DBG("CRCR %x %x %x\n", udc_read(UDEPCDMA_CRCR),
+			  udc_read(UDEPCDMA_RCSR), udc_read(UDEPCDMA_RTR));
+		epc_handle(dev);
+	} else if (irq_en1_flags & EPC_ERF_IF) {
+		DEBUG_DBG("IRQ:EPC event ring full\n");
+		udc_write(EPC_ERF_IF, UDCIF);
+		DEBUG_DBG("CRCR %x %x %x\n", udc_read(UDEPCDMA_CRCR),
+			  udc_read(UDEPCDMA_RCSR), udc_read(UDEPCDMA_RTR));
+	}
+	if (irq_en2_flags & SUS_IF) {
+		DEBUG_NOTICE("IRQ:UDC Suspent Event\n");
+		udc_write(SUS_IF, UDLIF);
+#ifdef CONFIG_USB_SUNPLUS_OTG
+		dev->suspend_sta++;
+		queue_work(dev->qwork_otg, &dev->work_otg);
+#endif
+		if (dev->driver){
+			if (dev->driver->suspend){
+				dev->driver->suspend(&dev->gadget);
+			}
+			if (dev->driver->disconnect){
+				dev->driver->disconnect(&dev->gadget);
+			}
+		}
+	}
+
+	if (irq_en2_flags & RESET_IF) {
+		DEBUG_NOTICE("reset irq\n");
+#ifdef CONFIG_USB_MULTIPLE_RESET_PROBLEM_WORKAROUND
+		//udelay(BUS_RESET_FOR_CHIRP_DELAY);
+		//udc_write(udc_read(UEP12DMACS) & (~RX_STEP7), UEP12DMACS);	/*control rx signal */
+#endif
+		/* two kind of reset :
+		 * - reset start -> pwr reg = 8
+		 * - reset end   -> pwr reg = 0
+		 **/
+		g_flag_ep5 = 0;
+		udc_write((udc_read(UDLCSET) | 8) & 0xFE, UDLCSET);
+		udc_write(RESET_IF, UDLIF);
+		/*Allow LNK to suspend PHY */
+		udc_write(udc_read(UDCCS) & (~UPHY_CLK_CSS), UDCCS);
+		clearHwState_UDC();
+		is_config = 0;
+		in_p_num = 0;
+	}
+
+	if (irq_en2_flags & EP0S_IF) {
+		udc_write(EP0S_IF, UDLIF);
+		DEBUG_NOTICE("ep0 setup int\n");
+		if ((udc_read(UDEP0CS) & (EP0_OVLD | EP0_OUT_EMPTY)) ==
+		    (EP0_OVLD | EP0_OUT_EMPTY)) {
+			udc_write(udc_read(UDEP0CS) | CLR_EP0_OUT_VLD, UDEP0CS);
+			/*DEBUG_ERR("why EP0_OVLD|EP0_OUT_EMPTY\n");*/
+		}
+		while (dev->ep0state != EP0_IDLE){
+			DEBUG_DBG("now,dev->ep0state:%d\n",dev->ep0state);
+			sp_udc_handle_ep0s(dev);
+		}
+		sp_udc_handle_ep0s(dev);
+	}
+
+	if ((irq_en2_flags & EP0I_IF)) {
+		DEBUG_NOTICE("IRQ:UDLC_EP0I_IE\n");
+		udc_write(EP0I_IF, UDLIF);
+		if (dev->ep0state != EP0_IDLE){
+			sp_udc_handle_ep0s(dev);
+		}
+		else
+			udc_write(udc_read(UDEP0CS) & (~EP_DIR), UDEP0CS);
+	}
+	if ((irq_en2_flags & EP0O_IF)) {
+		DEBUG_NOTICE("IRQ:UDLC_EP0O_IE maybe fix\n");
+		udc_write(EP0O_IF, UDLIF);
+		if (dev->ep0state == EP0_OUT_DATA_PHASE){
+			sp_udc_handle_ep0s(dev);
+		}
+	}
+	if (irq_en1_flags & EPB_DMA_IF) {
+		DEBUG_DBG("IRQ:UDC ep11 DMA\n");
+		udc_write(EPB_DMA_IF, UDCIF);
+		if ( /*dma_len&& */ 1)
+			ep11_dma_handle(dev);
+		/*queue_work(dev->qwork_ep11_dma, &dev->work_ep11_dma);*/
+
+	}else if (irq_en2_flags & EP1_DMA_IF) {	/*dma finish*/
+		DEBUG_DBG("IRQ:UDC ep1 DMA\n");
+		udc_write(EP1_DMA_IF, UDLIF);
+		if (dma_len_ep1)
+			ep1_dma_handle(dev);
+	}
+	if (irq_en1_flags & EP2_DMA_IF) {
+		DEBUG_DBG("IRQ:UDC ep2 DMA\n");
+		udc_write(EP2_DMA_IF, UDCIF);
+		 /*	if ( dma_len)*/
+		ep2_dma_handle(dev);
+	} else if (irq_en2_flags & EP2O_IF) {
+		DEBUG_DBG("IRQ:ep2 out int\n");
+		udc_write(EP2O_IF, UDLIF);
+		if (udc_read(UDEP2FS) & 0x22)
+			ep2_handle(dev);
+	} else if (irq_en2_flags & EP1I_IF) {
+		DEBUG_DBG("IRQ:ep1 in int\n");
+		udc_write(EP1I_IF, UDLIF);
+		if (dma_len_ep1) {
+			udc_write(udc_read(UDLIE) | (EP1I_IF), UDLIE);
+		} else if (!(udc_read(UDEP12FS) & 0x1)) {
+#ifdef CONFIG_USB_SUNPLUS_EP1
+			sp_udc_ep1_work();
+#else
+			ep1_handle(dev);
+#endif
+		}
+	} else if (irq_en2_flags & EP3I_IF) {
+		DEBUG_DBG("IRQ:ep3 in int\n");
+		udc_write(EP3I_IF, UDLIF);
+#ifdef INT_TEST
+		ep3_handle_test(dev);
+#else
+		queue_work(dev->qwork_ep3, &dev->work_ep3);
+#endif
+	} else if (irq_en2_flags & EP7I_IF) {
+		DEBUG_DBG("IRQ:ep7 in int\n");
+		udc_write(EP7I_IF, UDLIF);
+
+	} else if (irq_en2_flags & EP7_DMA_IF) {
+		DEBUG_DBG("IRQ:ep7 DMA in int\n");
+		udc_write(EP7_DMA_IF, UDLIF);
+
+	} else if (irq_en2_flags & EP5I_IF) {
+		DEBUG_DBG("IRQ:ep5 in int %x %x %x\n", udc_read(UDVDMA_CRCR),
+			  udc_read(UDVDMA_RCSR), udc_read(UDVDMA_RTR));
+		udc_write(EP5I_IF, UDLIF);
+		ep5_handle(dev);
+	} else if (irq_en2_flags & EP5_DMA_IF) {
+		DEBUG_DBG("IRQ:ep5 DMA in int\n");
+		udc_write(EP5_DMA_IF, UDLIF);
+	}
+	if (irq_en2_flags & EP1N_IF) {
+		DEBUG_DBG("IRQ:ep1 in NAK %x\n", udc_read(UDEP12FS));
+		udc_write(EP1N_IF, UDLIF);
+		udc_write(udc_read(UDLIE) & (~EP1N_IF), UDLIE);
+
+		if (dma_len_ep1) {
+			DEBUG_DBG("IRQ:ep1 dma_len_ep1=%d\n", dma_len_ep1);
+			udc_write(udc_read(UDLIE) | (EP1I_IF), UDLIE);
+		} else if (!(udc_read(UDEP12FS) & 0x1)) {
+			DEBUG_DBG("IRQ:ep1 hand\n");
+#ifdef CONFIG_USB_SUNPLUS_EP1
+			sp_udc_ep1_work();
+#else
+			ep1_handle(dev);
+#endif
+		}
+	} else if (irq_en2_flags & EP2N_IF) {
+		DEBUG_DBG("IRQ:ep2 out NAK %x\n", udc_read(UDEP2FS));
+		udc_write(EP2N_IF, UDLIF);
+	} else if (udc_epnb_irq_flags & EP8N_IF) {
+		DEBUG_DBG("IRQ:ep8 in NAK %x\n", udc_read(UDEP89FS));
+		udc_write(EP8N_IF, UDNBIF);
+		if (is_config == 1) {
+			is_config = 2;
+			DEBUG_NOTICE("will create /dev/iap!\n");
+			sp_reinit_iap(&memory.ep[9],
+					   list_entry((&memory.ep[9])->queue.next,
+					   struct sp_request,queue), 0xFF);
+		}
+	} else if (udc_epnb_irq_flags & EP9N_IF) {
+		DEBUG_DBG("IRQ:ep9 out NAK %x\n", udc_read(UDEP9FS));
+		udc_write(EP9N_IF, UDNBIF);
+
+	}
+
+	if (udc_epnb_irq_flags & EP8I_IF) {
+		DEBUG_DBG("IRQ:ep8 in  %x\n", udc_read(UDEP89FS));
+		udc_write(EP8I_IF, UDNBIF);
+		ep8_handle(dev);
+	}
+	if (udc_epnb_irq_flags & EP9O_IF) {
+		DEBUG_DBG("IRQ:ep9 OUT %x\n", udc_read(UDEP9FS));
+		udc_write(EP9O_IF, UDNBIF);
+		if (udc_read(UDEP9FS) & 0x22){
+			queue_work(dev->qwork_ep9, &dev->work_ep9);
+		}
+		else if (udc_read(UDEP9FS) == 0x55)
+			debug_ep_out();
+	} else if (udc_epnb_irq_flags & EP11O_IF) {
+		DEBUG_DBG("IRQ:ep11 out %x\n", udc_read(UDEPBFS));
+		udc_write(EP11O_IF, UDNBIF);
+
+		udc_write(udc_read(UDNBIE) & (~EP11O_IF), UDNBIE);
+#ifdef CONFIG_USB_SUNPLUS_EP11
+		if (dma_len) {
+#ifdef MANUAL_EP11
+			if (!is_ncm && !is_vera) {
+				udc_write(udc_read(UDNBIE) | (EP11O_IF), UDNBIE);
+				if (!down_trylock(&ep11_sw_sem)) {
+
+					if ((udc_read(UDEPBFS) & 0x22) == 0x20) {
+						DEBUG_DBG("IRQ:sw pipo\n");
+						if ((udc_read(UDEPBDMACS) & (UDC_FLASH_BUFFER_SIZE - 1)) > 0)	/*verB DMA bug*/
+							udc_write(udc_read(UDEPBPPC) | SWITCH_BUFF, UDEPBPPC);
+					} else {
+						udc_write(1, UDEPBONAKCN);
+					}
+					up(&ep11_sw_sem);
+				}
+			} else if (is_ncm) {
+				sp_udc_ep11_work();
+			}
+#endif
+		} else {
+			sp_udc_ep11_work();
+		}
+#else
+		if (udc_read(UDEPBFS) & 0x22)
+			ep11_handle(dev);
+#endif
+	} else if (udc_epnb_irq_flags & EP11N_IF) {
+		DEBUG_DBG("IRQ:ep11 nak %x\n", udc_read(UDEPBFS));
+		udc_write(EP11N_IF, UDNBIF);
+
+		udc_write(udc_read(UDNBIE) & (~EP11N_IF), UDNBIE);
+#ifdef CONFIG_USB_SUNPLUS_EP11
+		if (dma_len) {
+			udc_write(udc_read(UDNBIE) | (EP11N_IF), UDNBIE);
+#ifdef MANUAL_EP11
+			if (!is_ncm && !is_vera) {
+				if (!down_trylock(&ep11_sw_sem)) {
+
+					if ((udc_read(UDEPBFS) & 0x22) == 0x20) {
+						if ((udc_read(UDEPBDMACS) & (UDC_FLASH_BUFFER_SIZE - 1)) > 0)	/*verB DMA bug*/
+							udc_write(udc_read(UDEPBPPC) | SWITCH_BUFF, UDEPBPPC);
+					} else {
+
+						udc_write(1, UDEPBONAKCN);
+					}
+					up(&ep11_sw_sem);
+				}
+			} else if (is_ncm) {
+				sp_udc_ep11_work();
+			}
+#endif
+		} else {
+			sp_udc_ep11_work();
+		}
+#else
+		if (udc_read(UDEPBFS) & 0x22)
+			ep11_handle(dev);
+#endif
+	}
+	if (udc_read(UDNBIF) & SOF_IF) {
+#ifdef MANUAL_EP11
+		if (!is_ncm && dma_len && !down_trylock(&ep11_sw_sem)) {
+			if ((udc_read(UDEPBFS) & 0x22) == 0x20 ||
+				(sp_udc_get_ep_fifo_count((udc_read(UDEPBPPC) & CURR_BUFF) ? 1 : 0, UDEPBPIC) < 512 &&
+				sp_udc_get_ep_fifo_count((udc_read(UDEPBPPC) & CURR_BUFF) ? 0 : 1, UDEPBPIC) == 512)) {
+				if ((udc_read(UDEPBDMACS) & (UDC_FLASH_BUFFER_SIZE - 1)) > 0)	/*verB DMA bug*/
+					udc_write(udc_read(UDEPBPPC) | SWITCH_BUFF, UDEPBPPC);
+			}
+			up(&ep11_sw_sem);
+		}
+#endif
+/*		DEBUG_DBG("IRQ:sof\n");*/
+		udc_write(SOF_IF, UDNBIF);
+		udc_write(udc_read(UDNBIE) | (SOF_IF), UDNBIE);
+#ifndef CONFIG_USB_ZERO
+		if (t_task && sof_n++ % 2 && ncm_initialize_finish_flag){
+			tasklet_schedule(t_task);
+		}
+#endif
+	}
+	spin_unlock_irqrestore(&dev->lock, flags);
+/*	DEBUG_DBG("\t<irq...nIF=%x\n", udc_read(UDNBIF));*/
+	return IRQ_HANDLED;
+}
+
+static int sp_udc_queue(struct usb_ep *_ep, struct usb_request *_req,
+			    gfp_t gfp_flags)
+{
+	struct sp_request *req = to_sp_req(_req);
+	struct sp_ep *ep = to_sp_ep(_ep);
+	struct sp_udc *dev;
+	int ret = -1;
+	int queue_ret = 0;
+	u32 ep_csr = 0;
+	unsigned long flags;
+
+	DEBUG_INFO(">>> sp_udc_queue...\n");
+	if (ep->num == EP9 || ep->num == EP8 || ep->num == EP3) {
+		dev = ep->dev;
+		local_irq_save(flags);
+		goto iap_addr;
+	}
+	if (unlikely(!_ep || (!ep->desc && ep->ep.name != ep0name))) {
+		DEBUG_ERR("%s: invalid args %d %d %d\n", __func__,
+			  (!_ep) ? 1 : 0, (!ep->desc) ? 1 : 0,
+			  (ep->ep.name != ep0name) ? 1 : 0);
+		return -EINVAL;
+	}
+
+	dev = ep->dev;
+
+	if (unlikely(!dev->driver || dev->gadget.speed == USB_SPEED_UNKNOWN)) {
+		DEBUG_ERR("speed unknow\n");
+		return -ESHUTDOWN;
+	}
+	local_irq_save(flags);
+	if (unlikely(!_req || !_req->complete || !_req->buf
+	     || !sp_udc_list_empty(&req->queue, &ep->lock))) {
+		if (!_req)
+			DEBUG_ERR("%s: 1 X X X\n", __func__);
+		else {
+			DEBUG_ERR("%s: 0 %01d %01d %01d\n", __func__,
+				  !_req->complete, !_req->buf,
+				  !sp_udc_list_empty(&req->queue,
+							 &ep->lock));
+		}
+		local_irq_restore(flags);
+		return -EINVAL;
+	}
+
+iap_addr:
+
+	_req->status = -EINPROGRESS;
+	_req->actual = 0;
+
+	/* kickstart this i/o queue? */
+	if (sp_udc_list_empty(&ep->queue, &ep->lock)) {
+		if (ep->bEndpointAddress == EP0) {
+			DEBUG_INFO("ep0 enqueue\n");
+
+			ep_csr = udc_read(UDEP0CS);
+			if ((udc_read(UDEP0CS) & (EP0_OVLD | EP0_OUT_EMPTY)) == (EP0_OVLD | EP0_OUT_EMPTY))
+				udc_write(udc_read(UDEP0CS) | CLR_EP0_OUT_VLD,UDEP0CS);
+			DEBUG_DBG("dev->ep0state %d %x\n", dev->ep0state,
+				  udc_read(UDEP0CS));
+			switch (dev->ep0state) {
+			case EP0_IN_DATA_PHASE:
+				if (sp_udc_write_ep0_fifo(ep, req)) {
+					ret = 0;
+				}
+				break;
+
+			case EP0_OUT_DATA_PHASE:
+				if (!_req->length /*&& (!dev->req_std) */ ) {	/*NEED MODIFY */
+					udc_write(udc_read(UDLIE) | EP0I_IF, UDLIE);
+					udc_write(SET_EP0_IN_VLD | EP0_DIR, UDEP0CS);
+					DEBUG_DBG("ack 0 length => ep0 state=== %x\n", udc_read(UDEP0CS));
+				} else {
+					udc_write(udc_read(UDLIE) | EP0O_IF, UDLIE);
+					/*udc_write(CLR_EP0_OUT_VLD, UDEP0CS);*/
+				}
+				if ((!_req->length)
+				    || ((udc_read(UDEP0CS) & EP0_OVLD)
+					&& sp_udc_read_ep0_fifo(ep, req))) {
+					dev->ep0state = EP0_IDLE;
+					ret = 0;
+				}
+				DEBUG_DBG("ep0 state => %x\n",
+					  udc_read(UDEP0CS));
+				break;
+
+			default:
+				DEBUG_ERR(" ***** ep0 failed, dev->ep0state = %d \n",
+				     dev->ep0state);
+				queue_ret = -EL2HLT;
+				goto __QUEUE_BREAK;
+			}
+
+			if (ret == 0)
+				req = NULL;
+		} else if ((ep->bEndpointAddress & USB_DIR_IN) != 0) {
+			/*DEBUG_NOTICE("ep in status^^^^^^^^^^^^<<< %x\n",udc_read(UDC_LLCFS_OFST));*/
+			switch (ep->bEndpointAddress & 0x7F) {
+			case EP1:
+				DEBUG_INFO("enqueue, ep1 [%d] fifo_status:%x\n",
+					   req->req.length, udc_read(UDEP12FS));
+				break;
+			case EP3:
+				udc_write(udc_read(UDLIE) | EP3I_IF, UDLIE);
+
+				DEBUG_INFO("enqueue, ep3 in [%d] %x\n",
+					   req->req.length,
+					   udc_read(UDEP3CTRL));
+				ep_csr = udc_read(UDEP3CTRL);
+				if ((!(ep_csr & EP3_VLD))) {
+					if (sp_ep3_int_in(ep, req)) {
+						req = NULL;
+					}
+				} else {
+					DEBUG_ERR("[%s][%d] Why Invalid??\n",
+						  __FUNCTION__, __LINE__);
+					queue_ret = -EINVAL;
+					goto __QUEUE_BREAK;
+				}
+				break;
+
+			case EP5:
+				DEBUG_INFO("enqueue, ep5 in [%d] %x\n",
+					   req->req.length,
+					   udc_read(UDEP5CTRL));
+				ep_csr = udc_read(UDEP5CTRL);
+				if ((!(ep_csr & EP3_VLD)) && g_flag_ep5 < 2) {
+					if (sp_ep5_iso_in(ep, req)) {
+						req = NULL;
+					}
+				} else {
+					DEBUG_ERR("[%s][%d] Why Invalid??\n",
+						  __FUNCTION__, __LINE__);
+					queue_ret = -EINVAL;
+					goto __QUEUE_BREAK;
+				}
+				break;
+			case EP7:
+				udc_write(udc_read(UDLIE) | EP7I_IF |
+					  EP7_DMA_IF, UDLIE);
+
+				DEBUG_INFO("enqueue, ep7 in [%d] %x\n",
+					   req->req.length,
+					   udc_read(UDEP7CTRL));
+				ep_csr = udc_read(UDEP7CTRL);
+				if ((!(ep_csr & EP3_VLD))) {
+					if (sp_ep7_iso_in(ep, req)) {
+						req = NULL;
+					}
+				} else {
+					DEBUG_ERR("[%s][%d] Why Invalid??\n",
+						  __FUNCTION__, __LINE__);
+					queue_ret = -EINVAL;
+					goto __QUEUE_BREAK;
+				}
+				break;
+			case EP8:
+				DEBUG_DBG("enqueue, ep8 bulk in [%d]\n",
+					  req->req.length);
+				if (((udc_read(UDEP89FS) & 0x11) != 0x11)
+				    && sp_ep8_bulkin(ep, req))
+					req = NULL;
+				break;
+			case EP10:
+				/*DEBUG_INFO("enqueue, epa bulk in %x buff%d\n",
+						udc_read(UDC_EPABFS_OFST),(!(udc_read(UDC_EPABPPC_OFST)>>2)));*/
+				break;
+			default:
+				DEBUG_ERR("[%s][%d] Why Invalid??\n",
+					  __FUNCTION__, __LINE__);
+				queue_ret = -EINVAL;
+				goto __QUEUE_BREAK;
+			}
+		} else {
+			/*DEBUG_NOTICE("ep out status^^^^^^^^^^^^<<< %x\n",udc_read(UDC_LLCFS_OFST));*/
+			if (ep->bEndpointAddress != EP2
+			    && ep->bEndpointAddress != EP11
+			    && ep->bEndpointAddress != EP9
+			    && ep->bEndpointAddress != EP12
+			    && ep->bEndpointAddress != EP5) {
+				DEBUG_ERR("ep%d not complete \n",
+					  ep->bEndpointAddress);
+				queue_ret = -EINVAL;
+				goto __QUEUE_BREAK;
+			} else if (ep->bEndpointAddress == EP9) {
+				DEBUG_DBG("enqueue, bulk out ep9 %x buf%d\n",
+					  udc_read(UDEP9FS),
+					  (!(udc_read(UDEP9PPC) >> 2)));
+				/*if(udc_read(UDC_EP89FS_OFST)&0x22 &&
+				   sp_ep9_bulkout(ep, req))
+				   req == NULL; */
+			} else if (ep->bEndpointAddress == EP11) {
+				DEBUG_DBG("enqueue, bulk out ep11 %x buf%d\n",
+					  udc_read(UDEPBFS),
+					  (!(udc_read(UDEPBPPC) >> 2)));
+			} else if (ep->bEndpointAddress == EP12) {
+				if (sp_epc_iso_out(ep, req)) {
+					req = NULL;
+				}
+			}
+		}
+	}
+	if (likely(req)) {
+		sp_list_add(&req->queue, &ep->queue, &ep->lock);
+	}
+	local_irq_restore(flags);
+	if (dma_flag == 0 && (((ep->bEndpointAddress) & 0xf) == EP2)) {
+		if (udc_read(UDEP2FS) & 0x22)
+			ep2_handle(NULL);
+	}
+	if (dma_flag_b == 0 && (((ep->bEndpointAddress) & 0xf) == EP11)) {
+		if (udc_read(UDEPBFS) & 0x22)
+			ep11_handle(NULL);
+	}
+	if (dma_len_ep1) {
+		udc_write(udc_read(UDLIE) | EP1_DMA_IF, UDLIE);
+	} else if (((ep->bEndpointAddress) & 0xf) == EP1) {
+		if (likely(req)) {
+			if (req->req.actual) {
+				udc_write(udc_read(UDLIE) | EP1I_IF, UDLIE);
+				udc_write(udc_read(UDLIE) | EP1N_IF, UDLIE);
+			}
+			if ((udc_read(UDEP12FS) & 0x1) != 0x1) {
+
+			}
+		}
+	}
+
+	DEBUG_INFO("<<<%s..\n", __FUNCTION__);
+
+	return 0;
+
+__QUEUE_BREAK:
+	if (likely(req))
+		list_add_tail(&req->queue, &ep->queue);
+	DEBUG_INFO("<<<%s...\n", __FUNCTION__);
+	local_irq_restore(flags);
+	if(queue_ret < 0)
+		DEBUG_ERR("%s  error:%d\n",__FUNCTION__,queue_ret);
+
+	return 0;
+}
+
+static int sp_udc_dequeue(struct usb_ep *_ep, struct usb_request *_req)
+{
+	struct sp_ep *ep;
+	struct sp_udc *udc;
+	struct sp_request *req = NULL;
+	int retval = -EINVAL;
+
+	DEBUG_INFO(">>> sp_udc_dequeue...\n");
+	DEBUG_INFO("%s dequeue\n", _ep->name);
+
+	if (!the_controller->driver)
+		return -ESHUTDOWN;
+
+	if (!_ep || !_req)
+		return retval;
+
+	ep = to_sp_ep(_ep);
+	udc = to_sp_udc(ep->gadget);
+	list_for_each_entry(req, &ep->queue, queue) {
+		if (&req->req == _req) {
+			sp_del_list(&req->queue, &ep->lock);
+			_req->status = -ECONNRESET;
+			retval = 0;
+			break;
+		}
+	}
+
+	if (retval == 0) {
+		DEBUG_INFO("dequeued req %p from %s, len %d buf %p\n", req,
+			   _ep->name, _req->length, _req->buf);
+
+		sp_udc_done(ep, req, -ECONNRESET);
+	}
+	DEBUG_INFO("<<< sp_udc_dequeue...retval = %d\n", retval);
+	return retval;
+}
+
+static void sp_udc_enable(struct sp_udc *udc);
+
+static int sp_udc_get_frame(struct usb_gadget *_gadget)
+{
+	u32 sof_value;
+
+	sof_value = udc_read(UDFRNUM);
+
+	return sof_value;
+}
+
+static int sp_udc_wakeup(struct usb_gadget *_gadget)
+{
+	return -EOPNOTSUPP;
+}
+
+static int sp_udc_set_selfpowered(struct usb_gadget *_gadget,
+				      int is_selfpowered)
+{
+	return -EOPNOTSUPP;
+}
+
+static int sp_udc_pullup(struct usb_gadget *gadget, int is_on)
+{
+	if (is_on) {
+		DEBUG_NOTICE("Force to Connect\n");
+		/*Force to Connect */
+		udc_write((udc_read(UDLCSET) | 8) & 0xFE, UDLCSET);
+	} else {
+		DEBUG_NOTICE("Force to Disconnect\n");
+		/*Force to Disconnect */
+		sp_udc_nuke(NULL, &memory.ep[9], 0);
+		udc_write(udc_read(UDLCSET) | SOFT_DISC, UDLCSET);
+	}
+	DEBUG_NOTICE("<<< sp_udc_pullup...\n");
+
+	return 0;
+}
+
+static int sp_udc_vbus_session(struct usb_gadget *gadget, int is_active)
+{
+	return -EOPNOTSUPP;
+}
+
+static int sp_vbus_draw(struct usb_gadget *_gadget, unsigned ma)
+{
+	return -EOPNOTSUPP;
+}
+
+static int sp_udc_start(struct usb_gadget *gadget, struct usb_gadget_driver *driver)
+{
+	struct sp_udc *udc = the_controller;
+	int ret;
+
+	DEBUG_NOTICE(">>> sp_udc_start...\n");
+	/* Sanity checks */
+	if (!udc)
+		return -ENODEV;
+	if (udc->driver)
+		return -EBUSY;
+
+	if (!driver->bind || !driver->setup || driver->max_speed < USB_SPEED_FULL) {
+		DEBUG_ERR("Invalid driver: bind %p setup %p speed %d\n", driver->bind,
+			  driver->setup, driver->max_speed);
+		return -EINVAL;
+	}
+
+	/* Hook the driver */
+	udc->driver = driver;
+	udc->gadget.dev.driver = &driver->driver;
+
+	if ((ret = device_add(&udc->gadget.dev)) != 0) {
+		DEBUG_ERR("Error in device_add() : %d\n", ret);
+		goto register_error;
+	}
+
+	if ((ret = driver->bind(&udc->gadget, driver)) != 0) {
+		device_del(&udc->gadget.dev);
+		goto register_error;
+	}
+
+	sp_udc_enable(udc);
+
+	DEBUG_NOTICE("<<< sp_udc_start...\n");
+	return 0;
+
+register_error:
+	DEBUG_ERR("[%s][%d] fail[%d]\n", __FUNCTION__, __LINE__, ret);
+	udc->driver = NULL;
+	udc->gadget.dev.driver = NULL;
+	return ret;
+}
+
+static int sp_udc_stop(struct usb_gadget_driver *driver){
+	struct sp_udc *udc = the_controller;
+
+	DEBUG_NOTICE(">>> sp_udc_stop...\n");
+	if (!udc)
+		return -ENODEV;
+
+	if (!driver || driver != udc->driver || !driver->unbind)
+		return -EINVAL;
+
+	/* report disconnect */
+	if (driver->disconnect)
+		driver->disconnect(&udc->gadget);
+
+	driver->unbind(&udc->gadget);
+
+	device_del(&udc->gadget.dev);
+	udc->driver = NULL;
+
+	/* Disable udc
+	sp_udc_disable(udc);  TODO: sp_udc_disable*/
+
+	return 0;
+}
+
+static const struct usb_gadget_ops sp_ops = {
+	.get_frame = sp_udc_get_frame,
+	.wakeup = sp_udc_wakeup,
+	.set_selfpowered = sp_udc_set_selfpowered,
+	.pullup = sp_udc_pullup,
+	.vbus_session = sp_udc_vbus_session,
+	.vbus_draw = sp_vbus_draw,
+	.udc_start = sp_udc_start,
+	.udc_stop = sp_udc_stop,
+};
+
+static const struct usb_ep_ops sp_ep_ops = {
+	.enable = sp_udc_ep_enable,
+	.disable = sp_udc_ep_disable,
+
+	.alloc_request = sp_udc_alloc_request,
+	.free_request = sp_udc_free_request,
+
+	.queue = sp_udc_queue,
+	.dequeue = sp_udc_dequeue,
+
+	.set_halt = sp_udc_set_halt,
+};
+
+/*
+return	0 : disconnect	1 : connect
+*/
+static int sp_vbus_detect(void)
+{
+	return 1;
+}
+
+static struct sp_udc memory = {
+	.gadget = {
+		   .ops = &sp_ops,
+		   .ep0 = &memory.ep[0].ep,
+		   .name = gadget_name,
+		   .dev = {
+			   .init_name = "gadget",
+			   },
+		   },
+
+	/* control endpoint */
+	.ep[0] = {
+		  .num = 0,
+		  .ep = {
+			 .name = ep0name,
+			 .ops = &sp_ep_ops,
+			 .maxpacket = EP0_FIFO_SIZE,
+			 },
+		  .dev = &memory,
+		  },
+
+	/* first group of endpoints */
+	.ep[1] = {
+		  .num = 1,
+		  .ep = {
+			 .name = "ep1in-bulk",
+			 .ops = &sp_ep_ops,
+			 .maxpacket = EP12_FIFO_SIZE64,
+			 },
+		  .dev = &memory,
+		  .fifo_size = EP_FIFO_SIZE,
+		  .bEndpointAddress = USB_DIR_IN | EP1,
+		  .bmAttributes = USB_ENDPOINT_XFER_BULK,
+		  },
+	.ep[2] = {
+		  .num = 2,
+		  .ep = {
+			 .name = "ep2out-bulk",
+			 .ops = &sp_ep_ops,
+			 .maxpacket = EP12_FIFO_SIZE64,
+			 },
+		  .dev = &memory,
+		  .fifo_size = EP_FIFO_SIZE,
+		  .bEndpointAddress = USB_DIR_OUT | EP2,
+		  .bmAttributes = USB_ENDPOINT_XFER_BULK,
+		  },
+
+	.ep[3] = {
+		  .num = 3,
+		  .ep = {
+			 .name = "ep3in-int",
+			 .ops = &sp_ep_ops,
+			 .maxpacket = EP_FIFO_SIZE,
+			 },
+		  .dev = &memory,
+		  .fifo_size = EP_FIFO_SIZE,
+		  .bEndpointAddress = USB_DIR_IN | EP3,
+		  .bmAttributes = USB_ENDPOINT_XFER_INT,
+		  },
+	.ep[4] = {
+		  .num = 4,
+		  .ep = {
+			 .name = "ep4in-int",
+			 .ops = &sp_ep_ops,
+			 .maxpacket = EP12_FIFO_SIZE64,
+			 },
+		  .dev = &memory,
+		  .fifo_size = EP_FIFO_SIZE,
+		  .bEndpointAddress = USB_DIR_IN | EP4,
+		  .bmAttributes = USB_ENDPOINT_XFER_INT,
+		  },
+	.ep[5] = {
+		  .num = 5,
+		  .ep = {
+			 .name = "ep5-iso",
+			 .ops = &sp_ep_ops,
+			 .maxpacket = 1024 * 3,
+			 },
+		  .dev = &memory,
+		  .fifo_size = EP_FIFO_SIZE,
+		  .bEndpointAddress = USB_DIR_OUT | EP5,
+		  .bmAttributes = USB_ENDPOINT_XFER_ISOC,
+		  },
+
+	.ep[6] = {
+		  .num = 6,
+		  .ep = {
+			 .name = "ep6in-int",
+			 .ops = &sp_ep_ops,
+			 .maxpacket = EP12_FIFO_SIZE64,
+			 },
+		  .dev = &memory,
+		  .fifo_size = EP_FIFO_SIZE,
+		  .bEndpointAddress = USB_DIR_IN | EP6,
+		  .bmAttributes = USB_ENDPOINT_XFER_INT,
+		  },
+
+	.ep[7] = {
+		  .num = 7,
+		  .ep = {
+			 .name = "ep7-iso",
+			 .ops = &sp_ep_ops,
+			 .maxpacket = EP12_FIFO_SIZE64,
+			 },
+		  .dev = &memory,
+		  .fifo_size = EP_FIFO_SIZE,
+		  .bEndpointAddress = USB_DIR_OUT | EP7,
+		  .bmAttributes = USB_ENDPOINT_XFER_ISOC,
+		  },
+
+	.ep[8] = {
+		  .num = 8,
+		  .ep = {
+			 .name = "ep8in-bulk",
+			 .ops = &sp_ep_ops,
+			 .maxpacket = EP12_FIFO_SIZE64,
+			 },
+		  .dev = &memory,
+		  .fifo_size = EP_FIFO_SIZE,
+		  .bEndpointAddress = USB_DIR_IN | EP8,
+		  .bmAttributes = USB_ENDPOINT_XFER_BULK,
+		  },
+
+	.ep[9] = {
+		  .num = 9,
+		  .ep = {
+			 .name = "ep9out-bulk",
+			 .ops = &sp_ep_ops,
+			 .maxpacket = EP12_FIFO_SIZE64,
+			 },
+		  .dev = &memory,
+		  .fifo_size = EP_FIFO_SIZE,
+		  .bEndpointAddress = USB_DIR_OUT | EP9,
+		  .bmAttributes = USB_ENDPOINT_XFER_BULK,
+		  },
+
+	.ep[10] = {
+		   .num = 10,
+		   .ep = {
+			  .name = "ep10in-bulk",
+			  .ops = &sp_ep_ops,
+			  .maxpacket = EP12_FIFO_SIZE64,
+			  },
+		   .dev = &memory,
+		   .fifo_size = EP_FIFO_SIZE,
+		   .bEndpointAddress = USB_DIR_IN | EP10,
+		   .bmAttributes = USB_ENDPOINT_XFER_BULK,
+		   },
+
+	.ep[11] = {
+		   .num = 11,
+		   .ep = {
+			  .name = "ep11out-bulk",
+			  .ops = &sp_ep_ops,
+			  .maxpacket = EP12_FIFO_SIZE64,
+			  },
+		   .dev = &memory,
+		   .fifo_size = EP_FIFO_SIZE,
+		   .bEndpointAddress = USB_DIR_OUT | EP11,
+		   .bmAttributes = USB_ENDPOINT_XFER_BULK,
+		   },
+	.ep[12] = {
+		   .num = 12,
+		   .ep = {
+			  .name = "ep12-iso",
+			  .ops = &sp_ep_ops,
+			  .maxpacket = 1024,
+			  },
+		   .dev = &memory,
+		   .fifo_size = EP_FIFO_SIZE,
+		   .bEndpointAddress = USB_DIR_OUT | EP12,
+		   .bmAttributes = USB_ENDPOINT_XFER_ISOC,
+		   },
+};
+
+static void sp_udc_enable(struct sp_udc *udc)
+{
+	/*
+	   usb device interrupt enable
+	   ---force usb bus disconnect enable
+	   ---force usb bus connect interrupt enable
+	   ---vbus interrupt enable
+	 */
+
+	/* usb device controller interrupt flag */
+	udc_write(udc_read(UDCIF) & 0xFFFF, UDCIF);
+	/* usb device link layer interrupt flag */
+	udc_write(0xefffffff, UDLIF);
+
+	udc_write(VBUS_IF, UDCIE);
+	udc_write(EP0S_IF | RESET_IF | RESET_RELEASE_IF, UDLIE);
+
+	if (sp_vbus_detect()) {
+		udc_write(udc_read(UDLIE) | SUS_IF, UDLIE);
+		udelay(200);
+		udc_write(udc_read(UDCCS) | UPHY_CLK_CSS, UDCCS);	/*PREVENT SUSP */
+		udelay(200);
+		/*Force to Connect */
+	}
+	DEBUG_NOTICE("func:%s line:%d\n", __FUNCTION__, __LINE__);
+}
+
+static void sp_udc_reinit(struct sp_udc *udc)
+{
+	u32 i = 0;
+
+	/* device/ep0 records init */
+	INIT_LIST_HEAD(&udc->gadget.ep_list);
+	INIT_LIST_HEAD(&udc->gadget.ep0->ep_list);
+	udc->ep0state = EP0_IDLE;
+
+	for (i = 0; i < SP_MAXENDPOINTS; i++) {
+		struct sp_ep *ep = &udc->ep[i];
+
+		if (i != 0){
+			list_add_tail(&ep->ep.ep_list, &udc->gadget.ep_list);
+		}
+
+		ep->dev = udc;
+		ep->desc = NULL;
+		ep->halted = 0;
+		INIT_LIST_HEAD(&ep->queue);
+	}
+}
+
+#ifdef CONFIG_USB_SUNPLUS_OTG
+
+static void sp_udc_otg_work(struct work_struct *work)
+{
+	struct usb_phy *otg_phy;
+	struct sp_udc *udc =
+	    (struct sp_udc *)container_of(work, struct sp_udc,
+					      work_otg);
+	int frame_a;
+	int frame_b;
+	int otg_id;
+
+	DEBUG_NOTICE("%s in\n", __func__);
+
+	if (udc->suspend_sta == 1) {
+		DEBUG_ERR("B frist in\n");
+	}
+
+	udc->suspend_sta = 0;
+
+	otg_phy = usb_get_transceiver_sunplus(udc->bus_num - 1);
+	if (!otg_phy) {
+		DEBUG_ERR("Get otg control fail(busnum:%d)!\n", udc->bus_num);
+		return;
+	}
+
+	/* check device is disconnect ? */
+	frame_a = udc->gadget.ops->get_frame(&udc->gadget);
+	msleep(500);
+	frame_b = udc->gadget.ops->get_frame(&udc->gadget);
+
+	if (frame_a == frame_b) {
+
+		DEBUG_NOTICE("B device is disconnect %d %d\n", frame_a,
+			     frame_b);
+		otg_set_vbus(otg_phy->otg, 0);
+
+		/* id pin is still low */
+		if (otg_phy->io_ops->read && otg_phy->io_ops->write) {
+			otg_id = otg_phy->io_ops->read(otg_phy, (u32) (((u32 *) otg_phy->io_priv) + OTG_INT_ST_REG));
+			if ((otg_id & ~ID_PIN) == 0) {
+				msleep(10);
+				/*otg_set_vbus(otg_phy->otg, 1);*/
+			}
+		}
+		DEBUG_NOTICE("disc apple %d\n", is_config);
+		if (is_config) {
+			DEBUG_NOTICE("disc apple\n");
+			sp_udc_nuke(memory.ep[8].dev, &memory.ep[8], -ESHUTDOWN);
+			sp_reinit_iap(&memory.ep[9], list_entry((&memory.ep[9])->queue.next, struct sp_request, queue), -ESHUTDOWN);
+		}
+	}
+}
+#endif
+#ifdef CONFIG_FIQ_GLUE
+static int fiq_isr(int fiq, void *data)
+{
+	sp_udc_irq(irq_num,&memory);
+	return IRQ_HANDLED;
+}
+
+static void fiq_handler(struct fiq_glue_handler *h, void *regs, void *svc_sp)
+{
+	void __iomem *cpu_base = gic_base(GIC_CPU_BASE);
+	u32 irqstat, irqnr;
+
+	irqstat = readl_relaxed(cpu_base + GIC_CPU_HIGHPRI);
+	irqnr = irqstat & ~0x1c00;
+
+	if (irqnr == irq_num) {
+		readl_relaxed(cpu_base + GIC_CPU_INTACK);
+		fiq_isr(irqnr, h);
+		writel_relaxed(irqstat, cpu_base + GIC_CPU_EOI);
+	}
+}
+static irqreturn_t udcThreadHandler(int irq, void *dev_id)
+{
+	printk("<DSR>\n");
+	return IRQ_HANDLED;
+}
+#endif
+/********** PLATFORM DRIVER & DEVICE *******************/
+
+static int sp_udc_probe(struct platform_device *pdev)
+{
+	struct sp_udc *udc = &memory;
+	struct device *dev = &pdev->dev;
+	struct resource *res;
+	u32 irq;
+	int ret;
+
+	static u64 rsrc_start, rsrc_len;
+
+#ifdef CONFIG_USB_SUNPLUS_OTG
+	struct usb_phy *otg_phy;
+#endif
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	irq = platform_get_irq(pdev, 0);
+	if (!res || !irq) {
+		DEBUG_ERR("Not enough platform resources.\n");
+		ret = -ENODEV;
+		goto error;
+	}
+	rsrc_start = res->start;
+	rsrc_len = resource_size(res);
+	printk("udc-line:%d,%lld,%lld,irq:%d\n", __LINE__, rsrc_start, rsrc_len, irq);
+	base_addr = ioremap(rsrc_start, rsrc_len);
+	if (!base_addr) {
+		ret = -ENOMEM;
+		goto err_mem;
+	}
+#ifdef ISP_DEBUG
+	int sp3502_udc_probe(void);
+	sp3502_udc_probe();
+#endif
+	device_initialize(&udc->gadget.dev);
+	udc->gadget.dev.parent = dev;
+	udc->gadget.dev.dma_mask = dev->dma_mask;
+
+#ifdef CONFIG_USB_SUNPLUS_OTG
+	udc->suspend_sta = 0;
+	udc->qwork_otg = create_singlethread_workqueue("sp-udc-otg");
+	if (!udc->qwork_otg) {
+		DEBUG_ERR("cannot create workqueue sp-udc-otg\n");
+		ret = -ENOMEM;
+	}
+	INIT_WORK(&udc->work_otg, sp_udc_otg_work);
+#endif
+
+	udc->qwork_ep3 = create_singlethread_workqueue("sp-udc-ep3");
+	if (!udc->qwork_ep3) {
+		DEBUG_ERR("cannot create workqueue sp-udc-ep3\n");
+		ret = -ENOMEM;
+	}
+	INIT_WORK(&udc->work_ep3, sp_udc_ep3_work);
+
+	udc->qwork_ep9 = create_singlethread_workqueue("sp-udc-ep9");
+	if (!udc->qwork_ep9) {
+		DEBUG_ERR("cannot create workqueue sp-udc-ep9\n");
+		ret = -ENOMEM;
+	}
+	INIT_WORK(&udc->work_ep9, sp_udc_ep9_work);
+	the_controller = udc;
+	platform_set_drvdata(pdev, udc);
+	sp_udc_reinit(udc);
+#ifdef CONFIG_FIQ_GLUE
+	udc->handler.isr = fiq_isr;
+	ret = fiq_glue_register_handler(&udc->handler);
+	if (ret != 0)
+		printk("udc fiq fail\n");
+	ret = request_threaded_irq(irq, 0,
+							udcThreadHandler, IRQF_DISABLED , gadget_name, udc);/*udcThreadHandler*/
+#else
+	ret = request_irq(irq, sp_udc_irq, IRQF_DISABLED, gadget_name, udc);
+#endif
+	if (ret != 0) {
+		DEBUG_ERR("cannot get irq %i, err %d\n", irq, ret);
+		ret = -EBUSY;
+		goto err_map;
+	}
+	platform_set_drvdata(pdev, udc);
+	udc->vbus = 0;
+
+	spin_lock_init(&udc->lock);
+	init_ep_spin();
+	sp_sem_init();
+
+#ifdef CONFIG_USB_SUNPLUS_OTG
+	udc->bus_num = pdev->id;
+	otg_phy = usb_get_transceiver_sunplus(pdev->id - 1);
+	ret = otg_set_peripheral(otg_phy->otg, &udc->gadget);
+	if (ret < 0) {
+		goto err_add_udc;
+	}
+#endif
+
+	DEBUG_ERR("udc-line:%d\n", __LINE__);
+	ret = usb_add_gadget_udc(&pdev->dev, &udc->gadget);
+	if (ret) {
+		goto err_add_udc;
+	}
+
+	DEBUG_ERR("probe sp udc ok %x\n", udc_read(VERSION));
+	/*iap debug */
+	udc_write(udc_read(UDNBIE) | EP8N_IF | EP8I_IF, UDNBIE);
+	udc_write(EP_ENA | EP_DIR, UDEP89C);
+	udc_write(udc_read(UDNBIE) | EP9N_IF | EP9O_IF, UDNBIE);
+
+	device_create_file(&pdev->dev, &dev_attr_udc_ctrl);
+
+	return 0;
+err_add_udc:
+	free_irq(irq_num, udc);
+err_map:
+	DEBUG_INFO("probe sp udc fail\n");
+	return ret;
+err_mem:
+	release_mem_region(rsrc_start, rsrc_len);
+error:
+	DEBUG_ERR("probe sp udc fail\n");
+	return ret;
+
+}
+
+static int sp_udc_remove(struct platform_device *pdev)
+{
+	struct sp_udc *udc = platform_get_drvdata(pdev);
+
+	device_remove_file(&pdev->dev, &dev_attr_udc_ctrl);
+	usb_del_gadget_udc(&udc->gadget);
+	if (udc->driver)
+		return -EBUSY;
+	free_irq(irq_num, udc);
+	platform_set_drvdata(pdev, NULL);
+	DEBUG_INFO("sp_udc remove ok\n");
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int sp_udc_suspend(struct platform_device *pdev, pm_message_t state)
+{
+	return 0;
+}
+
+static int sp_udc_resume(struct platform_device *pdev)
+{
+	sp_udc_enable(NULL);
+
+	udc_write(udc_read(UDNBIE) | EP8N_IF | EP8I_IF, UDNBIE);
+	udc_write(EP_ENA | EP_DIR, UDEP89C);
+	udc_write(udc_read(UDNBIE) | EP9N_IF | EP9O_IF, UDNBIE);
+
+	return 0;
+}
+#else
+#define sp_udc_suspend	NULL
+#define sp_udc_resume	NULL
+#endif
+
+#ifdef CONFIG_USB_HOST_RESET_SP
+static int udc_init_c(void)
+{
+	sp_udc_enable(NULL);
+	/*iap debug */
+	udc_write(udc_read(UDNBIE) | EP8N_IF | EP8I_IF, UDNBIE);
+	udc_write(EP_ENA | EP_DIR, UDEP89C);
+	udc_write(udc_read(UDNBIE) | EP9N_IF | EP9O_IF, UDNBIE);
+	/*pullup */
+	udc_write((udc_read(UDLCSET) | 8) & 0xFE, UDLCSET);
+	return 0;
+}
+#endif
+void sp_udc_state_polling(unsigned long data)
+{
+	if (!platform_device_handle_flag
+		|| !bus_reset_finish_flag){
+		DEBUG_DBG("finish_flag: %d,handle_flag: %d\n",
+			bus_reset_finish_flag,platform_device_handle_flag);
+		return ;
+	}
+	if (sof_value == udc_read(UDFRNUM) /*&& sof_value */ ) {
+		DEBUG_NOTICE("SOF %x\n", udc_read(UDFRNUM));
+		sof_value = 0x1000;
+		/*discnnect */
+		usb_switch(TO_HOST);
+	} else {
+		sof_value = udc_read(UDFRNUM);
+		if (is_config) {
+			mod_timer(&vbus_polling_timer,
+				  jiffies + d_time1);
+		} else {
+			mod_timer(&vbus_polling_timer,
+				  jiffies + d_time0);
+		}
+	}
+}
+
+void sp_sof_state_polling(unsigned long data)
+{
+	if (!platform_device_handle_flag
+		|| bus_reset_finish_flag){
+		DEBUG_DBG("finish: %d,handle: %d\n",
+			bus_reset_finish_flag,platform_device_handle_flag);
+		return ;
+	}
+
+	if (first_enter_polling_timer_flag) {
+		temp_sof_value = udc_read(UDFRNUM);
+		first_enter_polling_timer_flag = false;
+		mod_timer(&sof_polling_timer,
+			  jiffies + 3 * HZ / 2);
+	} else {
+		if (temp_sof_value == udc_read(UDFRNUM)) {
+			DEBUG_NOTICE("SOFX %x\n",
+				     udc_read(UDFRNUM));
+			/*discnnect */
+					usb_switch(TO_HOST);
+		} else {
+			temp_sof_value = udc_read(UDFRNUM);
+			mod_timer(&sof_polling_timer,
+				  jiffies + 3 * HZ / 2);
+		}
+	}
+}
+
+void usb_switch(int device)
+{
+	void __iomem *regs = (void __iomem *)B_SYSTEM_BASE;
+
+	if (device) {
+#if 1
+		if (accessory_port_id == 0) {
+				writel(RF_MASK_V_SET(1 << 4), regs + 0x244);
+				writel(RF_MASK_V_CLR(1 << 5), regs + 0x244);
+		} else {
+				writel(RF_MASK_V_SET(1 << 12), regs + 0x244);
+				writel(RF_MASK_V_CLR(1 << 13), regs + 0x244);
+		}
+#else
+		value = readl(USBC_CTL);
+		if (accessory_port_id == 0) {
+			value &= ~(7 << 4);
+			value |= (1u << 6) | (0u << 5) | (1u << 4);
+		} else {
+			value &= ~(7 << 12);
+			value |= (1u << 14) | (0u << 13) | (1u << 12);
+		}
+		writel(value, USBC_CTL);
+#endif
+		DEBUG_ERR("host to device\n");
+	} else {
+		udc_write(udc_read(UDLCSET) | SOFT_DISC, UDLCSET);
+		if (is_config) {
+			is_config = 0;
+			sp_udc_nuke(memory.ep[8].dev, &memory.ep[8],
+					-ESHUTDOWN);
+			/*sp_reinit_iap(&memory.ep[9],
+						list_entry((&memory.ep[9])->queue.next,
+						struct sp_request, queue), -ESHUTDOWN);*/
+		}
+		if (accessory_port_id == 0) {
+			writel(RF_MASK_V_SET(1 << 5), regs + 0x244);
+		} else {
+			writel(RF_MASK_V_SET(1 << 13), regs + 0x244);
+		}
+		bus_reset_finish_flag = false;
+		platform_device_handle_flag = false;
+		DEBUG_ERR("device to host!\n");
+	}
+}
+
+void ctrl_rx_squelch(void)/*Controlling squelch signal to slove the uphy bad signal problem*/
+{
+	udc_write(udc_read(UEP12DMACS) | RX_STEP7, UEP12DMACS);	/*control rx signal */
+
+	DEBUG_NOTICE("ctrl_rx_squelch UEP12DMACS: %x\n",udc_read(UEP12DMACS));
+}
+
+EXPORT_SYMBOL(usb_switch);
+EXPORT_SYMBOL(ctrl_rx_squelch);
+
+void detech_start(void)
+{
+#ifdef	CONFIG_USB_HOST_RESET_SP
+	udc_init_c();
+#endif
+	platform_device_handle_flag = true;
+	first_enter_polling_timer_flag = true;
+	reset_global_value();
+	/*mod_timer(&vbus_polling_timer, jiffies + d_time0);*/
+	/*mod_timer(&sof_polling_timer, jiffies + HZ / 10);*/
+	DEBUG_ERR("detech_start......\n");
+}
+EXPORT_SYMBOL(detech_start);
+
+static const struct of_device_id sunplus_udc0_ids[] = {
+	{ .compatible = "sunplus,sunplus-q628-usb-udc0" },
+	{ }
+};
+MODULE_DEVICE_TABLE(platform, sunplus_udc0_ids);
+
+static const struct of_device_id sunplus_udc1_ids[] = {
+	{ .compatible = "sunplus,sunplus-q628-usb-udc1", },
+	{ }
+};
+MODULE_DEVICE_TABLE(platform, sunplus_udc1_ids);
+
+static struct platform_driver sunplus_udc0_driver = {
+	.driver		= {
+		.name	= "sunplus-usbgadget0",
+		.of_match_table = sunplus_udc0_ids,
+	},
+	.probe		= sp_udc_probe,
+	.remove		= sp_udc_remove,
+	.suspend	= sp_udc_suspend,
+	.resume		= sp_udc_remove,
+};
+
+static struct platform_driver sunplus_udc1_driver = {
+	.driver		= {
+		.name	= "sunplus-usbgadget1",
+		.of_match_table = sunplus_udc1_ids,
+	},
+	.probe		= sp_udc_probe,
+	.remove		= sp_udc_remove,
+	.suspend	= sp_udc_suspend,
+	.resume		= sp_udc_remove,
+};
+
+static int __init udc_init(void)
+{
+	int retval;
+	
+#ifdef ISP_DEBUG
+	g_hw = vmalloc(ISP_DEBUG_SIZE);
+	DEBUG_ERR("%x\n", g_hw);
+#endif
+	DEBUG_NOTICE("udc_init\n");
+
+	if (accessory_port_id == 0) {
+		printk(KERN_NOTICE "register sunplus_udc0_driver\n");
+		retval = platform_driver_register(&sunplus_udc0_driver);
+	} else {
+		printk(KERN_NOTICE "register sunplus_udc1_driver\n");
+		retval = platform_driver_register(&sunplus_udc1_driver);
+		
+	}
+	if (retval)
+		goto err;
+
+	init_timer(&vbus_polling_timer);
+	vbus_polling_timer.function = sp_udc_state_polling;
+	vbus_polling_timer.expires = jiffies - HZ;
+	/*add_timer(&vbus_polling_timer); */
+
+	init_timer(&sof_polling_timer);
+	sof_polling_timer.function = sp_sof_state_polling;
+	sof_polling_timer.expires = jiffies + 3 * HZ / 2;
+
+	/*switch usbX phy to host for CarPlay ,move to ehci/ohci reset thread*/
+	/*usb_switch(1); */
+#if 0
+	if (readl((void *)MO_STAMP) == IC_VERSION_A) {
+		is_vera = 1;
+		dma_fail = 1;
+		DEBUG_ERR("IC VerA\n");
+	}
+#endif
+
+	return 0;
+
+err:
+	return retval;
+}
+
+static void __exit udc_exit(void)
+{
+	if (accessory_port_id == 0) {
+		platform_driver_unregister(&sunplus_udc0_driver);
+	} else {
+		platform_driver_unregister(&sunplus_udc1_driver);
+	}
+}
+
+MODULE_LICENSE("GPL");
+
+module_init(udc_init);
+module_exit(udc_exit);
--- a/drivers/usb/gadget/udc/sunplus_udc.h	1970-01-01 03:00:00.000000000 +0300
+++ a/drivers/usb/gadget/udc/sunplus_udc.h	2018-11-12 06:42:55.000000000 +0300
@@ -0,0 +1,161 @@
+#ifndef _SUNPLUS_UDC_H
+#define _SUNPLUS_UDC_H
+
+#include <linux/wakelock.h>
+
+#define SP_MAXENDPOINTS      13
+#define EP0_FIFO_SIZE		 64	/*control Endpoint */
+#define EP12_FIFO_SIZE64	 64	/*full speed */
+#define EP_FIFO_SIZE		 64
+#define CONFIG_USB_SUNPLUS_EP11
+//#define CONFIG_USB_SUNPLUS_EP1
+#define CONFIG_USB_SUNPLUS_EP2
+#undef CONFIG_FIQ_GLUE
+
+static const char ep0name[] = "ep0";
+
+enum ep0_state {
+	EP0_IDLE,
+	EP0_IN_DATA_PHASE,
+	EP0_OUT_DATA_PHASE,
+	EP0_END_XFER,
+	EP0_STALL,
+};
+
+static const char *ep0states[] = {
+	"EP0_IDLE",
+	"EP0_IN_DATA_PHASE",
+	"EP0_OUT_DATA_PHASE",
+	"EP0_END_XFER",
+	"EP0_STALL",
+};
+
+struct sp_ep {
+	struct list_head queue;
+	unsigned long last_io;	/* jiffies timestamp */
+	struct usb_gadget *gadget;
+	struct sp_udc *dev;
+	const struct usb_endpoint_descriptor *desc;
+	struct usb_ep ep;
+	u8 num;
+
+	unsigned short fifo_size;
+	u8 bEndpointAddress;
+	u8 bmAttributes;
+
+	unsigned halted:1;
+	unsigned already_seen:1;
+	unsigned setup_stage:1;
+	spinlock_t lock;
+};
+
+struct sp_request {
+	struct list_head queue;	/* ep's requests */
+	struct usb_request req;
+	u8 *cmd_trb;
+};
+
+struct sp_udc {
+	spinlock_t lock;
+
+	struct sp_ep ep[SP_MAXENDPOINTS];
+	int address;
+	struct usb_gadget gadget;
+	struct usb_gadget_driver *driver;
+	struct sp_request fifo_req;
+
+	u8 fifo_buf[EP_FIFO_SIZE];
+	u16 devstatus;
+
+	u32 port_status;
+	int ep0state;
+
+#ifdef CONFIG_USB_SUNPLUS_OTG
+
+#define		ID_PIN					(1 << 16)
+#define		OTG_INT_ST_REG			(3)
+
+	int bus_num;
+	int suspend_sta;
+
+	struct work_struct work_otg;
+	struct workqueue_struct *qwork_otg;
+#endif
+#ifdef CONFIG_USB_SUNPLUS_EP1
+	struct work_struct work_ep1;
+	struct workqueue_struct *qwork_ep1;
+#endif
+#ifdef CONFIG_USB_SUNPLUS_EP2
+	struct work_struct work_ep2;
+	struct workqueue_struct *qwork_ep2;
+#endif
+#ifdef CONFIG_USB_SUNPLUS_EP11
+	struct work_struct work_ep11;
+	struct workqueue_struct *qwork_ep11;
+	struct work_struct work_ep11_dma;
+	struct workqueue_struct *qwork_ep11_dma;
+#endif
+
+	unsigned got_irq:1;
+
+	unsigned req_std:1;
+	unsigned req_config:1;
+	unsigned req_pending:1;
+	u8 vbus;
+	struct dentry *regs_info;
+	struct tasklet_struct ep1bulkin_task;
+	struct tasklet_struct ep2bulkout_task;
+	struct tasklet_struct epabulkin_task;
+	struct tasklet_struct epabulkin_dma_task;
+	struct tasklet_struct ep8bulkin_task;
+	struct tasklet_struct ep9bulkout_task;
+	struct wake_lock wake_lock;
+#ifdef CONFIG_FIQ_GLUE
+	struct fiq_glue_handler handler;
+#endif
+
+	struct work_struct work_ep3;
+	struct workqueue_struct *qwork_ep3;
+	struct work_struct work_ep9;
+	struct workqueue_struct *qwork_ep9;
+	struct work_struct work_configure;
+};
+
+extern int Q571_get_platform(void);
+/*for ISO DMA*/
+#define ALIGN_64	64
+#define TRB_NUM		256
+#define TRB_SIZE	16
+#define ALL_TRB_SIZE	(ALIGN_64+TRB_NUM*TRB_SIZE)
+#define E_TRB_SIZE	1024
+#define RCS_0		0
+#define RCS_1		1
+#define TRB_CC		(1 << 24)
+
+#define TRB_TC		(1 << 1)
+#define TRB_IOC		(1 << 5)
+#define TRB_NORMAL	(1 << 10)
+#define TRB_LINK	(3 << 11)
+#define TRB_IN		(1 << 16)
+
+struct iso_trb {
+	u32 ptr;
+	u32 rfu;
+	u32 size_cc;
+	u32 cmd;
+};
+/* udc endpoint*/
+#define EP0			0
+#define EP1			1
+#define EP2			2
+#define EP3			3
+#define EP4			4
+#define EP5			5
+#define EP6			6
+#define EP7			7
+#define EP8			8
+#define EP9			9
+#define EP10		10
+#define EP11		11
+#define EP12		12
+#endif
--- a/drivers/usb/gadget/udc/sunplus_udc_regs.h	1970-01-01 03:00:00.000000000 +0300
+++ a/drivers/usb/gadget/udc/sunplus_udc_regs.h	2018-11-12 06:42:55.000000000 +0300
@@ -0,0 +1,372 @@
+#ifndef _SUNPLUS_UDC_REGS_H
+#define _SUNPLUS_UDC_REGS_H
+/*USB_DEV_REG.pdf*/
+//#define AHB_USBD_BASE 0x40000800
+#undef AHB_USBD_BASE
+#define AHB_USBD_BASE0 0x9c102800
+#define AHB_USBD_END0	0x9c102c00
+#define AHB_USBD_BASE1 0x9c103800
+#define AHB_USBD_END1	0x9c103c00
+
+/*G0:--DMA Control Registers */
+#define  UEP12DMACS		0x000
+#define  UEP12DMADA		0x004
+#define  UDADMAS		0x008
+#define  UDADMADA		0x00c
+#define  UEP89DMACS		0x010
+#define  UEP89DMADA		0x014
+#define  UEPABDMACS		0x018
+#define  UEPABDMADA		0x01c
+#define  UDVDMACS		0x020
+#define  UDVDMADA		0x024
+#define  UDEPCDMACS		0x028
+#define  UDEPCDMADA		0x02c
+#define  UDEP2DMACS		0x030
+#define  UDEP2DMADA		0x034
+#define  UDEP9DMACS		0x038
+#define  UDEP9DMADA		0x03c
+#define  UDEPBDMACS		0x040
+#define  UDEPBDMADA		0x044
+
+/*G1:--System Domain Interrupt Registers */
+#define  UDCCS			0x080
+#define  UDCIE			0x084
+#define  UDCIF			0x088
+#define  UDADMA_CRCR		0x0c0
+#define  UDADMA_ERBAR		0x0c4
+#define  UDADMA_ERDPR		0x0c8
+#define  UDADMA_RCSR		0x0cc
+#define  UDADMA_RTR		0x0d0
+#define  UDVDMA_CRCR		0x0d4
+#define  UDVDMA_ERBAR		0x0d8
+#define  UDVDMA_ERDPR		0x0dc
+#define  UDVDMA_RCSR		0x0e0
+#define  UDVDMA_RTR		0x0e4
+#define  UDEPCDMA_CRCR		0x0e8
+#define  UDEPCDMA_ERBAR		0x0ec
+#define  UDEPCDMA_ERDPR		0x0f0
+#define  UDEPCDMA_RCSR		0x0f4
+#define  UDEPCDMA_RTR		0x0f8
+
+/*G2:--EP0/1/2/3/4 Control Registers */
+#define  UDLCSET		0x100
+#define  UDLCSTL		0x104
+#define  UDLCADDR		0x10c
+#define  UDEP0SDP		0x110
+#define  UDEP0CS		0x114
+#define  UDEP0DC		0x118
+#define  UDEP0DP		0x11c
+#define  UDEP0VB		0x120
+#define  UDEP0ONAKCN		0x124
+#define  UDEP0INAKCN		0x128
+#define  UDCMSTC		0x130
+#define  UDEP12C		0x134
+#define  UDEP12PPC		0x138
+#define  UDEP12FS		0x13c
+#define  UDEP12PIC		0x140
+#define  UDEP12POC		0x144
+#define  UDEP12FDP		0x148
+#define  UDEP12VB		0x14c
+#define  UDEP1SCS		0x150
+#define  UDEP1SDP		0x154
+#define  UDEP1INAKCN		0x158
+#define  UDEP2ONAKCN		0x15c
+#define  UDEP3VB		0x160
+#define  UDEP3CTRL		0x164
+#define  UDEP3PTR		0x168
+#define  UDEP3DATA		0x16c
+#define  UDEP4CTRL		0x170
+#define  UDEP4PTR		0x174
+#define  UDEP4DATA		0x178
+#define  UDEP4VB		0x17c
+
+/*G3:--EP5/6/7  Control Registers */
+#define  UDEP5CTRL		0x180
+#define  UDEP5HDLEN		0x184
+#define  UDEP5FRAME		0x188
+#define  UDEP5HDCTRL		0x18c
+#define  UDEP5RPT		0x190
+#define  UDEP5WPT		0x194
+#define  UDEP5DATA		0x198
+#define  UDSRE			0x19c
+#define  UDFT			0x1a0
+#define  UDEP5VB		0x1a4
+#define  UDSTCDIV		0x1a8
+#define  UDEP6CTRL		0x1c0
+#define  UDEP6PTR		0x1c4
+#define  UDEP6DATA		0x1c8
+#define  UDEP6VB		0x1cc
+#define  UDEP7CTRL		0x1e0
+#define  UDEP7RPTR		0x1e4
+#define  UDEP7WPTR		0x1e8
+#define  UDEP7DATA		0x1ec
+#define  UDEP7VB		0x1f0
+
+/*G4:--EP8/9/A/B  Control Registers */
+#define  UDEP89C		0x200
+#define  UDEP89PPC		0x204
+#define  UDEP89FS		0x208
+#define  UDEP89PIC		0x20c
+#define  UDEP89C		0x200
+#define  UDEP89PPC		0x204
+#define  UDEP89FS		0x208
+#define  UDEP89PIC		0x20c
+#define  UDEP89POC		0x210
+#define  UDEP89FDP		0x214
+#define  UDEP89VB		0x218
+#define  UDEP8INAKCN		0x21c
+#define  UDEP9ONAKCN		0x220
+#define  UDEP89S		0x224
+#define  UDEPABC		0x240
+#define  UDEPABPPC		0x244
+#define  UDEPABFS		0x248
+#define  UDEPABPIC		0x24c
+#define  UDEPABPOC		0x250
+#define  UDEPABFDP		0x254
+#define  UDEPABVB		0x258
+#define  UDEPAINAKCN		0x25c
+#define  UDEPBONAKCN		0x260
+#define  UDEPABS		0x264
+
+/*G5:--EPC/D  Control Registers */
+#define  UDEPCCTRL		0x280
+#define  UDEPCRPT		0x284
+#define  UDEPCWPT		0x288
+#define  UDEPCDATA		0x28c
+#define  UDEPCS			0x290
+#define  UDEPCBDC		0x294
+#define  UDEPDCTRL		0x298
+#define  UDEPDST		0x29c
+#define  UDEPDDATA		0x2a0
+
+/*G6:--Phyclk Domain Interrupt Registers */
+#define  UDLIF			0x300
+#define  UDLIE			0x304
+#define  UDNBIF			0x308
+#define  UDNBIE			0x30c
+
+#define  UDFRNUM		0x310
+#define  IP_Name		0x378
+#define  VERSION		0x37c
+
+/*G7:--Bulk Out FIFO Control Registeres */
+#define  UDEP2PPC		0x380
+#define  UDEP2FS		0x384
+#define  UDEP2PIC		0x388
+#define  UDEP2POC		0x38c
+
+#define  UDEP2FDP		0x390
+#define  UDEP2VB		0x394
+
+#define  UDEP9PPC		0x3a0
+#define  UDEP9FS		0x3a4
+#define  UDEP9PIC		0x3a8
+#define  UDEP9POC		0x3ac
+
+#define  UDEP9FDP		0x3b0
+#define  UDEP9VB		0x3b4
+
+#define  UDEPBPPC		0x3c0
+#define  UDEPBFS		0x3c4
+#define  UDEPBPIC		0x3c8
+#define  UDEPBPOC		0x3cc
+
+#define  UDEPBFDP		0x3d0
+#define  UDEPBVB		0x3d4
+
+ /*DMA*/
+#define  DMA_EN           	(1 << 31)
+#define  DMA_FLUSHEND		(1 << 30)
+#define  DMA_FLUSH		(1 << 29)
+#define  DMA_WRITE		(1 << 28)
+#define  DMA_COUNT_ALIGN	(1 << 27)
+#define  DMA_COUNT_MASK		((1 << 22) - 1)	/*21bit:0x1F FF FF */
+/*AUDIO COUNT MASK*/
+#define  DMAA_COUNT_MASK	((1 << 16) - 1)	/*15bit:0x1F FF */
+/*USB Device Controller Control Status (UDCCS)*/
+#define  USB_CLK_EN           	(1 << 31)
+#define  UPHY_CLK_CSS           (1 << 30)
+#define  UPHY_SUSP           	(1 << 29)
+#define  ISSUE_RESUME           (1 << 28)
+#define  VBUS_PRE           	(1 << 25)
+#define  VBUS           	(1 << 24)
+#define  VBUS_SAMPLE_MASK	((1 << 16) - 1)	/*15bit:0x1F FF */
+/*UDCIE UDCIF*/
+#define EPC_TRB_IF 		(1 << 15)
+#define VIDEO_TRB_IF		(1 << 14)
+#define AUDIO_TRB_IF		(1 << 13)
+#define EPC_ERF_IF		(1 << 12)
+#define VIDEO_ERF_IF		(1 << 11)
+#define AUDIO_ERF_IF		(1 << 10)
+#define EPB_DMA_IF		(1 << 9)
+#define EP9_DMA_IF		(1 << 8)
+#define EP2_DMA_IF		(1 << 7)
+#define EPC_DMA_IF		(1 << 6)
+#define VIDEO_DMA_IF		(1 << 5)
+#define EPAB_DMA_IF		(1 << 4)
+#define EP89_DMA_IF		(1 << 3)
+#define AUDIO_DMA_IF		(1 << 2)
+#define EP12_DMA_IF		(1 << 1)
+#define VBUS_IF			(1 << 0)
+/*UDADMA_CRCR*/
+#define  CRPTR_MASK		0xFFFFFFC0	/*0xFF FF FF C0 */
+#define  CRR			(1 << 3)
+#define  CS			(1 << 1)
+#define  RCS			(1 << 0)
+#define  ERBA_MASK		0xFFFFFFF0	/*0xFF FF FF F0 */
+#define  ERBP_MASK		0xFFFFFFF0	/*0xFF FF FF F0 */
+#define  CRT			(1 << 0)	/*Command Ring Trig */
+/*USB Device Linker Layer Controller Setting (UDLCSET)*/
+#define  CURR_LINSTATE_MASK	(0X3 << 18)	/*bit18~19 */
+#define  CURR_ALT_MASK		(0XF << 13)	/*bit13~16 */
+#define  CURR_INTF_MASK		(0XF << 9)	/*bit9~12 */
+#define  CURR_SPEED		(1 << 8)
+#define SUPP_SYNCFRAME		(1 << 5)
+#define SUPP_SETDESC		(1 << 4)
+#define NEG_SAMPLE_EN		(1 << 3)
+#define FORCE_FULLSP		(1 << 2)
+#define SIM_MODE		(1 << 1)
+#define SOFT_DISC		(1 << 0)
+/*UDLCSTL */
+#define CLREPDSTL		(1 << 26)
+#define CLREPBSTL 		(1 << 25)
+#define CLREPASTL		(1 << 24)
+#define CLREP9STL		(1 << 23)
+#define CLREP8STL		(1 << 22)
+#define CLREP6STL		(1 << 21)
+#define CLREP4STL		(1 << 20)
+#define CLREP3STL		(1 << 19)
+#define CLREP2STL		(1 << 18)
+#define CLREP1STL		(1 << 17)
+#define CLREP0STL		(1 << 16)
+#define SETEPDSTL		(1 << 10)
+#define SETEPBSTL		(1 << 9)
+#define SETEPASTL		(1 << 8)
+#define SETEP9STL		(1 << 7)
+#define SETEP8STL		(1 << 6)
+#define SETEP6STL		(1 << 5)
+#define SETEP4STL		(1 << 4)
+#define SETEP3STL		(1 << 3)
+#define SETEP2STL		(1 << 2)
+#define SETEP1STL		(1 << 1)
+#define SETEP0STL		(1 << 0)
+/*Device address register*/
+#define ADDR_VLD		(1 << 7)
+#define  DEV_ADDR_MASK		((1 << 7) - 1)	/*6bit */
+/*UDEP0CS*/
+#define EP0_OUT_EMPTY		(1 << 5)
+#define EP0_OVLD		(1 << 4)
+#define CLR_EP0_OUT_VLD		(1 << 3)
+#define EP0_IVLD		(1 << 2)
+#define SET_EP0_IN_VLD		(1 << 1)
+#define EP0_DIR			(1 << 0) /*IN*/
+#define  EP0_DATA_CNTR_MASK		((1 << 7) - 1)	/*6bit */
+/*UDEP12C*/
+#define SET_EP_IVLD		(1 << 4)
+#define CLR_EP_OVLD		(1 << 3)
+#define RESET_PIPO_FIFO		(1 << 2)
+#define EP_ENA			(1 << 1)
+#define EP_DIR			(1 << 0)
+#define CURR_BUFF		(1 << 2)
+#define SWITCH_BUFF		(1 << 1)
+#define AUTO_SWITCH_EN		(1 << 0)
+/*UDEP12FS*/
+#define N_MSDC_CMD		(1 << 7)
+#define A_FIFO_EMPTY		(1 << 6)
+#define A_EP_OVLD		(1 << 5)
+#define A_EP_IVLD		(1 << 4)
+#define MSDC_CMD_VLD		(1 << 3)
+#define FIFO_EMPTY		(1 << 2)
+#define EP_OVLD		(1 << 1)
+#define EP_IVLD		(1 << 0)
+#define RESET_EP_PING_CNTR		(1 << 12)
+#define RESET_EP_PONG_CNTR		(1 << 12)
+/* EP3CS */
+#define EP3_VLD        		(1 << 3)
+#define EP3_EN       		(1 << 0)
+#define EP4_VLD        		(1 << 3)
+#define EP4_EN       		(1 << 0)
+#define UDEP5FLUSH		(1 << 2)
+#define UDEP5HDEN		(1 << 1)
+#define UDEP5EN			(1 << 0)
+#define EP5CTRLEMPTY		(1 << 7)
+#define EP5CTRLFULL		(1 << 6)
+#define UDEP5FRAMEID		(1 << 0)
+#define UDEP5ERROR		(1 << 4)
+#define UDEP5FRAMEND		(1 << 3)
+#define UDEP5FRAMESTILL		(1 << 2)
+#define UDEP5FRAMESRC		(1 << 1)
+#define UDEP5FRAMEPT		(1 << 0)
+#define EP6_VLD        		(1 << 3)
+#define EP6_EN       		(1 << 0)
+/*UDEP89C*/
+#define SET_EP8_IVLD		(1 << 4)
+#define CLR_EP9_OVLD		(1 << 3)
+#define EP89_RESET_PIPO_FIFO	(1 << 2)
+#define EP89_ENA		(1 << 1)
+#define EP89_DIR		(1 << 0)
+#define EPAB_DIR		(1 << 3)
+#define UDEPCEMPTY		(1 << 3)
+#define UDEPCFULL		(1 << 2)
+#define UDEPCFLUSH		(1 << 1)
+#define UDEPCEN			(1 << 0)
+#define EPC_SUCC_IF		(1 << 31)
+#define EPC_FAIL_IF		(1 << 30)
+#define EPC_OFLOW_IF		(1 << 29)
+#define EPC_DERR_IF		(1 << 28)
+#define EP6_FAIL_IF		(1 << 27)
+#define EP3_FAIL_IF		(1 << 26)
+#define EP7_DMA_IF		(1 << 25)
+#define EP5_DMA_IF		(1 << 24)
+#define EP7I_IF			(1 << 23)
+#define EP6I_IF			(1 << 22)
+#define EP5I_IF			(1 << 21)
+#define EP4I_IF			(1 << 20)
+#define URES_IF			(1 << 29)
+#define RESET_RELEASE_IF	(1 << 19)
+#define EP4_FAIL_IF		(1 << 18)
+#define RESU_IF			(1 << 17)
+#define SUS_IF			(1 << 16)
+#define EP1_DMA_IF		(1 << 15)
+#define EP3I_IF			(1 << 14)
+#define PIPO_IF			(1 << 13)
+#define TEST_IF			(1 << 12)
+#define EP2N_IF			(1 << 11)
+#define EP1N_IF			(1 << 10)
+#define EP0N_IF			(1 << 9)
+#define ADDR_IF			(1 << 8)
+#define EP2O_IF			(1 << 7)
+#define EP1I_IF			(1 << 6)
+#define EP1SI_IF		(1 << 5)
+#define EP0I_IF			(1 << 4)
+#define EP0O_IF			(1 << 3)
+#define EP0S_IF			(1 << 2)
+#define SUSP_IF			(1 << 1)
+#define RESET_IF		(1 << 0)
+#define EPDOVLD_IF		(1 << 16)
+#define SOF_IF			(1 << 15)
+#define PIPOEPB_IF		(1 << 14)
+#define PIPOEP9_IF		(1 << 13)
+#define PIPOEP2_IF		(1 << 12)
+#define EP11O_IF		(1 << 11)
+#define EP10I_IF		(1 << 10)
+#define EP11N_IF		(1 << 9)
+#define EP10N_IF		(1 << 8)
+#define PIPOEPAB_IF		(1 << 7)
+#define EPADMA_IF		(1 << 6)
+#define EP9O_IF			(1 << 5)
+#define EP8I_IF			(1 << 4)
+#define EP9N_IF			(1 << 3)
+#define EP8N_IF			(1 << 2)
+#define EP89PIPO_IF		(1 << 1)
+#define EP8DMA_IF		(1 << 0)
+/*UEP12DMACS cotroll RX */
+#define RX_STEP1        (1 << 24)
+#define RX_STEP2        (1 << 25)
+#define RX_STEP3        ((1 << 24) | (1 << 25))
+#define RX_STEP4        (1 << 26)
+#define RX_STEP5        ((1 << 24) | (1 << 26))
+#define RX_STEP6        ((1 << 25) | (1 << 26))
+#define RX_STEP7        ((1 << 24) | (1 << 25) | (1 << 26))
+
+#endif /*_SUNPLUS_UDC_REGS_H*/
--- a/drivers/usb/gadget/u_f.c	2018-11-23 10:16:15.968818508 +0300
+++ a/drivers/usb/gadget/u_f.c	2018-11-23 10:31:03.791051407 +0300
@@ -14,20 +14,3 @@
 #include "u_f.h"
 #include <linux/usb/ch9.h>
 
-struct usb_request *alloc_ep_req(struct usb_ep *ep, size_t len)
-{
-	struct usb_request      *req;
-
-	req = usb_ep_alloc_request(ep, GFP_ATOMIC);
-	if (req) {
-		req->length = usb_endpoint_dir_out(ep->desc) ?
-			usb_ep_align(ep, len) : len;
-		req->buf = kmalloc(req->length, GFP_ATOMIC);
-		if (!req->buf) {
-			usb_ep_free_request(ep, req);
-			req = NULL;
-		}
-	}
-	return req;
-}
-EXPORT_SYMBOL_GPL(alloc_ep_req);
--- a/drivers/usb/gadget/u_f.h	2018-11-23 10:16:15.968818508 +0300
+++ a/drivers/usb/gadget/u_f.h	2018-11-23 10:31:03.790051467 +0300
@@ -59,13 +59,5 @@
  * usb_requests's length (req->length) to refer to the allocated buffer size.
  * Requests allocated via alloc_ep_req() *must* be freed by free_ep_req().
  */
-struct usb_request *alloc_ep_req(struct usb_ep *ep, size_t len);
-
-/* Frees a usb_request previously allocated by alloc_ep_req() */
-static inline void free_ep_req(struct usb_ep *ep, struct usb_request *req)
-{
-	kfree(req->buf);
-	usb_ep_free_request(ep, req);
-}
 
 #endif /* __U_F_H__ */
--- a/drivers/usb/host/ehci0-sunplus.c	1970-01-01 03:00:00.000000000 +0300
+++ a/drivers/usb/host/ehci0-sunplus.c	2018-11-12 06:42:55.000000000 +0300
@@ -0,0 +1,60 @@
+#include <linux/usb/sp_usb.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include "ehci-platform.h"
+
+extern void usb_hcd_platform_shutdown(struct platform_device *dev);
+
+static int ehci0_sunplus_platform_probe(struct platform_device *dev){
+
+	dev->id = 1;
+
+	return ehci_platform_probe(dev);
+}
+
+static const struct of_device_id ehci0_sunplus_dt_ids[] = {
+	{ .compatible = "sunplus,sunplus-q628-usb-ehci0" },
+	{ }
+};
+
+MODULE_DEVICE_TABLE(of, ehci0_sunplus_dt_ids);
+
+
+struct platform_driver ehci0_hcd_sunplus_driver = {
+	.probe			= ehci0_sunplus_platform_probe,
+	.remove			= ehci_platform_remove,
+	.shutdown		= usb_hcd_platform_shutdown,
+#ifdef CONFIG_PM_WARP
+	.resume 		= sp_ehci_fb_resume,
+	.suspend 		= sp_ehci_fb_suspend,
+#endif
+	.driver = {
+		.name		= "ehci0-sunplus",
+		.of_match_table = ehci0_sunplus_dt_ids,
+	}
+};
+
+/*-------------------------------------------------------------------------*/
+
+static int __init ehci0_sunplus_init(void)
+{
+	if (sp_port_enabled & PORT0_ENABLED){
+		printk(KERN_NOTICE "register ehci0_hcd_sunplus_driver\n");
+		return platform_driver_register(&ehci0_hcd_sunplus_driver);
+	} else {
+		printk(KERN_NOTICE "warn,port0 not enable,not register ehci0 sunplus hcd driver\n");
+		return -1;
+	}
+}
+module_init(ehci0_sunplus_init);
+
+static void __exit ehci0_sunplus_cleanup(void)
+{
+	platform_driver_unregister(&ehci0_hcd_sunplus_driver);
+}
+module_exit(ehci0_sunplus_cleanup);
+
+MODULE_ALIAS("platform:ehci0-sunplus");
+MODULE_DESCRIPTION(DRIVER_DESC);
+MODULE_LICENSE("GPL");
+
--- a/drivers/usb/host/ehci1-sunplus.c	1970-01-01 03:00:00.000000000 +0300
+++ a/drivers/usb/host/ehci1-sunplus.c	2018-11-12 06:42:55.000000000 +0300
@@ -0,0 +1,60 @@
+#include <linux/usb/sp_usb.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include "ehci-platform.h"
+
+extern void usb_hcd_platform_shutdown(struct platform_device *dev);
+
+static int ehci1_sunplus_platform_probe(struct platform_device *dev){
+
+	dev->id = 2;
+
+	return ehci_platform_probe(dev);
+}
+
+static const struct of_device_id ehci1_sunplus_dt_ids[] = {
+	{ .compatible = "sunplus,sunplus-q628-usb-ehci1" },
+	{ }
+};
+
+MODULE_DEVICE_TABLE(of, ehci1_sunplus_dt_ids);
+
+
+static struct platform_driver ehci1_hcd_sunplus_driver = {
+	.probe			= ehci1_sunplus_platform_probe,
+	.remove			= ehci_platform_remove,
+	.shutdown		= usb_hcd_platform_shutdown,
+#ifdef CONFIG_PM_WARP
+	.resume 		= sp_ehci_fb_resume,
+	.suspend 		= sp_ehci_fb_suspend,
+#endif
+	.driver = {
+		.name		= "ehci1-sunplus",
+		.of_match_table = ehci1_sunplus_dt_ids,
+	}
+};
+
+/*-------------------------------------------------------------------------*/
+
+static int __init ehci1_sunplus_init(void)
+{
+	if (sp_port_enabled & PORT1_ENABLED){
+		printk(KERN_NOTICE "register ehci1_hcd_sunplus_driver\n");
+		return platform_driver_register(&ehci1_hcd_sunplus_driver);
+	} else {
+		printk(KERN_NOTICE "warn,port1 not enable,not register ehci1 sunplus hcd driver\n");
+		return -1;
+	}
+}
+module_init(ehci1_sunplus_init);
+
+static void __exit ehci1_sunplus_cleanup(void)
+{
+	platform_driver_unregister(&ehci1_hcd_sunplus_driver);
+}
+module_exit(ehci1_sunplus_cleanup);
+
+MODULE_ALIAS("platform:ehci1-sunplus");
+MODULE_DESCRIPTION(DRIVER_DESC);
+MODULE_LICENSE("GPL");
+
--- a/drivers/usb/host/ehci.h	2018-11-23 10:16:15.980817795 +0300
+++ a/drivers/usb/host/ehci.h	2018-11-23 10:31:03.806050516 +0300
@@ -271,6 +271,20 @@
 	unsigned long		priv[0] __aligned(sizeof(s64));
 };
 
+#ifdef CONFIG_USB_HOST_RESET_SP
+struct ehci_hcd_sp {
+	/* must be 1st member here for hcd_to_ehci() to work */
+	struct ehci_hcd ehci;
+
+	struct task_struct	  	*reset_thread;
+	struct notifier_block 	 ehci_notifier;
+
+	u32 dum[3];
+
+	u32 flag;
+};
+#endif
+
 /* convert between an HCD pointer and the corresponding EHCI_HCD */
 static inline struct ehci_hcd *hcd_to_ehci(struct usb_hcd *hcd)
 {
--- a/drivers/usb/host/ehci-hcd.c	2018-11-23 10:16:15.978817914 +0300
+++ a/drivers/usb/host/ehci-hcd.c	2018-11-23 10:31:03.802050753 +0300
@@ -39,6 +39,9 @@
 #include <linux/dma-mapping.h>
 #include <linux/debugfs.h>
 #include <linux/slab.h>
+#include <linux/platform_device.h>
+#include <linux/usb/sp_usb.h>
+#include <linux/kthread.h>
 
 #include <asm/byteorder.h>
 #include <asm/io.h>
@@ -706,6 +709,7 @@
 	u32			status, masked_status, pcd_status = 0, cmd;
 	int			bh;
 	unsigned long		flags;
+	u32 port_status;
 
 	/*
 	 * For threadirqs option we use spin_lock_irqsave() variant to prevent
@@ -843,11 +847,57 @@
 	if (bh)
 		ehci_work (ehci);
 	spin_unlock_irqrestore(&ehci->lock, flags);
-	if (pcd_status)
+	if (pcd_status){
+#ifdef CONFIG_USB_HOST_NOT_FINISH_QTD_WHEN_DISC_WORKAROUND
+		port_status = ehci_readl(ehci, &ehci->regs->port_status[0]);
+		if ((!(port_status & PORT_CONNECT))
+		    || (port_status & PORT_CSC)) {
+			tasklet_schedule(&hcd->host_irq_tasklet);
+		}
+#endif
 		usb_hcd_poll_rh_status(hcd);
+	}
 	return IRQ_HANDLED;
 }
 
+#ifdef CONFIG_USB_HOST_NOT_FINISH_QTD_WHEN_DISC_WORKAROUND
+struct api_context {
+	struct completion done;
+	int status;
+};
+static void ehci_irq_tasklet(unsigned long data)
+{
+	int port_status;
+	struct api_context *ctx;
+	struct platform_device *pdev;
+	struct usb_hcd *hcd = (void *)data;
+	struct ehci_hcd *ehci = hcd_to_ehci(hcd);
+
+	pdev = to_platform_device(hcd->self.controller);
+	port_status = ehci_readl(ehci, &ehci->regs->port_status[0]);
+	printk(KERN_NOTICE "ehci_irq,id:%d,ps:%x\n",pdev->id - 1,port_status);
+	if (hcd->current_active_urb && hcd->enum_msg_flag) {
+		printk(KERN_NOTICE "ehci_irq,dev disc,ps:%x\n",port_status);
+		ctx = hcd->current_active_urb->context;
+		hcd->enum_msg_flag = false;
+		hcd->current_active_urb = NULL;
+		ctx->status = -ENOTCONN_IRQ;
+		complete(&ctx->done);
+	}
+
+}
+#endif
+
+int ehci_get_port_status_from_register(struct usb_hcd *hcd)
+{
+	struct ehci_hcd *ehci = hcd_to_ehci(hcd);
+	int port_status = ehci_readl(ehci, &ehci->regs->port_status[0]);
+
+	printk(KERN_DEBUG "e_ps:%x\n", port_status);
+
+	return port_status;
+}
+
 /*-------------------------------------------------------------------------*/
 
 /*
@@ -1262,6 +1312,461 @@
 }
 EXPORT_SYMBOL_GPL(ehci_init_driver);
 
+//remon add for logo test
+#ifdef CONFIG_USB_LOGO_TEST
+#include <mach/io_map.h>
+
+#define TEST_MODE_NOT_ENABLED 		(0<<16)
+#define TEST_J_STATE				(1<<16)
+#define TEST_K_STATE				(2<<16)
+#define TEST_SE0_NAK_1				(3<<16)
+#define TEST_Packet					(4<<16)
+#define TEST_FORCE_ENABLE			(5<<16)
+
+struct ehci_qh *qh;
+struct ehci_qtd *qtd_setup;
+struct ehci_qtd *qtd_in;
+struct ehci_qtd *qtd_out;
+u8 g_USB_addr = 0;
+u32 g_USB_endpoint = 0;
+struct usb_ctrlrequest *setup_buf = NULL;
+u8 *in_buf = NULL;
+dma_addr_t setup_dma, setup_dma_init;
+dma_addr_t in_dma, in_dma_init;
+dma_addr_t out_dma, out_dma_init;
+u32 transfer_lenth = 0;
+
+void Ehci_Init_var(struct ehci_hcd *ehci)
+{
+	struct usb_hcd *hcd = ehci_to_hcd(ehci);
+	qh = ehci_qh_alloc(ehci, GFP_ATOMIC);
+	if (NULL == qh) {
+		printk("in %s %d Malloc error\n", __FUNCTION__, __LINE__);
+		return;
+	}
+
+	qh->hw->hw_next = 0;
+	qh->hw->hw_info1 = 0x00008000;
+	qh->hw->hw_info2 = 1 << 30;
+	qh->hw->hw_current = 0;
+	qh->hw->hw_qtd_next = 1;
+	qh->hw->hw_alt_next = 1;
+	qh->hw->hw_buf[0] = 0;
+	qh->hw->hw_buf[1] = 0;
+	qh->hw->hw_buf[2] = 0;
+	qh->hw->hw_buf[3] = 0;
+	qh->hw->hw_buf[4] = 0;
+
+	qh->hw->hw_info1 =
+	    ((2 << 12) | (1 << 15) | (4 << 28) | (64 << 16) | (1 << 14));
+	qh->hw->hw_next = ((1 << 1) | (qh->qh_dma));
+
+	qh->hw->hw_info1 |= ((g_USB_endpoint << 8) | g_USB_addr);
+
+	if (g_USB_endpoint == 0) {
+		qh->hw->hw_info2 = 1 << 30;
+	} else {
+		qh->hw->hw_info2 = 3 << 30;
+	}
+
+	ehci_writel(ehci, qh->qh_dma, &ehci->regs->async_next);
+
+	qtd_setup = ehci_qtd_alloc(ehci, GFP_ATOMIC);
+	qtd_in = ehci_qtd_alloc(ehci, GFP_ATOMIC);
+	qtd_out = ehci_qtd_alloc(ehci, GFP_ATOMIC);
+	if (qtd_setup == NULL || qtd_in == NULL || qtd_out == NULL) {
+		ehci_dbg(ehci, "no dummy td\n");
+		return;
+	}
+
+	qtd_setup->hw_token = QTD_STS_ACTIVE;
+	qtd_setup->hw_token |= (3 << 10);
+	qtd_setup->hw_token |= QTD_IOC;
+
+	qtd_in->hw_token = QTD_STS_ACTIVE;
+	qtd_in->hw_token |= (3 << 10);
+	qtd_in->hw_token |= QTD_IOC;
+
+	qtd_out->hw_token = QTD_STS_ACTIVE;
+	qtd_out->hw_token |= (3 << 10);
+	qtd_out->hw_token |= QTD_IOC;
+
+	setup_buf = kmalloc(sizeof(struct usb_ctrlrequest), 0);
+
+	setup_buf->bRequestType = 0x80;
+	setup_buf->bRequest = 0x06;
+	setup_buf->wValue = cpu_to_le16(0x0100);
+	setup_buf->wIndex = cpu_to_le16(0);
+	setup_buf->wLength = cpu_to_le16(0x12);
+
+	setup_dma = dma_map_single(hcd->self.controller,
+				   setup_buf,
+				   sizeof(struct usb_ctrlrequest),
+				   DMA_TO_DEVICE);
+	if (dma_mapping_error(hcd->self.controller, setup_dma)) {
+		printk("mapping error\n");
+		return;
+	}
+
+	qtd_setup->hw_buf[0] = setup_dma;
+
+	setup_dma_init = setup_dma;
+	transfer_lenth = setup_buf->wLength;
+
+	in_buf = kmalloc(512 + 31, 0);
+	if (NULL == in_buf) {
+		printk("in %s %d Malloc error\n", __FUNCTION__, __LINE__);
+		return;
+	}
+	in_buf = (u8 *) (((u32) in_buf) & (~31));
+	in_dma = dma_map_single(hcd->self.controller,
+				in_buf,
+				sizeof(struct usb_ctrlrequest),
+				DMA_FROM_DEVICE);
+	if (dma_mapping_error(hcd->self.controller, in_dma)) {
+		printk("mapping error\n");
+		return;
+	}
+
+	qtd_in->hw_buf[0] = in_dma;
+	in_dma_init = in_dma;
+
+	g_USB_endpoint = 0;
+	g_USB_addr = 0;
+}
+
+void Ehci_unInit_var(struct ehci_hcd *ehci)
+{
+	ehci_qtd_free(ehci, qtd_setup);
+	ehci_qtd_free(ehci, qtd_in);
+	ehci_qtd_free(ehci, qtd_out);
+	qh_destroy(ehci, qh);
+}
+
+#if 0
+void __Fill_td(struct ehci_hcd *ehci, struct ehci_qtd *qtd, dma_addr_t dma_addr,
+	       u32 wLen)
+{
+	u32 i, count;
+
+	count = 0x1000 - (dma_addr & 0x0fff);	/* rest of that page */
+	if (wLen < count)	/* ... iff needed */
+		count = wLen;
+	else {
+		dma_addr += 0x1000;
+		dma_addr &= ~0x0fff;
+
+		/* per-qtd limit: from 16K to 20K (best alignment) */
+		for (i = 1; count < wLen && i < 5; i++) {
+			qtd->hw_buf[i] = dma_addr;
+			dma_addr += 0x1000;
+			if ((count + 0x1000) < wLen)
+				count += 0x1000;
+			else
+				count = wLen;
+		}
+	}
+
+	qtd->hw_token &= (~(0x7fff << 16));
+	qtd->hw_token |= (count << 16);
+}
+#endif
+
+void USB_transfer(struct ehci_hcd *ehci, struct ehci_qtd *qtd,
+		 dma_addr_t dma_addr, u32 wLen)
+{
+	u32 temp;
+	printk(">>> USB_transfer...\n");
+
+	//Fill  td
+	//__Fill_td(ehci, qtd, dma_addr, wLen);
+
+	printk("qh->hw->hw_next = 0x%08x\n", qh->hw->hw_next);
+	qh->hw->hw_current = (u32) qtd->qtd_dma;
+	qh->hw->hw_qtd_next = qtd->hw_next;
+	qh->hw->hw_alt_next = qtd->hw_alt_next;
+	qh->hw->hw_buf[0] = qtd->hw_buf[0];
+	qh->hw->hw_buf[1] = qtd->hw_buf[1];
+	qh->hw->hw_buf[2] = qtd->hw_buf[2];
+	qh->hw->hw_buf[3] = qtd->hw_buf[3];
+	qh->hw->hw_buf[4] = qtd->hw_buf[4];
+	qh->hw->hw_token = qtd->hw_token;
+
+	//Go
+	temp = ehci_readl(ehci, &ehci->regs->command);
+	temp &= (~CMD_PSE);
+	ehci_writel(ehci, temp | CMD_ASE, &ehci->regs->command);
+
+	temp = ehci_readl(ehci, &ehci->regs->command);
+	ehci_writel(ehci, temp | CMD_IAAD, &ehci->regs->command);	//4
+
+#if 0				//kernal  & clear
+	//wait
+	do {
+		temp = ehci_readl(ehci, &ehci->regs->command);
+		if (CMD_IAAD & temp) {
+			udelay(4);
+			continue;
+		}
+
+		mdelay(10);
+
+		while (1) {
+			temp = ehci_readl(ehci, &ehci->regs->status);
+			printk("temp = 0x%08x\n", temp);
+			if (0x02 & temp) {
+				printk("found a error %x ", temp);
+				//Need Clear stall
+				temp = g_USB_endpoint;
+				if ((((qh->dummy->hw_token) >> 8) & 3) == 1)	//in
+				{
+					temp |= 0x80;
+				}
+				return temp;	//Return is endpoint .Clear stall will use it
+			}
+			//normal complete
+			if (0x01 & temp) {
+				printk("STS_INT");
+				break;
+			}
+
+			udelay(4);
+			printk("======= ehci_usb_debug=0x%08x\n",
+			       ehci_readl(ehci, &ehci->regs->ehci_usb_debug));
+			printk("======= ehci_sys_debug=0x%08x\n",
+			       ehci_readl(ehci, &ehci->regs->ehci_sys_debug));
+		}
+
+		//Clear int
+		ehci_writel(ehci, temp & 3, &ehci->regs->status);	//4
+		//Disbale AS, cause we not add the dummy qh,qtd to save mem
+
+		temp = ehci_readl(ehci, &ehci->regs->command);
+		if (temp & CMD_ASE) {
+			ehci_writel(ehci, temp & (~CMD_ASE),
+				    &ehci->regs->command);
+		}
+
+		break;
+	} while (1);
+#else
+	mdelay(5);
+	temp = ehci_readl(ehci, &ehci->regs->command);
+	if (temp & CMD_ASE) {
+		ehci_writel(ehci, temp & (~CMD_ASE), &ehci->regs->command);
+	}
+#endif
+
+	if (g_USB_endpoint) {
+		if (qtd->hw_token & QTD_TOGGLE) {
+			qtd->hw_token |= QTD_TOGGLE;
+		} else {
+			qtd->hw_token &= ~QTD_TOGGLE;
+		}
+	}
+	//Here make sure AS have disable, move here to save wait time
+	while ((ehci_readl(ehci, &ehci->regs->status) & STS_ASS)) {
+		udelay(2);
+	}
+
+	printk("<<< USB_transfer...\n");
+}
+
+static void Ehci_Host_Setup(struct ehci_hcd *ehci)
+{
+	printk(">>> Ehci_Host_Setup...\n");
+
+	qtd_setup->hw_token = QTD_STS_ACTIVE;
+	qtd_setup->hw_token |= (3 << 10);
+	qtd_setup->hw_token |= QTD_IOC;
+
+	qtd_setup->hw_token |= (2 /* "setup" */  << 8);
+	qtd_setup->hw_token &= (~(0x7fff << 16));
+	qtd_setup->hw_token |= (8 << 16);
+
+	setup_dma = setup_dma_init;
+	qtd_setup->hw_buf[0] = setup_dma;
+
+	USB_transfer(ehci, qtd_setup, setup_dma, 8);
+}
+
+static void Ehci_Host_In(struct ehci_hcd *ehci)
+{
+	printk(">>> Ehci_Host_In...\n");
+
+	qtd_in->hw_token = QTD_STS_ACTIVE;
+	qtd_in->hw_token |= (3 << 10);
+	qtd_in->hw_token |= QTD_IOC;
+
+	qtd_in->hw_token |= (01 /* "in" */  << 8);
+	qtd_in->hw_token &= (~(0x7fff << 16));
+	qtd_in->hw_token |= (transfer_lenth << 16);
+
+	in_dma = in_dma_init;
+	qtd_in->hw_buf[0] = in_dma;
+
+	qtd_in->hw_token |= QTD_TOGGLE;	/* force DATA1 */
+
+	USB_transfer(ehci, qtd_in, in_dma, transfer_lenth);
+}
+
+static void Ehci_Host_Out(struct ehci_hcd *ehci)
+{
+	printk(">>> Ehci_Host_Out...\n");
+
+	qtd_out->hw_token = QTD_STS_ACTIVE;
+	qtd_out->hw_token |= (3 << 10);
+	qtd_out->hw_token |= QTD_IOC;
+
+	qtd_out->hw_token &= ~(3 << 8);
+	qtd_out->hw_token &= (~(0x7fff << 16));
+
+	qtd_out->hw_token |= QTD_TOGGLE;	/* force DATA1 */
+
+	USB_transfer(ehci, qtd_out, out_dma, 0);
+}
+
+static void Test_PORT_EHCI(struct ehci_hcd *ehci)
+{
+	printk("Test_PORT_EHCI\n");
+	msleep(SEND_SOF_TIME_BEFORE_SUSPEND);	/* wait 15 seconds */
+
+	do {
+		u32 Temp;
+
+		/* suspend */
+		Temp = ehci_readl(ehci, &ehci->regs->port_status[0]);
+		Temp |= PORT_SUSPEND;
+		ehci_writel(ehci, Temp, &ehci->regs->port_status[0]);
+		msleep(ELAPSE_TIME_AFTER_SUSPEND);	/* wait 15 seconds */
+
+		//4  resume
+		Temp = ehci_readl(ehci, &ehci->regs->port_status[0]);
+		Temp |= PORT_RESUME;
+		ehci_writel(ehci, Temp, &ehci->regs->port_status[0]);
+		msleep(WAIT_TIME_AFTER_RESUME); /* wait 25 ms, minimum is 20 ms */
+
+		Temp = ehci_readl(ehci, &ehci->regs->port_status[0]);
+		Temp &= ~PORT_SUSPEND;
+		Temp &= ~PORT_RESUME;
+		ehci_writel(ehci, Temp, &ehci->regs->port_status[0]);
+
+		msleep(SEND_SOF_TIME_BEFORE_SUSPEND);	/* wait 15 seconds */
+	} while (!kthread_should_stop());
+}
+
+void Test_FEATURE_EHCI(struct ehci_hcd *ehci)
+{
+	printk("Test_FEATURE_EHCI\n");
+
+	Ehci_Init_var(ehci);
+
+	do {
+		Ehci_Host_Setup(ehci);	//host is setup transcation
+		msleep(SEND_SOF_TIME_BEFORE_SEND_IN_PACKET);
+		Ehci_Host_In(ehci);	//host is in transcation
+		Ehci_Host_Out(ehci);	//host is out transcation
+	} while (!kthread_should_stop());
+
+	Ehci_unInit_var(ehci);
+}
+
+static int ehci_usb_logo_test(struct usb_hcd *hcd, int idProduct)
+{
+	struct ehci_hcd *ehci = hcd_to_ehci(hcd);
+	void __iomem *reg_addr;
+	u32 command = 0;
+	u32 port_status = 0;
+	int tmp = 0;
+
+	printk(">>> usb_logo_test ...\n");
+
+	while ((ehci_readl(ehci, &ehci->regs->status) & STS_ASS)) {
+		udelay(2);
+	}
+
+	switch (idProduct) {
+	case 0x0106:
+		Test_PORT_EHCI(ehci);
+		break;
+	case 0x0108:
+		Test_FEATURE_EHCI(ehci);
+	}
+
+	//3 Ref EHCI 4.14 Port Test Modes
+	//disable periodic and ansyncschedule
+	command = ehci_readl(ehci, &ehci->regs->command);
+	command &= ~(CMD_ASE | CMD_PSE);
+	ehci_writel(ehci, command, &ehci->regs->command);
+
+	//port suspend
+	if (idProduct != 0x0104) {
+		port_status = ehci_readl(ehci, &ehci->regs->port_status[0]);
+		port_status |= PORT_SUSPEND;
+		ehci_writel(ehci, port_status, &ehci->regs->port_status[0]);
+	}
+	//stop ehci
+	command = ehci_readl(ehci, &ehci->regs->command);
+	command &= ~(CMD_RUN);
+	ehci_writel(ehci, command, &ehci->regs->command);
+
+	//wait ehci halt
+	while (1) {
+		tmp = ehci_readl(ehci, &ehci->regs->status);
+		if (tmp & STS_HALT) {
+			break;
+		}
+		udelay(10);
+	}
+
+	//Now Test by set Port Test Control.
+	port_status = ehci_readl(ehci, &ehci->regs->port_status[0]);
+	port_status &= ~(0xf << 16);
+
+	switch (idProduct) {
+	case 0x0101:
+		printk("test se0\n");
+		port_status |= TEST_SE0_NAK_1;
+		printk("port_status = 0x%08x\n", port_status);
+		writel(port_status, &ehci->regs->port_status[0]);
+		break;
+	case 0x0102:
+		printk("test J\n");
+		port_status |= TEST_J_STATE;
+		printk("port_status = 0x%08x\n", port_status);
+		ehci_writel(ehci, port_status, &ehci->regs->port_status[0]);
+		break;
+	case 0x0103:
+		printk("test K\n");
+		port_status |= TEST_K_STATE;
+		printk("port_status = 0x%08x\n", port_status);
+		ehci_writel(ehci, port_status, &ehci->regs->port_status[0]);
+		break;
+	case 0x0104:
+		printk("test packet\n");
+		port_status |= TEST_Packet;
+		printk("port_status = 0x%08x\n", port_status);
+
+		reg_addr = (hcd->self.busnum - 1) ? uphy1_base_addr : uphy0_base_addr;
+		writel(0xa1, reg_addr + BIT_TEST_OFFSET);
+		//ehci_writel(ehci, port_status, &ehci->regs->port_status[0]);
+		break;
+	default:
+		printk("pid fail\n");
+		break;
+	}
+
+	while (!kthread_should_stop()) {
+		msleep(1500);
+		printk("Test end\n");
+	}
+
+	printk("<<< usb_logo_test ...\n");
+	return 0;
+}
+
+#endif // CONFIG_USB_LOGO_TEST
+
 /*-------------------------------------------------------------------------*/
 
 MODULE_DESCRIPTION(DRIVER_DESC);
@@ -1308,6 +1813,11 @@
 #define        PLATFORM_DRIVER         ehci_mv_driver
 #endif
 
+#ifdef CONFIG_USB_EHCI_HCD_PLATFORM
+#include "ehci-platform.c"
+#endif
+
+#if 0
 static int __init ehci_hcd_init(void)
 {
 	int retval = 0;
@@ -1384,7 +1894,7 @@
 	clear_bit(USB_EHCI_LOADED, &usb_hcds_loaded);
 	return retval;
 }
-module_init(ehci_hcd_init);
+/*module_init(ehci_hcd_init);*/
 
 static void __exit ehci_hcd_cleanup(void)
 {
@@ -1405,4 +1915,5 @@
 #endif
 	clear_bit(USB_EHCI_LOADED, &usb_hcds_loaded);
 }
-module_exit(ehci_hcd_cleanup);
+/*module_exit(ehci_hcd_cleanup);*/
+#endif
--- a/drivers/usb/host/ehci-hub.c	2018-11-23 10:16:15.978817914 +0300
+++ a/drivers/usb/host/ehci-hub.c	2018-11-23 10:31:03.803050694 +0300
@@ -1320,6 +1320,16 @@
 static void ehci_relinquish_port(struct usb_hcd *hcd, int portnum)
 {
 	struct ehci_hcd		*ehci = hcd_to_ehci(hcd);
+#ifdef CONFIG_RETRY_TIMES
+	u32 port_val;
+
+	port_val = ehci_readl(ehci, &ehci->regs->port_status[0]);
+	if (PORT_CONNECT & port_val) {
+		ehci_writel(ehci, 0x0, &ehci->regs->configured_flag);
+		//ehci_halt(ehci);
+		//ehci_reset(ehci);
+	}
+#endif
 
 	if (ehci_is_TDI(ehci))
 		return;
--- a/drivers/usb/host/ehci-platform.c	2018-11-23 10:16:15.978817914 +0300
+++ a/drivers/usb/host/ehci-platform.c	2018-11-23 10:31:03.800050872 +0300
@@ -3,7 +3,6 @@
  *
  * Copyright 2007 Steven Brown <sbrown@cortland.com>
  * Copyright 2010-2012 Hauke Mehrtens <hauke@hauke-m.de>
- * Copyright 2014 Hans de Goede <hdegoede@redhat.com>
  *
  * Derived from the ohci-ssb driver
  * Copyright 2007 Michael Buesch <m@bues.ch>
@@ -19,437 +18,709 @@
  *
  * Licensed under the GNU/GPL. See COPYING for details.
  */
-#include <linux/acpi.h>
-#include <linux/clk.h>
-#include <linux/dma-mapping.h>
-#include <linux/err.h>
-#include <linux/kernel.h>
-#include <linux/hrtimer.h>
-#include <linux/io.h>
-#include <linux/module.h>
-#include <linux/of.h>
-#include <linux/phy/phy.h>
 #include <linux/platform_device.h>
-#include <linux/reset.h>
-#include <linux/usb.h>
-#include <linux/usb/hcd.h>
 #include <linux/usb/ehci_pdriver.h>
-#include <linux/usb/of.h>
-
-#include "ehci.h"
-
-#define DRIVER_DESC "EHCI generic platform driver"
-#define EHCI_MAX_CLKS 4
-#define EHCI_MAX_RSTS 4
-#define hcd_to_ehci_priv(h) ((struct ehci_platform_priv *)hcd_to_ehci(h)->priv)
-
-struct ehci_platform_priv {
-	struct clk *clks[EHCI_MAX_CLKS];
-	struct reset_control *rsts[EHCI_MAX_RSTS];
-	struct phy **phys;
-	int num_phys;
-	bool reset_on_resume;
-};
-
-static const char hcd_name[] = "ehci-platform";
+#include <linux/kthread.h>
+#include <linux/usb/otg.h>
+#include <mach/io_map.h>
+#include <linux/usb/sp_usb.h>
 
 static int ehci_platform_reset(struct usb_hcd *hcd)
 {
 	struct platform_device *pdev = to_platform_device(hcd->self.controller);
-	struct usb_ehci_pdata *pdata = dev_get_platdata(&pdev->dev);
+	struct usb_ehci_pdata *pdata = pdev->dev.platform_data;
 	struct ehci_hcd *ehci = hcd_to_ehci(hcd);
+	int port_num = pdev->id - 1;
 	int retval;
 
+	hcd->has_tt = pdata->has_tt;
 	ehci->has_synopsys_hc_bug = pdata->has_synopsys_hc_bug;
-
-	if (pdata->pre_setup) {
-		retval = pdata->pre_setup(hcd);
-		if (retval < 0)
-			return retval;
-	}
+	ehci->big_endian_desc = pdata->big_endian_desc;
+	ehci->big_endian_mmio = pdata->big_endian_mmio;
 
 	ehci->caps = hcd->regs + pdata->caps_offset;
 	retval = ehci_setup(hcd);
 	if (retval)
 		return retval;
 
-	if (pdata->no_io_watchdog)
-		ehci->need_io_watchdog = 0;
+	if (pdata->port_power_on)
+		ehci_port_power(ehci, port_num, 1);
+	if (pdata->port_power_off)
+		ehci_port_power(ehci, port_num, 0);
+
 	return 0;
 }
 
-static int ehci_platform_power_on(struct platform_device *dev)
+static const struct hc_driver ehci_platform_hc_driver = {
+	.description = hcd_name,
+	.product_desc = "Generic Platform EHCI Controller",
+#ifdef	CONFIG_USB_HOST_RESET_SP
+	.hcd_priv_size = sizeof(struct ehci_hcd_sp),
+#else
+	.hcd_priv_size = sizeof(struct ehci_hcd),
+#endif
+
+	.irq = ehci_irq,
+	.flags = HCD_MEMORY | HCD_USB2,
+
+	.reset = ehci_platform_reset,
+	.start = ehci_run,
+	.stop = ehci_stop,
+	.shutdown = ehci_shutdown,
+
+#ifdef CONFIG_USB_LOGO_TEST
+	/*
+	 * usb logo test support
+	 */
+	.usb_logo_test = ehci_usb_logo_test,
+#endif
+
+	.urb_enqueue = ehci_urb_enqueue,
+	.urb_dequeue = ehci_urb_dequeue,
+	.endpoint_disable = ehci_endpoint_disable,
+	.endpoint_reset = ehci_endpoint_reset,
+
+	.get_frame_number = ehci_get_frame,
+
+	.hub_status_data = ehci_hub_status_data,
+	.hub_control = ehci_hub_control,
+#if defined(CONFIG_PM)
+	.bus_suspend = ehci_bus_suspend,
+	.bus_resume = ehci_bus_resume,
+#endif
+	.relinquish_port = ehci_relinquish_port,
+	.port_handed_over = ehci_port_handed_over,
+
+	.clear_tt_buffer_complete = ehci_clear_tt_buffer_complete,
+	.get_port_status_from_register = ehci_get_port_status_from_register,
+};
+
+#ifdef	CONFIG_USB_HOST_RESET_SP
+#define 	RESET_UPHY(x,ret,addr)	{				\
+				ret	 = readl(addr);		\
+				ret |= (1<<(9+x))|(1<<(12+x));		\
+				writel(ret,addr);			\
+				ret &= ~((1<<(9+x))|(1<<(12+x)));	\
+				writel(ret,addr);			\
+			}
+#define		REG_UPHY_RESET_OFFSET	(18)
+#endif
+
+#ifdef	CONFIG_USB_HOST_RESET_SP
+extern void reset_usb_powerx(struct usb_hcd *hcd, int delayms);
+
+#ifdef CONFIG_USB_GADGET_SUNPLUS
+extern void usb_switch(int device);
+#ifdef FIX_MULTIPLE_RESET_PROBLEM
+extern void ctrl_rx_squelch(void);
+#endif
+extern void detech_start(void);
+#endif
+
+#ifdef CONFIG_USB_LOGO_TEST
+extern u32 usb_logo_test_start;
+#endif
+
+static int ehci_reset_thread(void *arg)
 {
-	struct usb_hcd *hcd = platform_get_drvdata(dev);
-	struct ehci_platform_priv *priv = hcd_to_ehci_priv(hcd);
-	int clk, ret, phy_num;
+	struct ehci_hcd *ehci = (struct ehci_hcd *)arg;
+	struct ehci_hcd_sp *sp_ehci = (struct ehci_hcd_sp *)arg;
+	struct usb_hcd *hcd = ehci_to_hcd(ehci);
+	struct platform_device *pdev = to_platform_device(hcd->self.controller);
+
+	int i;
+	u32 flag;
+	void __iomem *reg_addr;
+
+	do {
+
+NEXT_LOOP:
+
+		msleep(10);
+		wait_event_interruptible(hcd->reset_queue,
+					 ((sp_ehci->flag & (RESET_UPHY_SIGN |
+							    RESET_HC_SIGN)) !=
+					  0)
+					 || kthread_should_stop());
+
+		if (kthread_should_stop()) {
+			printk("%s is stoped!\n", __func__);
+			break;
+		}
+#ifdef CONFIG_USB_LOGO_TEST
+		if (usb_logo_test_start == 1) {
+			sp_ehci->flag = 0;
+			continue;
+		}
+#endif
+
+		/*besure nothing on hcd bus */
+		for (i = 1; i < 128 / (8 * sizeof(unsigned long)); i++) {
+
+			if (unlikely(sp_ehci->flag & RESET_HC_DEAD))
+				break;
+
+			if (hcd->self.devmap.devicemap[i]) {
+				sp_ehci->flag = 0;
+				goto NEXT_LOOP;
+			}
+		}
+
+		if ((hcd->self.devmap.devicemap[0] == 2)
+		    || unlikely(sp_ehci->flag & RESET_HC_DEAD)) {
+
+			flag = sp_ehci->flag;
+			clear_bit(HCD_FLAG_DEAD, &hcd->flags);
+
+			usb_remove_hcd(hcd);
+
+			if (flag & RESET_UPHY_SIGN) {
+				reg_addr = (pdev->id - 1) ? uphy1_base_addr : uphy0_base_addr;
+				hcd->uphy_disconnect_level[pdev->id - 1] = readl(reg_addr + DISC_LEVEL_OFFSET);
+				reset_uphy(pdev->id - 1);
+				reinit_uphy(pdev->id - 1);
+				writel(hcd->uphy_disconnect_level[pdev->id - 1], reg_addr + DISC_LEVEL_OFFSET);
+				/*tell ohci reset controllor */
+				sp_ehci->flag = RESET_SENDER;
+#ifdef CONFIG_USB_GADGET_SUNPLUS
+				printk(KERN_NOTICE
+				       "port_num:%d,device_mode_flag:%d\n",
+				       pdev->id - 1,
+				       platform_device_mode_flag[pdev->id - 1]);
+				if (platform_device_mode_flag[pdev->id - 1]) {
+					platform_device_mode_flag[pdev->id -
+								  1] = false;
+					msleep(1);
+					usb_switch(1);
+					msleep(1);
+#ifdef FIX_MULTIPLE_RESET_PROBLEM
+					/*control squelch signal */
+					ctrl_rx_squelch();
+					msleep(1);
+#endif
+					detech_start();
+				}
+#endif
+			}
+
+			msleep(100);
+
+			usb_add_hcd(hcd, hcd->irq, IRQF_DISABLED | IRQF_SHARED);
+
+			sp_ehci->flag &= ~RESET_HC_SIGN;
+		} else {
+			sp_ehci->flag = 0;
+		}
+	} while (!kthread_should_stop());
+	return 0;
+}
+#endif
 
-	for (clk = 0; clk < EHCI_MAX_CLKS && priv->clks[clk]; clk++) {
-		ret = clk_prepare_enable(priv->clks[clk]);
-		if (ret)
-			goto err_disable_clks;
-	}
-
-	for (phy_num = 0; phy_num < priv->num_phys; phy_num++) {
-		ret = phy_init(priv->phys[phy_num]);
-		if (ret)
-			goto err_exit_phy;
-		ret = phy_power_on(priv->phys[phy_num]);
-		if (ret) {
-			phy_exit(priv->phys[phy_num]);
-			goto err_exit_phy;
+#ifdef	CONFIG_USB_HOST_RESET_SP
+static int ehci_notifier_call(struct notifier_block *self,
+			      unsigned long action, void *dev)
+{
+	struct usb_device *udev = (struct usb_device *)dev;
+	struct usb_hcd *hcd_o;
+	struct platform_device *pdev_o;
+	u32 *ptr;
+
+	struct ehci_hcd_sp *sp_ehci = container_of((void *)self,
+						   struct ehci_hcd_sp,
+						   ehci_notifier);
+	struct ehci_hcd *ehci = (struct ehci_hcd *)sp_ehci;
+	struct usb_hcd *hcd_e = ehci_to_hcd(ehci);
+	struct platform_device *pdev_e =
+	    to_platform_device(hcd_e->self.controller);
+
+	if (action == USB_DEVICE_ADD) {
+		if (!udev->parent) {	// roothub add
+			hcd_o = bus_to_hcd(udev->bus);
+			pdev_o = to_platform_device(hcd_o->self.controller);
+			ptr = (u32 *) ((u8 *) hcd_o->hcd_priv +
+				       hcd_o->driver->hcd_priv_size -
+				       sizeof(u32)
+			    );
+
+			//EHCI&OHCI on one port
+			if ((pdev_e != pdev_o) && (pdev_e->id == pdev_o->id)) {
+				if (ptr && (*ptr & RESET_SENDER)) {
+					sp_ehci->flag =
+					    RESET_HC_SIGN & (~RESET_UPHY_SIGN);
+					*ptr &= ~RESET_SENDER;
+					wake_up_interruptible(&hcd_e->
+							      reset_queue);
+				}
+			}
 		}
 	}
 
 	return 0;
+}
+#endif
+
+#ifdef CONFIG_SWITCH_USB_ROLE
+
+#ifdef CONFIG_PM_WARP
+static u32 fb_restore = 0;
+#endif
+
+#define USB_UPHY_REG	(3)
+
+static ssize_t show_usb_role(struct device *dev,
+			     struct device_attribute *attr, char *buf)
+{
+	//struct platform_device *pdev = to_platform_device(dev);
+
+	return 0;
+}
+
+static ssize_t store_usb_role(struct device *dev,
+			      struct device_attribute *attr,
+			      const char *buf, size_t count)
+{
+#if 0
+	struct platform_device *pdev = to_platform_device(dev);
+	//struct usb_hcd *hcd = (struct usb_hcd *)platform_get_drvdata(pdev);
+	//struct ehci_hcd *ehci = hcd_to_ehci(hcd);
+
+	u32 switch_usb_role;
+	volatile u32 *grop1 = (u32 *) VA_IOB_ADDR(2 * 32 * 4);
+	u32 ret;
+
+	/* 0:host , 1:device */
+	if (kstrtouint(buf, 0, &switch_usb_role) == 0) {
+		//printk("usb rold -> %x\n", switch_usb_role);
+		ret = ioread32(grop1 + USB_UPHY_REG);
+
+		ret |= (1 << ((pdev->id - 1) * 8 + 4));
+		if (switch_usb_role & 0x1) {
+			ret &= ~(1 << ((pdev->id - 1) * 8 + 5));
+			ret |= (1 << ((pdev->id - 1) * 8 + 6));
+		} else
+			ret |= (3 << ((pdev->id - 1) * 8 + 5));
 
-err_exit_phy:
-	while (--phy_num >= 0) {
-		phy_power_off(priv->phys[phy_num]);
-		phy_exit(priv->phys[phy_num]);
+		//printk("usb ret -> %x\n", ret);
+		iowrite32(ret, grop1 + USB_UPHY_REG);
 	}
-err_disable_clks:
-	while (--clk >= 0)
-		clk_disable_unprepare(priv->clks[clk]);
+#endif
+	return count;
+}
+
+static DEVICE_ATTR(usb_role_switch,
+		   S_IWUSR | S_IRUSR, show_usb_role, store_usb_role);
 
-	return ret;
+/* switch usb speed ( fs/hs ) */
+static ssize_t show_usb_speed(struct device *dev,
+			      struct device_attribute *attr, char *buf)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	struct usb_hcd *hcd = (struct usb_hcd *)platform_get_drvdata(pdev);
+	struct ehci_hcd *ehci = hcd_to_ehci(hcd);
+
+	u32 result;
+
+	result = ehci_readl(ehci, &ehci->regs->configured_flag);
+
+	return sprintf(buf, "%d\n", result);
 }
 
-static void ehci_platform_power_off(struct platform_device *dev)
+#define MAX_PORT_NUM  					2
+#define POWER_RESET_TIME 				500
+#define ENABLE_FORCE_HOST_DISCONNECT    1
+#define DISABLE_FORCE_HOST_DISCONNECT   0
+static ssize_t store_usb_speed(struct device *dev,
+			       struct device_attribute *attr,
+			       const char *buf, size_t count)
 {
-	struct usb_hcd *hcd = platform_get_drvdata(dev);
-	struct ehci_platform_priv *priv = hcd_to_ehci_priv(hcd);
-	int clk, phy_num;
+	struct platform_device *pdev = to_platform_device(dev);
+	struct usb_hcd *hcd = (struct usb_hcd *)platform_get_drvdata(pdev);
+	struct ehci_hcd *ehci = hcd_to_ehci(hcd);
+	int port_num = pdev->id - 1;
 
-	for (phy_num = 0; phy_num < priv->num_phys; phy_num++) {
-		phy_power_off(priv->phys[phy_num]);
-		phy_exit(priv->phys[phy_num]);
+	u32 usb_host_owner;
+
+	/* 0:full speed 1:high speed */
+	if (kstrtouint(buf, 0, &usb_host_owner) == 0) {
+		if (port_num < MAX_PORT_NUM) {
+			DISABLE_VBUS_POWER(port_num);
+			uphy_force_disc(ENABLE_FORCE_HOST_DISCONNECT, port_num);
+			msleep(POWER_RESET_TIME);
+			ehci_writel(ehci,
+				    FLAG_CF & usb_host_owner,
+				    &ehci->regs->configured_flag);
+			uphy_force_disc(DISABLE_FORCE_HOST_DISCONNECT,
+					port_num);
+			ENABLE_VBUS_POWER(port_num);
+		} else if (MAX_PORT_NUM == port_num) {
+			printk(KERN_NOTICE
+			       "warning,port 2 is not supported to power reset\n");
+			ehci_writel(ehci,
+				    FLAG_CF & usb_host_owner,
+				    &ehci->regs->configured_flag);
+		} else {
+			printk(KERN_NOTICE "error port num:%d\n", port_num);
+		}
 	}
 
-	for (clk = EHCI_MAX_CLKS - 1; clk >= 0; clk--)
-		if (priv->clks[clk])
-			clk_disable_unprepare(priv->clks[clk]);
+	return count;
 }
 
-static struct hc_driver __read_mostly ehci_platform_hc_driver;
+static DEVICE_ATTR(usb_speed_switch,
+		   S_IWUSR | S_IRUSR, show_usb_speed, store_usb_speed);
 
-static const struct ehci_driver_overrides platform_overrides __initconst = {
-	.reset =		ehci_platform_reset,
-	.extra_priv_size =	sizeof(struct ehci_platform_priv),
-};
+static ssize_t show_usb_swing(struct device *dev,
+			      struct device_attribute *attr, char *buf)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+
+	return sprintf(buf, "%d\n", get_uphy_swing(pdev->id - 1));
+}
+
+static ssize_t store_usb_swing(struct device *dev,
+			       struct device_attribute *attr,
+			       const char *buf, size_t count)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	//struct usb_hcd *hcd = (struct usb_hcd *)platform_get_drvdata(pdev);
+	//struct ehci_hcd *ehci = hcd_to_ehci(hcd);
+
+	u32 swing_val;
+
+	if (kstrtouint(buf, 0, &swing_val) == 0) {
+		set_uphy_swing(swing_val, pdev->id - 1);
+	}
+
+	return count;
+}
+
+static DEVICE_ATTR(usb_uphy_swing,
+		   S_IWUSR | S_IRUSR, show_usb_swing, store_usb_swing);
+
+static ssize_t show_usb_disconnect_level(struct device *dev,
+					 struct device_attribute *attr,
+					 char *buf)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	u32 disc_level;
 
-static struct usb_ehci_pdata ehci_platform_defaults = {
-	.power_on =		ehci_platform_power_on,
-	.power_suspend =	ehci_platform_power_off,
-	.power_off =		ehci_platform_power_off,
+	disc_level = get_disconnect_level(pdev->id - 1);
+	printk(KERN_DEBUG
+	       "port:%d,get disconnect level:0x%x\n", pdev->id - 1, disc_level);
+
+	return sprintf(buf, "0x%x\n", disc_level);
+}
+
+static ssize_t store_usb_disconnect_level(struct device *dev,
+					  struct device_attribute *attr,
+					  const char *buf, size_t count)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	u32 disc_level;
+
+	if (kstrtouint(buf, 0, &disc_level) == 0) {
+		printk(KERN_DEBUG
+		       "port:%d,set disconnect level:0x%x\n",
+		       pdev->id - 1, disc_level);
+		set_disconnect_level(disc_level, pdev->id - 1);
+	}
+
+	return count;
+}
+
+static DEVICE_ATTR(usb_disconnect_level,
+		   S_IWUSR | S_IRUSR, show_usb_disconnect_level,
+		   store_usb_disconnect_level);
+
+static ssize_t store_usb_ctrl_reset(struct device *dev,
+				    struct device_attribute *attr,
+				    const char *buf, size_t count)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	struct usb_hcd *hcd = (struct usb_hcd *)platform_get_drvdata(pdev);
+	/*struct ehci_hcd *ehci = hcd_to_ehci(hcd); */
+	u32 val = 1;
+
+	if (kstrtouint(buf, 0, &val)) {
+		return 1;
+	}
+
+	if (NULL == hcd) {
+		printk("store_usb_ctrl_reset: usb controller invalid\n");
+		return count;
+	}
+	printk("Will reset usb controller val=%d\n", val);
+#ifdef CONFIG_USB_HOST_RESET_SP
+	if (val == 1) {
+		printk("%s wake usb ctrl\n", __FUNCTION__);
+		*(hcd->ptr_flag) |= (RESET_HC_DEAD | RESET_UPHY_SIGN);
+		wake_up_interruptible(&hcd->reset_queue);
+	} else if (val > 500) {
+		printk("power reset %d ms \n", val);
+		reset_usb_powerx(hcd, val);
+	}
+#endif
+
+	return count;
+}
+
+static DEVICE_ATTR(usb_ctrl_reset, S_IWUSR, NULL, store_usb_ctrl_reset);
+
+#endif
+
+static struct usb_ehci_pdata usb_ehci_pdata = {
 };
 
-static int ehci_platform_probe(struct platform_device *dev)
+int ehci_platform_probe(struct platform_device *dev)
 {
 	struct usb_hcd *hcd;
 	struct resource *res_mem;
-	struct usb_ehci_pdata *pdata = dev_get_platdata(&dev->dev);
-	struct ehci_platform_priv *priv;
-	struct ehci_hcd *ehci;
-	int err, irq, phy_num, clk = 0, rst;
+	int irq;
+	int err = -ENOMEM;
+#ifdef CONFIG_USB_SUNPLUS_OTG
+	struct usb_phy *otg_phy;
+#endif
 
-	if (usb_disabled())
-		return -ENODEV;
+#ifdef CONFIG_USB_HOST_RESET_SP
+	struct ehci_hcd_sp *ehci_sp;
+#endif
 
-	/*
-	 * Use reasonable defaults so platforms don't have to provide these
-	 * with DT probing on ARM.
-	 */
-	if (!pdata)
-		pdata = &ehci_platform_defaults;
+	//BUG_ON(!dev->dev.platform_data);
 
-	err = dma_coerce_mask_and_coherent(&dev->dev,
-		pdata->dma_mask_64 ? DMA_BIT_MASK(64) : DMA_BIT_MASK(32));
-	if (err) {
-		dev_err(&dev->dev, "Error: DMA mask configuration failed\n");
-		return err;
-	}
+	if (usb_disabled())
+		return -ENODEV;
 
+	dev->dev.platform_data = &usb_ehci_pdata;
 	irq = platform_get_irq(dev, 0);
 	if (irq < 0) {
-		dev_err(&dev->dev, "no irq provided");
+		pr_err("no irq provieded,ret:%d\n",irq);
 		return irq;
 	}
+	printk("ehci_id:%d,irq:%d\n",dev->id,irq);
+
+	res_mem = platform_get_resource(dev, IORESOURCE_MEM, 0);
+	if (!res_mem) {
+		pr_err("no memory recourse provieded");
+		return -ENXIO;
+	}
 
 	hcd = usb_create_hcd(&ehci_platform_hc_driver, &dev->dev,
 			     dev_name(&dev->dev));
 	if (!hcd)
 		return -ENOMEM;
 
-	platform_set_drvdata(dev, hcd);
-	dev->dev.platform_data = pdata;
-	priv = hcd_to_ehci_priv(hcd);
-	ehci = hcd_to_ehci(hcd);
-
-	if (pdata == &ehci_platform_defaults && dev->dev.of_node) {
-		if (of_property_read_bool(dev->dev.of_node, "big-endian-regs"))
-			ehci->big_endian_mmio = 1;
-
-		if (of_property_read_bool(dev->dev.of_node, "big-endian-desc"))
-			ehci->big_endian_desc = 1;
-
-		if (of_property_read_bool(dev->dev.of_node, "big-endian"))
-			ehci->big_endian_mmio = ehci->big_endian_desc = 1;
-
-		if (of_property_read_bool(dev->dev.of_node,
-					  "needs-reset-on-resume"))
-			priv->reset_on_resume = true;
-
-		if (of_property_read_bool(dev->dev.of_node,
-					  "has-transaction-translator"))
-			hcd->has_tt = 1;
-
-		priv->num_phys = of_count_phandle_with_args(dev->dev.of_node,
-				"phys", "#phy-cells");
-
-		if (priv->num_phys > 0) {
-			priv->phys = devm_kcalloc(&dev->dev, priv->num_phys,
-					    sizeof(struct phy *), GFP_KERNEL);
-			if (!priv->phys)
-				return -ENOMEM;
-		} else
-			priv->num_phys = 0;
-
-		for (phy_num = 0; phy_num < priv->num_phys; phy_num++) {
-			priv->phys[phy_num] = devm_of_phy_get_by_index(
-					&dev->dev, dev->dev.of_node, phy_num);
-			if (IS_ERR(priv->phys[phy_num])) {
-				err = PTR_ERR(priv->phys[phy_num]);
-					goto err_put_hcd;
-			} else if (!hcd->phy) {
-				/* Avoiding phy_get() in usb_add_hcd() */
-				hcd->phy = priv->phys[phy_num];
-			}
-		}
+	hcd->rsrc_start = res_mem->start;
+	hcd->rsrc_len = resource_size(res_mem);
 
-		for (clk = 0; clk < EHCI_MAX_CLKS; clk++) {
-			priv->clks[clk] = of_clk_get(dev->dev.of_node, clk);
-			if (IS_ERR(priv->clks[clk])) {
-				err = PTR_ERR(priv->clks[clk]);
-				if (err == -EPROBE_DEFER)
-					goto err_put_clks;
-				priv->clks[clk] = NULL;
-				break;
-			}
-		}
+#ifdef CONFIG_USB_USE_PLATFORM_RESOURCE
+	if (!request_mem_region(hcd->rsrc_start, hcd->rsrc_len, hcd_name)) {
+		pr_err("controller already in use");
+		err = -EBUSY;
+		goto err_put_hcd;
 	}
 
-	for (rst = 0; rst < EHCI_MAX_RSTS; rst++) {
-		priv->rsts[rst] = devm_reset_control_get_shared_by_index(
-					&dev->dev, rst);
-		if (IS_ERR(priv->rsts[rst])) {
-			err = PTR_ERR(priv->rsts[rst]);
-			if (err == -EPROBE_DEFER)
-				goto err_reset;
-			priv->rsts[rst] = NULL;
-			break;
-		}
+	hcd->regs = ioremap_nocache(hcd->rsrc_start, hcd->rsrc_len);
+	if (!hcd->regs)
+		goto err_release_region;
+#else
+	hcd->regs = (void *)res_mem->start;
+#endif
+	tasklet_init(&hcd->host_irq_tasklet, ehci_irq_tasklet, (unsigned long)hcd);
+	err = usb_add_hcd(hcd, irq, IRQF_SHARED);
+	printk("hcd_irq:%d,%d\n",hcd->irq,irq);
+	if (err)
+		goto err_iounmap;
+
+	platform_set_drvdata(dev, hcd);
+/****************************************************/
+#ifdef CONFIG_USB_HOST_RESET_SP
+	ehci_sp = (struct ehci_hcd_sp *)hcd_to_ehci(hcd);
+#endif
 
-		err = reset_control_deassert(priv->rsts[rst]);
-		if (err)
-			goto err_reset;
-	}
-
-	if (pdata->big_endian_desc)
-		ehci->big_endian_desc = 1;
-	if (pdata->big_endian_mmio)
-		ehci->big_endian_mmio = 1;
-	if (pdata->has_tt)
-		hcd->has_tt = 1;
-	if (pdata->reset_on_resume)
-		priv->reset_on_resume = true;
-
-#ifndef CONFIG_USB_EHCI_BIG_ENDIAN_MMIO
-	if (ehci->big_endian_mmio) {
-		dev_err(&dev->dev,
-			"Error: CONFIG_USB_EHCI_BIG_ENDIAN_MMIO not set\n");
-		err = -EINVAL;
-		goto err_reset;
-	}
-#endif
-#ifndef CONFIG_USB_EHCI_BIG_ENDIAN_DESC
-	if (ehci->big_endian_desc) {
-		dev_err(&dev->dev,
-			"Error: CONFIG_USB_EHCI_BIG_ENDIAN_DESC not set\n");
-		err = -EINVAL;
-		goto err_reset;
+#ifdef CONFIG_USB_SUNPLUS_OTG
+	if (dev->id < 3) {
+		otg_phy = usb_get_transceiver_sunplus(dev->id - 1);
+		err = otg_set_host(otg_phy->otg, &hcd->self);
+		if (err < 0) {
+			dev_err(&pdev->dev,
+				"unable to register with transceiver\n");
+			goto err_iounmap;
+		}
 	}
 #endif
 
-	if (pdata->power_on) {
-		err = pdata->power_on(dev);
-		if (err < 0)
-			goto err_reset;
+#ifdef CONFIG_SWITCH_USB_ROLE
+	if (dev->id < 3) {
+		device_create_file(&dev->dev, &dev_attr_usb_role_switch);
+		device_create_file(&dev->dev, &dev_attr_usb_ctrl_reset);
 	}
 
-	res_mem = platform_get_resource(dev, IORESOURCE_MEM, 0);
-	hcd->regs = devm_ioremap_resource(&dev->dev, res_mem);
-	if (IS_ERR(hcd->regs)) {
-		err = PTR_ERR(hcd->regs);
-		goto err_power;
+	device_create_file(&dev->dev, &dev_attr_usb_speed_switch);
+	device_create_file(&dev->dev, &dev_attr_usb_uphy_swing);
+	device_create_file(&dev->dev, &dev_attr_usb_disconnect_level);
+#endif
+
+#ifdef CONFIG_USB_HOST_RESET_SP
+	ehci_sp->flag = 0;
+
+	printk("flag ***%p %p %d %d %p\n", hcd, hcd->hcd_priv,
+	       sizeof(struct ehci_hcd_sp), hcd->driver->hcd_priv_size,
+	       &ehci_sp->flag);
+
+	/* ohci reset uphy notifier */
+	ehci_sp->ehci_notifier.notifier_call = ehci_notifier_call;
+	usb_register_notify(&ehci_sp->ehci_notifier);
+
+	init_waitqueue_head(&hcd->reset_queue);
+	hcd->ptr_flag = &ehci_sp->flag;
+
+	ehci_sp->reset_thread = kthread_create(ehci_reset_thread,
+					       hcd_to_ehci(hcd),
+					       "ehci_reset_wait_event");
+
+	if (IS_ERR(ehci_sp->reset_thread)) {
+		pr_err("Create EHCI(%d) reset thread fail!\n", dev->id);
+		return err;
 	}
-	hcd->rsrc_start = res_mem->start;
-	hcd->rsrc_len = resource_size(res_mem);
 
-	err = usb_add_hcd(hcd, irq, IRQF_SHARED);
-	if (err)
-		goto err_power;
+	/* Tell the thread to start working */
+	wake_up_process(ehci_sp->reset_thread);
 
-	device_wakeup_enable(hcd->self.controller);
-	device_enable_async_suspend(hcd->self.controller);
-	platform_set_drvdata(dev, hcd);
+#endif
 
 	return err;
 
-err_power:
-	if (pdata->power_off)
-		pdata->power_off(dev);
-err_reset:
-	while (--rst >= 0)
-		reset_control_assert(priv->rsts[rst]);
-err_put_clks:
-	while (--clk >= 0)
-		clk_put(priv->clks[clk]);
+err_iounmap:
+#ifdef CONFIG_USB_USE_PLATFORM_RESOURCE
+	iounmap(hcd->regs);
+err_release_region:
+	release_mem_region(hcd->rsrc_start, hcd->rsrc_len);
 err_put_hcd:
-	if (pdata == &ehci_platform_defaults)
-		dev->dev.platform_data = NULL;
-
+#endif
 	usb_put_hcd(hcd);
-
 	return err;
 }
 
-static int ehci_platform_remove(struct platform_device *dev)
+int ehci_platform_remove(struct platform_device *dev)
 {
 	struct usb_hcd *hcd = platform_get_drvdata(dev);
-	struct usb_ehci_pdata *pdata = dev_get_platdata(&dev->dev);
-	struct ehci_platform_priv *priv = hcd_to_ehci_priv(hcd);
-	int clk, rst;
 
-	usb_remove_hcd(hcd);
+#ifdef CONFIG_USB_HOST_RESET_SP
+	struct ehci_hcd_sp *ehci_sp = (struct ehci_hcd_sp *)hcd_to_ehci(hcd);
+#endif
+
+#ifdef CONFIG_SWITCH_USB_ROLE
+	if (dev->id < 3) {
+		device_remove_file(&dev->dev, &dev_attr_usb_role_switch);
+		device_remove_file(&dev->dev, &dev_attr_usb_ctrl_reset);
+	}
 
-	if (pdata->power_off)
-		pdata->power_off(dev);
+	device_remove_file(&dev->dev, &dev_attr_usb_speed_switch);
+	device_remove_file(&dev->dev, &dev_attr_usb_uphy_swing);
+	device_remove_file(&dev->dev, &dev_attr_usb_disconnect_level);
+#endif
 
-	for (rst = 0; rst < EHCI_MAX_RSTS && priv->rsts[rst]; rst++)
-		reset_control_assert(priv->rsts[rst]);
+#ifdef	CONFIG_USB_HOST_RESET_SP
+	if (dev->id < 3) {
+		//kthread_stop(ehci_sp->reset_thread);
+		usb_unregister_notify(&ehci_sp->ehci_notifier);
+	}
+#endif
 
-	for (clk = 0; clk < EHCI_MAX_CLKS && priv->clks[clk]; clk++)
-		clk_put(priv->clks[clk]);
+	usb_remove_hcd(hcd);
 
-	usb_put_hcd(hcd);
+#ifdef CONFIG_USB_USE_PLATFORM_RESOURCE
+	iounmap(hcd->regs);
+	release_mem_region(hcd->rsrc_start, hcd->rsrc_len);
+#endif
 
-	if (pdata == &ehci_platform_defaults)
-		dev->dev.platform_data = NULL;
+	usb_put_hcd(hcd);
+	platform_set_drvdata(dev, NULL);
 
 	return 0;
 }
 
-#ifdef CONFIG_PM_SLEEP
+#ifdef CONFIG_PM
+
 static int ehci_platform_suspend(struct device *dev)
 {
 	struct usb_hcd *hcd = dev_get_drvdata(dev);
-	struct usb_ehci_pdata *pdata = dev_get_platdata(dev);
-	struct platform_device *pdev = to_platform_device(dev);
-	bool do_wakeup = device_may_wakeup(dev);
-	int ret;
-
-	ret = ehci_suspend(hcd, do_wakeup);
-	if (ret)
-		return ret;
+	bool wakeup = device_may_wakeup(dev);
 
-	if (pdata->power_suspend)
-		pdata->power_suspend(pdev);
-
-	return ret;
+	ehci_prepare_ports_for_controller_suspend(hcd_to_ehci(hcd), wakeup);
+	return 0;
 }
 
 static int ehci_platform_resume(struct device *dev)
 {
 	struct usb_hcd *hcd = dev_get_drvdata(dev);
-	struct usb_ehci_pdata *pdata = dev_get_platdata(dev);
-	struct platform_device *pdev = to_platform_device(dev);
-	struct ehci_platform_priv *priv = hcd_to_ehci_priv(hcd);
-	struct device *companion_dev;
 
-	if (pdata->power_on) {
-		int err = pdata->power_on(pdev);
-		if (err < 0)
-			return err;
-	}
-
-	companion_dev = usb_of_get_companion_dev(hcd->self.controller);
-	if (companion_dev) {
-		device_pm_wait_for_dev(hcd->self.controller, companion_dev);
-		put_device(companion_dev);
-	}
-
-	ehci_resume(hcd, priv->reset_on_resume);
+	ehci_prepare_ports_for_controller_resume(hcd_to_ehci(hcd));
 	return 0;
 }
-#endif /* CONFIG_PM_SLEEP */
 
-static const struct of_device_id vt8500_ehci_ids[] = {
-	{ .compatible = "via,vt8500-ehci", },
-	{ .compatible = "wm,prizm-ehci", },
-	{ .compatible = "generic-ehci", },
-	{ .compatible = "cavium,octeon-6335-ehci", },
-	{}
-};
-MODULE_DEVICE_TABLE(of, vt8500_ehci_ids);
+#ifdef CONFIG_PM_WARP
 
-static const struct acpi_device_id ehci_acpi_match[] = {
-	{ "PNP0D20", 0 }, /* EHCI controller without debug */
-	{ }
-};
-MODULE_DEVICE_TABLE(acpi, ehci_acpi_match);
+int sp_ehci_fb_resume(struct platform_device *dev)
+{
+	struct usb_hcd *hcd = platform_get_drvdata(dev);
+	extern int warp_fastboot;
 
-static const struct platform_device_id ehci_platform_table[] = {
-	{ "ehci-platform", 0 },
-	{ }
-};
-MODULE_DEVICE_TABLE(platform, ehci_platform_table);
+#ifdef CONFIG_USB_HOST_RESET_SP
+	struct ehci_hcd_sp *ehci_sp = (struct ehci_hcd_sp *)hcd_to_ehci(hcd);
+#endif
 
-static SIMPLE_DEV_PM_OPS(ehci_platform_pm_ops, ehci_platform_suspend,
-	ehci_platform_resume);
+	if (warp_fastboot) {
 
-static struct platform_driver ehci_platform_driver = {
-	.id_table	= ehci_platform_table,
-	.probe		= ehci_platform_probe,
-	.remove		= ehci_platform_remove,
-	.shutdown	= usb_hcd_platform_shutdown,
-	.driver		= {
-		.name	= "ehci-platform",
-		.pm	= &ehci_platform_pm_ops,
-		.of_match_table = vt8500_ehci_ids,
-		.acpi_match_table = ACPI_PTR(ehci_acpi_match),
-	}
-};
+		usb_add_hcd(hcd, hcd->irq, IRQF_DISABLED | IRQF_SHARED);
 
-static int __init ehci_platform_init(void)
-{
-	if (usb_disabled())
-		return -ENODEV;
+#ifdef CONFIG_USB_HOST_RESET_SP
+
+		ehci_sp->reset_thread = kthread_create(ehci_reset_thread,
+						       hcd_to_ehci(hcd),
+						       "ehci_reset_wait_event");
 
-	pr_info("%s: " DRIVER_DESC "\n", hcd_name);
+		ehci_sp->ehci_notifier.notifier_call = ehci_notifier_call;
+		usb_register_notify(&ehci_sp->ehci_notifier);
+
+		wake_up_process(ehci_sp->reset_thread);
+#endif
 
-	ehci_init_driver(&ehci_platform_hc_driver, &platform_overrides);
-	return platform_driver_register(&ehci_platform_driver);
+	}
+
+	else {
+		ehci_platform_resume(&dev->dev);
+	}
+
+	return 0;
 }
-module_init(ehci_platform_init);
 
-static void __exit ehci_platform_cleanup(void)
+int sp_ehci_fb_suspend(struct platform_device *dev, pm_message_t state)
 {
-	platform_driver_unregister(&ehci_platform_driver);
+	struct usb_hcd *hcd = platform_get_drvdata(dev);
+	extern int warp_fastboot;
+
+#ifdef CONFIG_USB_HOST_RESET_SP
+	struct ehci_hcd_sp *ehci_sp = (struct ehci_hcd_sp *)hcd_to_ehci(hcd);
+#endif
+
+	if (warp_fastboot) {
+#ifdef CONFIG_USB_HOST_RESET_SP
+		kthread_stop(ehci_sp->reset_thread);
+		usb_unregister_notify(&ehci_sp->ehci_notifier);
+#endif
+		usb_remove_hcd(hcd);
+	}
+
+	else {
+		ehci_platform_suspend(&dev->dev);
+	}
+
+	return 0;
 }
-module_exit(ehci_platform_cleanup);
+#endif
 
-MODULE_DESCRIPTION(DRIVER_DESC);
-MODULE_AUTHOR("Hauke Mehrtens");
-MODULE_AUTHOR("Alan Stern");
-MODULE_LICENSE("GPL");
+#else /* !CONFIG_PM */
+#define ehci_platform_suspend	NULL
+#define ehci_platform_resume	NULL
+#endif /* CONFIG_PM */
--- a/drivers/usb/host/ehci-platform.h	1970-01-01 03:00:00.000000000 +0300
+++ a/drivers/usb/host/ehci-platform.h	2018-11-23 10:31:03.801050813 +0300
@@ -0,0 +1,19 @@
+#ifndef __EHCI_PLATFORM_H
+#define __EHCI_PLATFORM_H
+
+int ehci_platform_probe(struct platform_device *dev);
+
+int ehci_platform_remove(struct platform_device *dev);
+
+
+#ifdef CONFIG_PM_WARP
+int sp_ehci_fb_resume(struct platform_device *dev);
+
+int sp_ehci_fb_suspend(struct platform_device *dev, pm_message_t state);
+#endif
+
+#endif
+
+
+
+
--- a/drivers/usb/host/Kconfig	2018-11-23 10:16:15.977817973 +0300
+++ a/drivers/usb/host/Kconfig	2018-11-23 10:31:03.806050516 +0300
@@ -3,6 +3,25 @@
 #
 comment "USB Host Controller Drivers"
 
+config USB_LOGO_TEST
+	bool "GEMINI USB Logo Test support"
+	depends on USB
+	select USB_BAD_DEVICE_INFO
+
+# workaround hw bug that randomly happen abnormal when host controller send packet
+config USB_HOST_RESET_SP
+	bool "Enable Reset SUNPLUS usb host controllor with wait_event"
+	depends on USB
+
+config USB_OHCI_MSI_WORKAROUND
+	bool "Enable Workaround USB Ohci Msi Problem"
+	depends on USB
+
+config USB_USE_PLATFORM_RESOURCE
+	bool "GEMINI Use USB Platfrom Resource"
+	depends on USB
+	default n
+
 config USB_C67X00_HCD
 	tristate "Cypress C67x00 HCD support"
 	depends on HAS_IOMEM
@@ -152,6 +171,20 @@
 		Enables support for the onchip USB controller on the PMC_MSP7100 Family SoC's.
 		If unsure, say N.
 
+config USB_EHCI_BIG_ENDIAN_MMIO
+	bool
+	depends on USB_EHCI_HCD && (PPC_CELLEB || PPC_PS3 || 440EPX || \
+				    ARCH_IXP4XX || XPS_USB_HCD_XILINX || \
+				    PPC_MPC512x || CPU_CAVIUM_OCTEON || \
+				    PMC_MSP || SPARC_LEON)
+	default y
+
+config USB_EHCI_BIG_ENDIAN_DESC
+	bool
+	depends on USB_EHCI_HCD && (440EPX || ARCH_IXP4XX || XPS_USB_HCD_XILINX || \
+				    PPC_MPC512x || PMC_MSP || SPARC_LEON)
+	default y
+
 config XPS_USB_HCD_XILINX
 	bool "Use Xilinx usb host EHCI controller core"
 	depends on (PPC32 || MICROBLAZE)
--- a/drivers/usb/host/Makefile	2018-11-23 10:16:15.977817973 +0300
+++ a/drivers/usb/host/Makefile	2018-11-23 10:31:03.807050456 +0300
@@ -3,6 +3,7 @@
 #
 
 # tell define_trace.h where to find the xhci trace header
+ccflags-$(CONFIG_USB_DEBUG) := -DDEBUG
 CFLAGS_xhci-trace.o := -I$(src)
 
 fhci-y := fhci-hcd.o fhci-hub.o fhci-q.o
@@ -31,7 +32,7 @@
 
 obj-$(CONFIG_USB_EHCI_HCD)	+= ehci-hcd.o
 obj-$(CONFIG_USB_EHCI_PCI)	+= ehci-pci.o
-obj-$(CONFIG_USB_EHCI_HCD_PLATFORM)	+= ehci-platform.o
+#obj-$(CONFIG_USB_EHCI_HCD_PLATFORM)	+= ehci-platform.o
 obj-$(CONFIG_USB_EHCI_MXC)	+= ehci-mxc.o
 obj-$(CONFIG_USB_EHCI_HCD_OMAP)	+= ehci-omap.o
 obj-$(CONFIG_USB_EHCI_HCD_ORION)	+= ehci-orion.o
@@ -49,7 +50,7 @@
 
 obj-$(CONFIG_USB_OHCI_HCD)	+= ohci-hcd.o
 obj-$(CONFIG_USB_OHCI_HCD_PCI)	+= ohci-pci.o
-obj-$(CONFIG_USB_OHCI_HCD_PLATFORM)	+= ohci-platform.o
+#obj-$(CONFIG_USB_OHCI_HCD_PLATFORM)	+= ohci-platform.o
 obj-$(CONFIG_USB_OHCI_EXYNOS)	+= ohci-exynos.o
 obj-$(CONFIG_USB_OHCI_HCD_OMAP1)	+= ohci-omap.o
 obj-$(CONFIG_USB_OHCI_HCD_OMAP3)	+= ohci-omap3.o
@@ -81,3 +82,7 @@
 obj-$(CONFIG_USB_HCD_SSB)	+= ssb-hcd.o
 obj-$(CONFIG_USB_FOTG210_HCD)	+= fotg210-hcd.o
 obj-$(CONFIG_USB_MAX3421_HCD)	+= max3421-hcd.o
+obj-$(CONFIG_USB_EHCI_HCD)	+= ehci0-sunplus.o
+obj-$(CONFIG_USB_EHCI_HCD)	+= ehci1-sunplus.o
+obj-$(CONFIG_USB_OHCI_HCD)	+= ohci0-sunplus.o
+obj-$(CONFIG_USB_OHCI_HCD)	+= ohci1-sunplus.o
--- a/drivers/usb/host/ohci0-sunplus.c	1970-01-01 03:00:00.000000000 +0300
+++ a/drivers/usb/host/ohci0-sunplus.c	2018-11-12 06:42:55.000000000 +0300
@@ -0,0 +1,56 @@
+#include <linux/usb/sp_usb.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include "ohci-platform.h"
+
+extern void usb_hcd_platform_shutdown(struct platform_device *dev);
+
+static int ohci0_sunplus_platform_probe(struct platform_device *dev){
+
+	dev->id = 1;
+
+	return ohci_platform_probe(dev);
+}
+
+
+static const struct of_device_id ohci0_sunplus_dt_ids[] = {
+	{ .compatible = "sunplus,sunplus-q628-usb-ohci0" },
+	{ }
+};
+
+MODULE_DEVICE_TABLE(of, ohci0_sunplus_dt_ids);
+
+static struct platform_driver ohci0_hcd_sunplus_driver = {
+	.probe			= ohci0_sunplus_platform_probe,
+	.remove			= ohci_platform_remove,
+	.shutdown		= usb_hcd_platform_shutdown,
+	.driver = {
+		.name		= "ohci0-sunplus",
+		.of_match_table = ohci0_sunplus_dt_ids,
+	}
+};
+
+/*-------------------------------------------------------------------------*/
+
+static int __init ohci0_sunplus_init(void)
+{
+	if (sp_port_enabled & PORT0_ENABLED){
+		printk(KERN_NOTICE "register ohci0_hcd_sunplus_driver\n");
+		return platform_driver_register(&ohci0_hcd_sunplus_driver);
+	} else {
+		printk(KERN_NOTICE "warn,port0 not enable,not register ohci0 sunplus hcd driver\n");
+		return -1;
+	}
+}
+module_init(ohci0_sunplus_init);
+
+static void __exit ohci0_sunplus_cleanup(void)
+{
+	platform_driver_unregister(&ohci0_hcd_sunplus_driver);
+}
+module_exit(ohci0_sunplus_cleanup);
+
+MODULE_ALIAS("platform:ohci0-sunplus");
+MODULE_DESCRIPTION(DRIVER_DESC);
+MODULE_LICENSE("GPL");
+
--- a/drivers/usb/host/ohci1-sunplus.c	1970-01-01 03:00:00.000000000 +0300
+++ a/drivers/usb/host/ohci1-sunplus.c	2018-11-12 06:42:55.000000000 +0300
@@ -0,0 +1,56 @@
+#include <linux/usb/sp_usb.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include "ohci-platform.h"
+
+extern void usb_hcd_platform_shutdown(struct platform_device *dev);
+
+static int ohci1_sunplus_platform_probe(struct platform_device *dev){
+
+	dev->id = 2;
+
+	return ohci_platform_probe(dev);
+}
+
+
+static const struct of_device_id ohci1_sunplus_dt_ids[] = {
+	{ .compatible = "sunplus,sunplus-q628-usb-ohci1" },
+	{ }
+};
+
+MODULE_DEVICE_TABLE(of, ohci1_sunplus_dt_ids);
+
+static struct platform_driver ohci1_hcd_sunplus_driver = {
+	.probe			= ohci1_sunplus_platform_probe,
+	.remove			= ohci_platform_remove,
+	.shutdown		= usb_hcd_platform_shutdown,
+	.driver = {
+		.name		= "ohci1-sunplus",
+		.of_match_table = ohci1_sunplus_dt_ids,
+	}
+};
+
+/*-------------------------------------------------------------------------*/
+
+static int __init ohci1_sunplus_init(void)
+{
+	if (sp_port_enabled & PORT1_ENABLED){
+		printk(KERN_NOTICE "register ohci1_hcd_sunplus_driver\n");
+		return platform_driver_register(&ohci1_hcd_sunplus_driver);	
+	} else {
+		printk(KERN_NOTICE "warn,port1 not enable,not register ohci1 sunplus hcd driver\n");
+		return -1;
+	}
+}
+module_init(ohci1_sunplus_init);
+
+static void __exit ohci1_sunplus_cleanup(void)
+{
+	platform_driver_unregister(&ohci1_hcd_sunplus_driver);
+}
+module_exit(ohci1_sunplus_cleanup);
+
+MODULE_ALIAS("platform:ohci1-sunplus");
+MODULE_DESCRIPTION(DRIVER_DESC);
+MODULE_LICENSE("GPL");
+
--- a/drivers/usb/host/ohci.h	2018-11-23 10:16:15.984817558 +0300
+++ a/drivers/usb/host/ohci.h	2018-11-23 10:31:03.808050397 +0300
@@ -433,10 +433,6 @@
 	struct dentry		*debug_async;
 	struct dentry		*debug_periodic;
 	struct dentry		*debug_registers;
-
-	/* platform-specific data -- must come last */
-	unsigned long           priv[0] __aligned(sizeof(s64));
-
 };
 
 #ifdef CONFIG_USB_PCI
--- a/drivers/usb/host/ohci-hcd.c	2018-11-23 10:16:15.983817617 +0300
+++ a/drivers/usb/host/ohci-hcd.c	2018-11-23 10:31:03.803050694 +0300
@@ -39,11 +39,15 @@
 #include <linux/dmapool.h>
 #include <linux/workqueue.h>
 #include <linux/debugfs.h>
+#include <linux/platform_device.h>
+
 
 #include <asm/io.h>
 #include <asm/irq.h>
 #include <asm/unaligned.h>
 #include <asm/byteorder.h>
+#include <linux/usb/sp_usb.h>
+
 
 
 #define DRIVER_AUTHOR "Roman Weissgaerber, David Brownell"
@@ -70,6 +74,12 @@
 /*-------------------------------------------------------------------------*/
 
 static const char	hcd_name [] = "ohci_hcd";
+#ifdef CONFIG_USB_OHCI_SPHE8700_TD_FIX
+u32 td_fix_flag = 0;
+#define set_td_fix_flag() (td_fix_flag |=  1)
+#define clr_td_fix_flag() (td_fix_flag &= ~1)
+#define get_td_fix_flag() (td_fix_flag & 0x1)
+#endif
 
 #define	STATECHANGE_DELAY	msecs_to_jiffies(300)
 #define	IO_WATCHDOG_DELAY	msecs_to_jiffies(275)
@@ -78,6 +88,7 @@
 #include "pci-quirks.h"
 
 static void ohci_dump(struct ohci_hcd *ohci);
+static int ohci_init(struct ohci_hcd *ohci);
 static void ohci_stop(struct usb_hcd *hcd);
 static void io_watchdog_func(unsigned long _ohci);
 
@@ -855,6 +866,7 @@
 	struct ohci_hcd		*ohci = hcd_to_ohci (hcd);
 	struct ohci_regs __iomem *regs = ohci->regs;
 	int			ints;
+	int port_status;
 
 	/* Read interrupt status (and flush pending writes).  We ignore the
 	 * optimization of checking the LSB of hcca->done_head; it doesn't
@@ -959,9 +971,53 @@
 	}
 	spin_unlock(&ohci->lock);
 
+#ifdef CONFIG_USB_HOST_NOT_FINISH_QTD_WHEN_DISC_WORKAROUND
+	port_status = ohci_readl(ohci, &ohci->regs->roothub.portstatus[0]);
+	if ((!(port_status & RH_PS_CCS)) || (port_status & RH_PS_CSC)) {
+		tasklet_schedule(&hcd->host_irq_tasklet);
+	}
+#endif
+
 	return IRQ_HANDLED;
 }
 
+#ifdef CONFIG_USB_HOST_NOT_FINISH_QTD_WHEN_DISC_WORKAROUND
+struct api_context {
+	struct completion done;
+	int status;
+};
+static void ohci_irq_tasklet(unsigned long data)
+{
+	int port_status;
+	struct api_context *ctx;
+	struct platform_device *pdev;
+	struct usb_hcd *hcd = (void *)data;
+	struct ohci_hcd *ohci = hcd_to_ohci(hcd);
+
+	pdev = to_platform_device(hcd->self.controller);
+	port_status = ohci_readl(ohci, &ohci->regs->roothub.portstatus[0]);
+	printk(KERN_NOTICE "ohci_irq,id:%d,ps:%x\n",pdev->id - 1,port_status);
+	if (hcd->current_active_urb && hcd->enum_msg_flag) {
+		printk(KERN_NOTICE "ohci_irq,dev disc,ps:%x\n",port_status);
+		ctx = hcd->current_active_urb->context;
+		hcd->enum_msg_flag = false;
+		hcd->current_active_urb = NULL;
+		ctx->status = -ENOTCONN_IRQ;
+		complete(&ctx->done);
+	}
+}
+#endif
+
+int ohci_get_port_status_from_register(struct usb_hcd *hcd)
+{
+	struct ohci_hcd *ohci = hcd_to_ohci(hcd);
+	int port_status = ohci_readl(ohci, &ohci->regs->roothub.portstatus[0]);
+
+	printk(KERN_DEBUG "o_ps:%x\n", port_status);
+
+	return port_status;
+}
+
 /*-------------------------------------------------------------------------*/
 
 static void ohci_stop (struct usb_hcd *hcd)
@@ -1245,6 +1301,11 @@
 #define PLATFORM_DRIVER		ohci_hcd_tilegx_driver
 #endif
 
+#ifdef CONFIG_USB_OHCI_HCD_PLATFORM
+#include "ohci-platform.c"
+#endif
+
+#if 0
 static int __init ohci_hcd_mod_init(void)
 {
 	int retval = 0;
@@ -1333,7 +1394,7 @@
 	clear_bit(USB_OHCI_LOADED, &usb_hcds_loaded);
 	return retval;
 }
-module_init(ohci_hcd_mod_init);
+/*module_init(ohci_hcd_mod_init);*/
 
 static void __exit ohci_hcd_mod_exit(void)
 {
@@ -1358,5 +1419,5 @@
 	debugfs_remove(ohci_debug_root);
 	clear_bit(USB_OHCI_LOADED, &usb_hcds_loaded);
 }
-module_exit(ohci_hcd_mod_exit);
-
+/*module_exit(ohci_hcd_mod_exit);*/
+#endif
--- a/drivers/usb/host/ohci-hub.c	2018-11-23 10:16:15.983817617 +0300
+++ a/drivers/usb/host/ohci-hub.c	2018-11-23 10:31:03.800050872 +0300
@@ -337,6 +337,48 @@
 	return rc;
 }
 
+/* Carry out the final steps of resuming the controller device */
+static void ohci_finish_controller_resume(struct usb_hcd *hcd)
+{
+	struct ohci_hcd		*ohci = hcd_to_ohci(hcd);
+	int			port;
+	bool			need_reinit = false;
+
+	/* See if the controller is already running or has been reset */
+	ohci->hc_control = ohci_readl(ohci, &ohci->regs->control);
+	if (ohci->hc_control & (OHCI_CTRL_IR | OHCI_SCHED_ENABLES)) {
+		need_reinit = true;
+	} else {
+		switch (ohci->hc_control & OHCI_CTRL_HCFS) {
+		case OHCI_USB_OPER:
+		case OHCI_USB_RESET:
+			need_reinit = true;
+		}
+	}
+
+	/* If needed, reinitialize and suspend the root hub */
+	if (need_reinit) {
+		spin_lock_irq(&ohci->lock);
+		ohci_rh_resume(ohci);
+		ohci_rh_suspend(ohci, 0);
+		spin_unlock_irq(&ohci->lock);
+	}
+
+	/* Normally just turn on port power and enable interrupts */
+	else {
+		ohci_dbg(ohci, "powerup ports\n");
+		for (port = 0; port < ohci->num_ports; port++)
+			ohci_writel(ohci, RH_PS_PPS,
+					&ohci->regs->roothub.portstatus[port]);
+
+		ohci_writel(ohci, OHCI_INTR_MIE, &ohci->regs->intrenable);
+		ohci_readl(ohci, &ohci->regs->intrenable);
+		msleep(20);
+	}
+
+	usb_hcd_resume_root_hub(hcd);
+}
+
 /* Carry out polling-, autostop-, and autoresume-related state changes */
 static int ohci_root_hub_state_changes(struct ohci_hcd *ohci, int changed,
 		int any_connected, int rhsc_status)
--- a/drivers/usb/host/ohci-platform.c	2018-11-23 10:16:15.983817617 +0300
+++ a/drivers/usb/host/ohci-platform.c	2018-11-23 10:31:03.804050634 +0300
@@ -3,7 +3,6 @@
  *
  * Copyright 2007 Michael Buesch <m@bues.ch>
  * Copyright 2011-2012 Hauke Mehrtens <hauke@hauke-m.de>
- * Copyright 2014 Hans de Goede <hdegoede@redhat.com>
  *
  * Derived from the OCHI-SSB driver
  * Derived from the OHCI-PCI driver
@@ -14,386 +13,618 @@
  *
  * Licensed under the GNU/GPL. See COPYING for details.
  */
-
-#include <linux/clk.h>
-#include <linux/dma-mapping.h>
-#include <linux/hrtimer.h>
-#include <linux/io.h>
-#include <linux/kernel.h>
-#include <linux/module.h>
-#include <linux/err.h>
-#include <linux/phy/phy.h>
 #include <linux/platform_device.h>
-#include <linux/reset.h>
 #include <linux/usb/ohci_pdriver.h>
-#include <linux/usb.h>
-#include <linux/usb/hcd.h>
 
-#include "ohci.h"
+#include <linux/kthread.h>
+#include <linux/notifier.h>
+//#include "ohci.h"
+
+#ifdef CONFIG_USB_SP_UDC_HOST
+#include "udc-to-host.h"
+#endif
+
+#if defined(CONFIG_USB_HOST_RESET) || defined(CONFIG_USB_HOST_RESET_SP)
 
-#define DRIVER_DESC "OHCI generic platform driver"
-#define OHCI_MAX_CLKS 3
-#define OHCI_MAX_RESETS 2
-#define hcd_to_ohci_priv(h) ((struct ohci_platform_priv *)hcd_to_ohci(h)->priv)
-
-struct ohci_platform_priv {
-	struct clk *clks[OHCI_MAX_CLKS];
-	struct reset_control *resets[OHCI_MAX_RESETS];
-	struct phy **phys;
-	int num_phys;
+struct ohci_hcd_sp {
+	/* must be 1st member here for hcd_to_ehci() to work */
+	struct ohci_hcd ohci;
+
+	struct task_struct *reset_thread;
+	struct notifier_block ohci_notifier;
+
+#ifdef CONFIG_USB_SP_UDC_HOST
+	struct notifier_block udc_notifier;
+#endif
+
+	u32 flag;
+
+#define RESET_UPHY_SIGN	(1<<0)
+#define RESET_HC_SIGN		(1<<1)
+#define RESET_SENDER		(1<<31)
+#define FASTBOOT_FG			(1<<30)
 };
 
-static const char hcd_name[] = "ohci-platform";
+#elif defined CONFIG_USB_SP_UDC_HOST
 
-static int ohci_platform_power_on(struct platform_device *dev)
-{
-	struct usb_hcd *hcd = platform_get_drvdata(dev);
-	struct ohci_platform_priv *priv = hcd_to_ohci_priv(hcd);
-	int clk, ret, phy_num;
+struct ohci_hcd_sp {
+	/* must be 1st member here for hcd_to_ehci() to work */
+	struct ohci_hcd ohci;
+	struct notifier_block udc_notifier;
+};
+#endif
 
-	for (clk = 0; clk < OHCI_MAX_CLKS && priv->clks[clk]; clk++) {
-		ret = clk_prepare_enable(priv->clks[clk]);
-		if (ret)
-			goto err_disable_clks;
-	}
+#if 1				/*fix ohci msi */
+/*
+*twofish suggest that latency should not
+*exceed 8192 clock cycles(system clock),about 24.8us
+*/
+s32 get_td_retry_time = 24;
+#endif
 
-	for (phy_num = 0; phy_num < priv->num_phys; phy_num++) {
-		ret = phy_init(priv->phys[phy_num]);
-		if (ret)
-			goto err_exit_phy;
-		ret = phy_power_on(priv->phys[phy_num]);
-		if (ret) {
-			phy_exit(priv->phys[phy_num]);
-			goto err_exit_phy;
-		}
-	}
+static int ohci_platform_reset(struct usb_hcd *hcd)
+{
+	struct platform_device *pdev = to_platform_device(hcd->self.controller);
+	struct usb_ohci_pdata *pdata = pdev->dev.platform_data;
+	struct ohci_hcd *ohci = hcd_to_ohci(hcd);
+	int err;
 
-	return 0;
+	if (pdata->big_endian_desc)
+		ohci->flags |= OHCI_QUIRK_BE_DESC;
+	if (pdata->big_endian_mmio)
+		ohci->flags |= OHCI_QUIRK_BE_MMIO;
+	if (pdata->no_big_frame_no)
+		ohci->flags |= OHCI_QUIRK_FRAME_NO;
 
-err_exit_phy:
-	while (--phy_num >= 0) {
-		phy_power_off(priv->phys[phy_num]);
-		phy_exit(priv->phys[phy_num]);
-	}
-err_disable_clks:
-	while (--clk >= 0)
-		clk_disable_unprepare(priv->clks[clk]);
+	ohci_hcd_init(ohci);
+	err = ohci_init(ohci);
 
-	return ret;
+	return err;
 }
 
-static void ohci_platform_power_off(struct platform_device *dev)
+static int ohci_platform_start(struct usb_hcd *hcd)
 {
-	struct usb_hcd *hcd = platform_get_drvdata(dev);
-	struct ohci_platform_priv *priv = hcd_to_ohci_priv(hcd);
-	int clk, phy_num;
+	struct ohci_hcd *ohci = hcd_to_ohci(hcd);
+	int err;
 
-	for (phy_num = 0; phy_num < priv->num_phys; phy_num++) {
-		phy_power_off(priv->phys[phy_num]);
-		phy_exit(priv->phys[phy_num]);
+	err = ohci_run(ohci);
+	if (err < 0) {
+		ohci_err(ohci, "can't start\n");
+		ohci_stop(hcd);
 	}
 
-	for (clk = OHCI_MAX_CLKS - 1; clk >= 0; clk--)
-		if (priv->clks[clk])
-			clk_disable_unprepare(priv->clks[clk]);
+	return err;
 }
 
-static struct hc_driver __read_mostly ohci_platform_hc_driver;
+static const struct hc_driver ohci_platform_hc_driver = {
+	.description = hcd_name,
+	.product_desc = "Generic Platform OHCI Controller",
+#if defined(CONFIG_USB_HOST_RESET) || defined(CONFIG_USB_HOST_RESET_SP)
+	.hcd_priv_size = sizeof(struct ohci_hcd_sp),
+#else
+	.hcd_priv_size = sizeof(struct ohci_hcd),
+#endif
 
-static const struct ohci_driver_overrides platform_overrides __initconst = {
-	.product_desc =		"Generic Platform OHCI controller",
-	.extra_priv_size =	sizeof(struct ohci_platform_priv),
-};
+	.irq = ohci_irq,
+	.flags = HCD_MEMORY | HCD_USB11,
 
-static struct usb_ohci_pdata ohci_platform_defaults = {
-	.power_on =		ohci_platform_power_on,
-	.power_suspend =	ohci_platform_power_off,
-	.power_off =		ohci_platform_power_off,
+	.reset = ohci_platform_reset,
+	.start = ohci_platform_start,
+	.stop = ohci_stop,
+	.shutdown = ohci_shutdown,
+
+	.urb_enqueue = ohci_urb_enqueue,
+	.urb_dequeue = ohci_urb_dequeue,
+	.endpoint_disable = ohci_endpoint_disable,
+
+	.get_frame_number = ohci_get_frame,
+
+	.hub_status_data = ohci_hub_status_data,
+	.hub_control = ohci_hub_control,
+#ifdef	CONFIG_PM
+	.bus_suspend = ohci_bus_suspend,
+	.bus_resume = ohci_bus_resume,
+#endif
+
+	.start_port_reset = ohci_start_port_reset,
+	.get_port_status_from_register = ohci_get_port_status_from_register,
 };
 
-static int ohci_platform_probe(struct platform_device *dev)
+#if defined(CONFIG_USB_HOST_RESET) || defined(CONFIG_USB_HOST_RESET_SP)
+#include <mach/io_map.h>
+#define 	RESET_UPHY(x,ret,addr)	{				\
+				ret	 = ioread32(addr);		\
+				ret |= (1<<(9+x))|(1<<(12+x));		\
+				iowrite32(ret,addr);			\
+				ret &= ~((1<<(9+x))|(1<<(12+x)));	\
+				iowrite32(ret,addr);			\
+			}
+#define		REG_UPHY_RESET_OFFSET	(18)
+#endif
+
+#ifdef 	CONFIG_USB_HOST_RESET
+
+static int ohci_reset_thread(void *arg)
 {
-	struct usb_hcd *hcd;
-	struct resource *res_mem;
-	struct usb_ohci_pdata *pdata = dev_get_platdata(&dev->dev);
-	struct ohci_platform_priv *priv;
-	struct ohci_hcd *ohci;
-	int err, irq, phy_num, clk = 0, rst = 0;
+	struct ohci_hcd_sp *sp_ohci = (struct ohci_hcd_sp *)arg;
+	struct ohci_hcd *ohci = (struct ohci_hcd *)arg;
+	struct usb_hcd *hcd = ohci_to_hcd(ohci);
+	struct platform_device *pdev = to_platform_device(hcd->self.controller);
 
-	if (usb_disabled())
-		return -ENODEV;
+	u32 val;
+	int i;
+	//int flag = 1;
 
-	/*
-	 * Use reasonable defaults so platforms don't have to provide these
-	 * with DT probing on ARM.
-	 */
-	if (!pdata)
-		pdata = &ohci_platform_defaults;
+	while (1) {
 
-	err = dma_coerce_mask_and_coherent(&dev->dev, DMA_BIT_MASK(32));
-	if (err)
-		return err;
+		if (sp_ohci->flag & (RESET_UPHY_SIGN | RESET_HC_SIGN)) {
 
-	irq = platform_get_irq(dev, 0);
-	if (irq < 0) {
-		dev_err(&dev->dev, "no irq provided");
-		return irq;
+			while (hcd->self.devmap.devicemap[0] != 2)
+				msleep(1);
+
+			if (hcd->self.devmap.devicemap[0] > 2) {
+				goto NEXT_LOOP;
+			}
+
+			for (i = 1; i < 128 / (8 * sizeof(unsigned long)); i++) {
+				if (hcd->self.devmap.devicemap[i]) {
+					goto NEXT_LOOP;
+				}
+			}
+
+			/*hcd->irq will be set to 0 by ohci_stop() */
+			if (pdev->id == 1) {
+				i = SP_IRQ_OHCI_USB0;
+			} else if (pdev->id == 2) {
+				i = SP_IRQ_OHCI_USB1;
+			}
+
+			if (sp_ohci->flag & RESET_UPHY_SIGN) {
+				reset_uphy(pdev->id - 1);
+				sp_ohci->flag = RESET_SENDER;
+			} else {
+				sp_ohci->flag = 0;
+			}
+
+			hcd->irq = i;
+			usb_remove_hcd(hcd);
+			ohci_usb_reset(ohci);
+			msleep(1);
+			usb_add_hcd(hcd, i, IRQF_SHARED);
+		}
+
+NEXT_LOOP:
+		sp_ohci->flag = 0;
+		msleep(30);
 	}
 
-	hcd = usb_create_hcd(&ohci_platform_hc_driver, &dev->dev,
-			dev_name(&dev->dev));
-	if (!hcd)
-		return -ENOMEM;
+	return 0;
+}
 
-	platform_set_drvdata(dev, hcd);
-	dev->dev.platform_data = pdata;
-	priv = hcd_to_ohci_priv(hcd);
-	ohci = hcd_to_ohci(hcd);
-
-	if (pdata == &ohci_platform_defaults && dev->dev.of_node) {
-		if (of_property_read_bool(dev->dev.of_node, "big-endian-regs"))
-			ohci->flags |= OHCI_QUIRK_BE_MMIO;
-
-		if (of_property_read_bool(dev->dev.of_node, "big-endian-desc"))
-			ohci->flags |= OHCI_QUIRK_BE_DESC;
-
-		if (of_property_read_bool(dev->dev.of_node, "big-endian"))
-			ohci->flags |= OHCI_QUIRK_BE_MMIO | OHCI_QUIRK_BE_DESC;
-
-		if (of_property_read_bool(dev->dev.of_node, "no-big-frame-no"))
-			ohci->flags |= OHCI_QUIRK_FRAME_NO;
-
-		of_property_read_u32(dev->dev.of_node, "num-ports",
-				     &ohci->num_ports);
-
-		priv->num_phys = of_count_phandle_with_args(dev->dev.of_node,
-				"phys", "#phy-cells");
-
-		if (priv->num_phys > 0) {
-			priv->phys = devm_kcalloc(&dev->dev, priv->num_phys,
-					    sizeof(struct phy *), GFP_KERNEL);
-			if (!priv->phys)
-				return -ENOMEM;
-		} else
-			priv->num_phys = 0;
-
-		for (phy_num = 0; phy_num < priv->num_phys; phy_num++) {
-			priv->phys[phy_num] = devm_of_phy_get_by_index(
-					&dev->dev, dev->dev.of_node, phy_num);
-			if (IS_ERR(priv->phys[phy_num])) {
-				err = PTR_ERR(priv->phys[phy_num]);
-				goto err_put_hcd;
-			} else if (!hcd->phy) {
-				/* Avoiding phy_get() in usb_add_hcd() */
-				hcd->phy = priv->phys[phy_num];
+#elif defined(CONFIG_USB_HOST_RESET_SP)
+
+#ifdef CONFIG_USB_GADGET_SUNPLUS
+extern void usb_switch(int device);
+#ifdef CONFIG_USB_MULTIPLE_RESET_PROBLEM_WORKAROUND
+extern void ctrl_rx_squelch(void);
+#endif
+extern void detech_start(void);
+#endif
+
+#ifdef CONFIG_USB_LOGO_TEST
+extern u32 usb_logo_test_start;
+#endif
+
+static int ohci_reset_thread(void *arg)
+{
+	struct ohci_hcd *ohci = (struct ohci_hcd *)arg;
+	struct ohci_hcd_sp *sp_ohci = (struct ohci_hcd_sp *)arg;
+	struct usb_hcd *hcd = ohci_to_hcd(ohci);
+	struct platform_device *pdev = to_platform_device(hcd->self.controller);
+	u32 flag;
+	int i;
+	int irq_num = 0;
+	void __iomem *reg_addr;
+
+	do {
+
+NEXT_LOOP:
+		msleep(1);
+		wait_event_interruptible(hcd->reset_queue,
+					 ((sp_ohci->flag &
+					   (RESET_UPHY_SIGN | RESET_HC_SIGN)) !=
+					  0) || kthread_should_stop());
+
+		if (kthread_should_stop())
+			break;
+
+#ifdef CONFIG_USB_LOGO_TEST
+		if (usb_logo_test_start == 1) {
+			sp_ohci->flag = 0;
+			continue;
+		}
+#endif
+
+		/*besure nothing on hcd bus */
+		for (i = 1; i < 128 / (8 * sizeof(unsigned long)); i++) {
+			if (hcd->self.devmap.devicemap[i]) {
+				sp_ohci->flag = 0;
+				goto NEXT_LOOP;
 			}
 		}
 
-		for (clk = 0; clk < OHCI_MAX_CLKS; clk++) {
-			priv->clks[clk] = of_clk_get(dev->dev.of_node, clk);
-			if (IS_ERR(priv->clks[clk])) {
-				err = PTR_ERR(priv->clks[clk]);
-				if (err == -EPROBE_DEFER)
-					goto err_put_clks;
-				priv->clks[clk] = NULL;
-				break;
+		printk("### %s  devicemap=%lx +\n", __FUNCTION__, hcd->self.devmap.devicemap[0]);
+		if (hcd->self.devmap.devicemap[0] == 2) {
+			irq_num = hcd->irq;
+			flag = sp_ohci->flag;
+			/*Clear flag  */
+			clear_bit(HCD_FLAG_RH_RUNNING, &hcd->flags);
+			clear_bit(HCD_FLAG_DEAD, &hcd->flags);
+
+			disable_irq(hcd->irq);
+			usb_remove_hcd(hcd);
+
+#ifndef CONFIG_USB_SUNPLUS_OTG
+			if (flag & RESET_UPHY_SIGN) {
+				reg_addr = (pdev->id - 1) ? uphy1_base_addr : uphy0_base_addr;
+				hcd->uphy_disconnect_level[pdev->id - 1] = readl(reg_addr + DISC_LEVEL_OFFSET);
+				reset_uphy(pdev->id - 1);
+				reinit_uphy(pdev->id - 1);
+				writel(hcd->uphy_disconnect_level[pdev->id - 1], reg_addr + DISC_LEVEL_OFFSET);
+				/*tell ehci reset controllor */
+				sp_ohci->flag = RESET_SENDER;
+#ifdef CONFIG_USB_GADGET_SUNPLUS
+				printk(KERN_NOTICE
+				       "port_num:%d,device_mode_flag:%d\n",
+				       pdev->id - 1,
+				       platform_device_mode_flag[pdev->id - 1]);
+				if (platform_device_mode_flag[pdev->id - 1]) {
+					platform_device_mode_flag[pdev->id -
+								  1] = false;
+					msleep(1);
+					usb_switch(1);
+					msleep(1);
+#ifdef CONFIG_USB_MULTIPLE_RESET_PROBLEM_WORKAROUND
+					/*control squelch signal */
+					ctrl_rx_squelch();
+					msleep(1);
+#endif
+					detech_start();
+				}
+#endif
 			}
+#endif
+			msleep(100);
+
+			usb_add_hcd(hcd, irq_num, IRQF_DISABLED | IRQF_SHARED);
+
+			sp_ohci->flag &= ~RESET_HC_SIGN;
+
+#ifdef CONFIG_USB_OHCI_SPHE8700_TD_FIX
+			/*clear td fix flag */
+			clr_td_fix_flag();
+#endif
+
+			if (enum_rx_active_flag[pdev->id - 1]) {
+				printk(KERN_NOTICE
+				       "rx-active,ohci reset finish\n");
+				up(&enum_rx_active_reset_sem[pdev->id - 1]);
+			}
+		} else {
+			sp_ohci->flag = 0;
 		}
-		for (rst = 0; rst < OHCI_MAX_RESETS; rst++) {
-			priv->resets[rst] =
-				devm_reset_control_get_shared_by_index(
-								&dev->dev, rst);
-			if (IS_ERR(priv->resets[rst])) {
-				err = PTR_ERR(priv->resets[rst]);
-				if (err == -EPROBE_DEFER)
-					goto err_reset;
-				priv->resets[rst] = NULL;
-				break;
+	} while (!kthread_should_stop());
+
+	return 0;
+}
+
+#endif
+
+#if defined(CONFIG_USB_HOST_RESET) || defined(CONFIG_USB_HOST_RESET_SP)
+
+static int ohci_notifier_call(struct notifier_block *self,
+			      unsigned long action, void *dev)
+{
+	struct usb_device *udev = (struct usb_device *)dev;
+
+	struct usb_hcd *hcd_e;
+	struct platform_device *pdev_e;
+	u32 *ptr;
+
+	struct ohci_hcd_sp *sp_ohci = container_of((void *)self,
+						   struct ohci_hcd_sp,
+						   ohci_notifier);
+	struct ohci_hcd *ohci = (struct ohci_hcd *)sp_ohci;
+	struct usb_hcd *hcd_o = ohci_to_hcd(ohci);
+	struct platform_device *pdev_o =
+	    to_platform_device(hcd_o->self.controller);
+
+	//printk("notifier ohci\n");
+
+	if (action == USB_DEVICE_ADD) {
+
+		if (!udev->parent) {	//roothub add
+
+			hcd_e = bus_to_hcd(udev->bus);
+			pdev_e = to_platform_device(hcd_e->self.controller);
+			ptr = (u32 *) ((u8 *) hcd_e->hcd_priv +
+				       hcd_e->driver->hcd_priv_size -
+				       sizeof(u32)
+			    );
+			//printk("notifier ohci %p 0x%x\n",ptr,*ptr);
+
+			//EHCI&OHCI on one port
+			if ((pdev_e != pdev_o) && (pdev_e->id == pdev_o->id)) {
+				if (ptr && (*ptr & RESET_SENDER)) {
+					sp_ohci->flag =
+					    RESET_HC_SIGN & (~RESET_UPHY_SIGN);
+					*ptr &= ~RESET_SENDER;
+#ifdef CONFIG_USB_HOST_RESET_SP
+					wake_up_interruptible(&hcd_o->
+							      reset_queue);
+#endif
+				}
 			}
-			err = reset_control_deassert(priv->resets[rst]);
-			if (err)
-				goto err_reset;
 		}
 	}
 
-	if (pdata->big_endian_desc)
-		ohci->flags |= OHCI_QUIRK_BE_DESC;
-	if (pdata->big_endian_mmio)
-		ohci->flags |= OHCI_QUIRK_BE_MMIO;
-	if (pdata->no_big_frame_no)
-		ohci->flags |= OHCI_QUIRK_FRAME_NO;
-	if (pdata->num_ports)
-		ohci->num_ports = pdata->num_ports;
+	return 0;
+}
+
+#endif
+
+#ifdef CONFIG_USB_SP_UDC_HOST
+
+static int udc_notifier_call(struct notifier_block *self,
+			     unsigned long action, void *dev)
+{
+	struct ohci_hcd_sp *sp_ohci = container_of((void *)self,
+						   struct ohci_hcd_sp,
+						   udc_notifier);
+	struct ohci_hcd *ohci = (struct ohci_hcd *)sp_ohci;
+	struct usb_hcd *hcd = ohci_to_hcd(ohci);
+
+	struct udc_hcd_platform_device *udc_dev =
+	    (struct udc_hcd_platform_device *)dev;
+
+	//u32 *grop1 = (u32*)VA_IOB_ADDR(1*32*4);
+	//u32 ret;
+
+	//printk("udc notifier %lx %x %p\n",action,hcd->rh_registered,hcd);
+
+	if (hcd->rh_registered == 1)
+		//usb_remove_hcd(hcd);
+
+		if (action == USB_DEVICE_ADD) {
+			//if(hcd->rh_registered == 1)
+			//      usb_remove_hcd(hcd);
+			//ret = ioread32(grop1 + 10);
+			//ret &= ~(1<<4);
+			//iowrite32(ret,grop1 + 10);
+			while (HC_IS_RUNNING(hcd->state))
+				msleep(1);
+			//SET_TO_UDC_OHCI(udc_dev->state);
+			SET_TO_UDC(udc_dev->state);
+		}
 
-#ifndef CONFIG_USB_OHCI_BIG_ENDIAN_MMIO
-	if (ohci->flags & OHCI_QUIRK_BE_MMIO) {
-		dev_err(&dev->dev,
-			"Error: CONFIG_USB_OHCI_BIG_ENDIAN_MMIO not set\n");
-		err = -EINVAL;
-		goto err_reset;
+	if (action == USB_DEVICE_REMOVE) {
+
+		//if(hcd->rh_registered == 1)
+		//      usb_remove_hcd(hcd);
+
+		//ret = ioread32(grop1 + 10);
+		//ret |= (1<<4);
+		//iowrite32(ret,grop1 + 10);
+
+		//usb_add_hcd(hcd, hcd->irq, IRQF_SHARED);
 	}
+
+	return 0;
+}
+
 #endif
-#ifndef CONFIG_USB_OHCI_BIG_ENDIAN_DESC
-	if (ohci->flags & OHCI_QUIRK_BE_DESC) {
-		dev_err(&dev->dev,
-			"Error: CONFIG_USB_OHCI_BIG_ENDIAN_DESC not set\n");
-		err = -EINVAL;
-		goto err_reset;
+
+#if 1				/*fix ohci msi */
+static ssize_t show_get_td_retry_time(struct device *dev,
+				      struct device_attribute *attr, char *buf)
+{
+	printk(KERN_DEBUG "get get_td_retry_time\n");
+
+	return sprintf(buf, "%d\n", get_td_retry_time);
+}
+
+static ssize_t store_get_td_retry_time(struct device *dev,
+				       struct device_attribute *attr,
+				       const char *buf, size_t count)
+{
+	printk(KERN_DEBUG "set get_td_retry_time\n");
+	if (kstrtouint(buf, 0, &get_td_retry_time) == 0) {
+		printk(KERN_DEBUG "%d\n", get_td_retry_time);
+	} else {
+		printk(KERN_NOTICE "set get_td_retry_time fail\n");
 	}
+
+	return count;
+}
+
+static DEVICE_ATTR(get_td_retry_time, S_IWUSR | S_IRUSR,
+		   show_get_td_retry_time, store_get_td_retry_time);
+#endif
+
+static struct usb_ohci_pdata usb_ohci_pdata = {
+};
+
+int ohci_platform_probe(struct platform_device *dev)
+{
+	struct usb_hcd *hcd;
+	struct resource *res_mem;
+	int irq;
+	int err = -ENOMEM;
+
+#if defined(CONFIG_USB_HOST_RESET) || defined(CONFIG_USB_HOST_RESET_SP) || defined(CONFIG_USB_SP_UDC_HOST)
+	struct ohci_hcd_sp *ohci_sp;
 #endif
 
-	if (pdata->power_on) {
-		err = pdata->power_on(dev);
-		if (err < 0)
-			goto err_reset;
+	//BUG_ON(!dev->dev.platform_data);
+
+	if (usb_disabled())
+		return -ENODEV;
+
+	dev->dev.platform_data = &usb_ohci_pdata;
+	irq = platform_get_irq(dev, 0);
+	if (irq < 0) {
+		pr_err("no irq provieded");
+		return irq;
 	}
+	printk("ohci_id:%d,irq:%d\n",dev->id,irq);
 
 	res_mem = platform_get_resource(dev, IORESOURCE_MEM, 0);
-	hcd->regs = devm_ioremap_resource(&dev->dev, res_mem);
-	if (IS_ERR(hcd->regs)) {
-		err = PTR_ERR(hcd->regs);
-		goto err_power;
+	if (!res_mem) {
+		pr_err("no memory recourse provieded");
+		return -ENXIO;
 	}
+
+	hcd = usb_create_hcd(&ohci_platform_hc_driver, &dev->dev,
+			     dev_name(&dev->dev));
+	if (!hcd)
+		return -ENOMEM;
+
 	hcd->rsrc_start = res_mem->start;
 	hcd->rsrc_len = resource_size(res_mem);
 
+#ifdef	CONFIG_USB_USE_PLATFORM_RESOURCE
+	if (!request_mem_region(hcd->rsrc_start, hcd->rsrc_len, hcd_name)) {
+		pr_err("controller already in use");
+		err = -EBUSY;
+		goto err_put_hcd;
+	}
+
+	hcd->regs = ioremap_nocache(hcd->rsrc_start, hcd->rsrc_len);
+	if (!hcd->regs)
+		goto err_release_region;
+#else
+	hcd->regs = (void *)res_mem->start;
+#endif
+#ifdef CONFIG_USB_HOST_NOT_FINISH_QTD_WHEN_DISC_WORKAROUND
+	tasklet_init(&hcd->host_irq_tasklet, ohci_irq_tasklet, (unsigned long)hcd);
+#endif
 	err = usb_add_hcd(hcd, irq, IRQF_SHARED);
 	if (err)
-		goto err_power;
-
-	device_wakeup_enable(hcd->self.controller);
+		goto err_iounmap;
 
 	platform_set_drvdata(dev, hcd);
 
-	return err;
+#if defined(CONFIG_USB_HOST_RESET) || defined(CONFIG_USB_HOST_RESET_SP) || defined(CONFIG_USB_SP_UDC_HOST)
+	ohci_sp = (struct ohci_hcd_sp *)hcd_to_ohci(hcd);
+#endif
 
-err_power:
-	if (pdata->power_off)
-		pdata->power_off(dev);
-err_reset:
-	while (--rst >= 0)
-		reset_control_assert(priv->resets[rst]);
-err_put_clks:
-	while (--clk >= 0)
-		clk_put(priv->clks[clk]);
-err_put_hcd:
-	if (pdata == &ohci_platform_defaults)
-		dev->dev.platform_data = NULL;
+#ifdef CONFIG_USB_SP_UDC_HOST
 
-	usb_put_hcd(hcd);
+	/*udc/host uphy notifier */
+	if (dev->id == 3) {
+		ohci_sp->udc_notifier.notifier_call = udc_notifier_call;
+		udc_register_notify(&ohci_sp->udc_notifier);
+	}
+#endif
 
+#if 1				/*fix ohci msi */
+	device_create_file(&dev->dev, &dev_attr_get_td_retry_time);
+#endif
+
+#if defined(CONFIG_USB_HOST_RESET) || defined(CONFIG_USB_HOST_RESET_SP)
+	//struct ohci_hcd_sp *ohci_sp = (struct ohci_hcd_sp *)hcd_to_ohci(hcd);
+	ohci_sp->ohci_notifier.notifier_call = ohci_notifier_call;
+	usb_register_notify(&ohci_sp->ohci_notifier);
+
+	ohci_sp->flag = 0;
+	printk(KERN_DEBUG "flag *** %d %d %p\n", sizeof(struct ohci_hcd_sp),
+	       hcd->driver->hcd_priv_size, &ohci_sp->flag);
+
+#ifdef 	CONFIG_USB_HOST_RESET
+	ohci_sp->reset_thread = kthread_create(ohci_reset_thread,
+					       hcd_to_ohci(hcd),
+					       "ohci_reset_polling");
+#elif defined(CONFIG_USB_HOST_RESET_SP)
+
+	init_waitqueue_head(&hcd->reset_queue);
+	hcd->ptr_flag = &ohci_sp->flag;
+
+	ohci_sp->reset_thread = kthread_create(ohci_reset_thread,
+					       hcd_to_ohci(hcd),
+					       "ohci_reset_wait_event");
+#endif
+	if (IS_ERR(ohci_sp->reset_thread)) {
+		pr_err("Create OHCI(%d) reset thread fail!\n", dev->id);
+		return err;
+	}
+
+	/* Tell the thread to start working */
+	wake_up_process(ohci_sp->reset_thread);
+
+#endif
+	return err;
+err_iounmap:
+#ifdef	CONFIG_USB_USE_PLATFORM_RESOURCE
+	iounmap(hcd->regs);
+err_release_region:
+	release_mem_region(hcd->rsrc_start, hcd->rsrc_len);
+err_put_hcd:
+#endif
+	usb_put_hcd(hcd);
 	return err;
 }
 
-static int ohci_platform_remove(struct platform_device *dev)
+int ohci_platform_remove(struct platform_device *dev)
 {
 	struct usb_hcd *hcd = platform_get_drvdata(dev);
-	struct usb_ohci_pdata *pdata = dev_get_platdata(&dev->dev);
-	struct ohci_platform_priv *priv = hcd_to_ohci_priv(hcd);
-	int clk, rst;
 
-	usb_remove_hcd(hcd);
+#if defined(CONFIG_USB_HOST_RESET) || defined(CONFIG_USB_HOST_RESET_SP)|| defined(CONFIG_USB_SP_UDC_HOST)
+	struct ohci_hcd_sp *ohci_sp = (struct ohci_hcd_sp *)hcd_to_ohci(hcd);
+#endif
+
+#if 1				/*fix ohci msi */
+	device_remove_file(&dev->dev, &dev_attr_get_td_retry_time);
+#endif
 
-	if (pdata->power_off)
-		pdata->power_off(dev);
+#ifdef CONFIG_USB_SP_UDC_HOST
+	if (dev->id == 3)
+		udc_unregister_notify(&ohci_sp->udc_notifier);
+#endif
 
-	for (rst = 0; rst < OHCI_MAX_RESETS && priv->resets[rst]; rst++)
-		reset_control_assert(priv->resets[rst]);
+#if defined(CONFIG_USB_HOST_RESET) || defined(CONFIG_USB_HOST_RESET_SP)
+	kthread_stop(ohci_sp->reset_thread);
+	usb_unregister_notify(&ohci_sp->ohci_notifier);
+#endif
 
-	for (clk = 0; clk < OHCI_MAX_CLKS && priv->clks[clk]; clk++)
-		clk_put(priv->clks[clk]);
+	usb_remove_hcd(hcd);
 
+#ifdef	CONFIG_USB_USE_PLATFORM_RESOURCE
+	iounmap(hcd->regs);
+	release_mem_region(hcd->rsrc_start, hcd->rsrc_len);
+#endif
 	usb_put_hcd(hcd);
-
-	if (pdata == &ohci_platform_defaults)
-		dev->dev.platform_data = NULL;
+	platform_set_drvdata(dev, NULL);
 
 	return 0;
 }
 
-#ifdef CONFIG_PM_SLEEP
+#ifdef CONFIG_PM
+
 static int ohci_platform_suspend(struct device *dev)
 {
-	struct usb_hcd *hcd = dev_get_drvdata(dev);
-	struct usb_ohci_pdata *pdata = dev->platform_data;
-	struct platform_device *pdev = to_platform_device(dev);
-	bool do_wakeup = device_may_wakeup(dev);
-	int ret;
-
-	ret = ohci_suspend(hcd, do_wakeup);
-	if (ret)
-		return ret;
-
-	if (pdata->power_suspend)
-		pdata->power_suspend(pdev);
-
-	return ret;
+	return 0;
 }
 
 static int ohci_platform_resume(struct device *dev)
 {
 	struct usb_hcd *hcd = dev_get_drvdata(dev);
-	struct usb_ohci_pdata *pdata = dev_get_platdata(dev);
-	struct platform_device *pdev = to_platform_device(dev);
-
-	if (pdata->power_on) {
-		int err = pdata->power_on(pdev);
-		if (err < 0)
-			return err;
-	}
 
-	ohci_resume(hcd, false);
+	ohci_finish_controller_resume(hcd);
 	return 0;
 }
-#endif /* CONFIG_PM_SLEEP */
-
-static const struct of_device_id ohci_platform_ids[] = {
-	{ .compatible = "generic-ohci", },
-	{ .compatible = "cavium,octeon-6335-ohci", },
-	{ }
-};
-MODULE_DEVICE_TABLE(of, ohci_platform_ids);
-
-static const struct platform_device_id ohci_platform_table[] = {
-	{ "ohci-platform", 0 },
-	{ }
-};
-MODULE_DEVICE_TABLE(platform, ohci_platform_table);
-
-static SIMPLE_DEV_PM_OPS(ohci_platform_pm_ops, ohci_platform_suspend,
-	ohci_platform_resume);
-
-static struct platform_driver ohci_platform_driver = {
-	.id_table	= ohci_platform_table,
-	.probe		= ohci_platform_probe,
-	.remove		= ohci_platform_remove,
-	.shutdown	= usb_hcd_platform_shutdown,
-	.driver		= {
-		.name	= "ohci-platform",
-		.pm	= &ohci_platform_pm_ops,
-		.of_match_table = ohci_platform_ids,
-	}
-};
-
-static int __init ohci_platform_init(void)
-{
-	if (usb_disabled())
-		return -ENODEV;
-
-	pr_info("%s: " DRIVER_DESC "\n", hcd_name);
-
-	ohci_init_driver(&ohci_platform_hc_driver, &platform_overrides);
-	return platform_driver_register(&ohci_platform_driver);
-}
-module_init(ohci_platform_init);
 
-static void __exit ohci_platform_cleanup(void)
-{
-	platform_driver_unregister(&ohci_platform_driver);
-}
-module_exit(ohci_platform_cleanup);
+#else /* !CONFIG_PM */
+#define ohci_platform_suspend	NULL
+#define ohci_platform_resume	NULL
+#endif /* CONFIG_PM */
 
-MODULE_DESCRIPTION(DRIVER_DESC);
-MODULE_AUTHOR("Hauke Mehrtens");
-MODULE_AUTHOR("Alan Stern");
-MODULE_LICENSE("GPL");
--- a/drivers/usb/host/ohci-platform.h	1970-01-01 03:00:00.000000000 +0300
+++ a/drivers/usb/host/ohci-platform.h	2018-11-23 10:31:03.805050575 +0300
@@ -0,0 +1,10 @@
+#ifndef __OHCI_PLATFORM_H
+#define __OHCI_PLATFORM_H
+
+int ohci_platform_probe(struct platform_device *dev);
+
+int ohci_platform_remove(struct platform_device *dev);
+
+
+#endif
+
--- a/drivers/usb/Kconfig	2018-11-23 10:16:15.951819518 +0300
+++ a/drivers/usb/Kconfig	2018-11-23 10:31:03.799050932 +0300
@@ -2,6 +2,21 @@
 # USB device configuration
 #
 
+config GEMINI_USB
+	bool "Support Gemini USB"
+	select SCSI
+	select USB
+	select USB_SUPPORT
+	select USB_ARCH_HAS_EHCI
+	select USB_ARCH_HAS_OHCI
+#	select USB_EHCI_HCD_PLATFORM
+#	select USB_OHCI_HCD_PLATFORM
+#	select USB_EHCI_HCD
+#	select USB_OHCI_HCD
+	select USB_STORAGE
+	help
+	  Sunplus Gemini platform USB support
+
 config USB_OHCI_BIG_ENDIAN_DESC
 	bool
 
@@ -28,6 +43,22 @@
 	  You will also need drivers from the following menu to make use of it.
 
 if USB_SUPPORT
+# usb ports freely determine enable/disable
+config USB_PORT0
+	boolean "Sunplus Gemini USB PORT 0"
+	default y
+
+config USB_PORT1
+	boolean "Sunplus Gemini USB PORT 1"
+	default y
+
+config USB_GADGET_ENABLED
+	bool
+	default y if (USB_PORT0 || USB_PORT1)
+
+config USB_GADGET_PORT0_ENABLED
+	boolean "Sunplus Gemini USB gadget port 0"
+	default n
 
 config USB_COMMON
 	tristate
@@ -85,6 +116,18 @@
 
 if USB
 
+config USB_HOST_ENUM_RETRY
+	bool "Enable USB Host Enum Retry"
+	depends on USB
+
+config USB_MULTIPLE_RESET_PROBLEM_WORKAROUND
+	bool "Enable USB Multiple Reset Problem Workaround"
+	depends on USB
+
+config USB_HOST_NOT_FINISH_QTD_WHEN_DISC_WORKAROUND
+	bool "Enable Workaround USB Host Not Finish QTD When Disconnect"
+	depends on USB
+
 source "drivers/usb/core/Kconfig"
 
 source "drivers/usb/mon/Kconfig"
@@ -162,6 +205,8 @@
 
 source "drivers/usb/gadget/Kconfig"
 
+source "drivers/usb/bc/Kconfig"
+
 source "drivers/usb/typec/Kconfig"
 
 config USB_LED_TRIG
--- a/drivers/usb/Makefile	2018-11-23 10:16:15.951819518 +0300
+++ a/drivers/usb/Makefile	2018-11-23 10:31:03.787051645 +0300
@@ -60,6 +60,7 @@
 obj-$(CONFIG_USB_GADGET)	+= gadget/
 
 obj-$(CONFIG_USB_COMMON)	+= common/
+obj-y				+= bc/
 
 obj-$(CONFIG_USBIP_CORE)	+= usbip/
 
--- a/drivers/usb/phy/Kconfig	2018-11-23 10:16:15.997816785 +0300
+++ a/drivers/usb/phy/Kconfig	2018-11-23 10:31:03.808050397 +0300
@@ -3,6 +3,10 @@
 #
 menu "USB Physical Layer drivers"
 
+config SUNPLUS_USB_PHY
+	boolean "Sunplus USB PHY"
+	default y
+
 config USB_PHY
 	def_bool n
 
--- a/drivers/usb/phy/Makefile	2018-11-23 10:16:15.997816785 +0300
+++ a/drivers/usb/phy/Makefile	2018-11-23 10:31:03.809050337 +0300
@@ -1,27 +1,29 @@
 #
 # Makefile for physical layer USB drivers
 #
-obj-$(CONFIG_USB_PHY)			+= phy.o
-obj-$(CONFIG_OF)			+= of.o
 
-# transceiver drivers, keep the list sorted
+obj-$(CONFIG_SUNPLUS_USB_PHY)			+= phy0-sunplus.o phy1-sunplus.o
+
+#obj-$(CONFIG_USB_PHY)			+= phy.o
+#obj-$(CONFIG_OF)			+= of.o
 
-obj-$(CONFIG_AB8500_USB)		+= phy-ab8500-usb.o
-obj-$(CONFIG_FSL_USB2_OTG)		+= phy-fsl-usb.o
-obj-$(CONFIG_ISP1301_OMAP)		+= phy-isp1301-omap.o
-obj-$(CONFIG_NOP_USB_XCEIV)		+= phy-generic.o
-obj-$(CONFIG_TAHVO_USB)			+= phy-tahvo.o
-obj-$(CONFIG_AM335X_CONTROL_USB)	+= phy-am335x-control.o
-obj-$(CONFIG_AM335X_PHY_USB)		+= phy-am335x.o
-obj-$(CONFIG_OMAP_OTG)			+= phy-omap-otg.o
-obj-$(CONFIG_TWL6030_USB)		+= phy-twl6030-usb.o
-obj-$(CONFIG_USB_EHCI_TEGRA)		+= phy-tegra-usb.o
-obj-$(CONFIG_USB_GPIO_VBUS)		+= phy-gpio-vbus-usb.o
-obj-$(CONFIG_USB_ISP1301)		+= phy-isp1301.o
-obj-$(CONFIG_USB_MSM_OTG)		+= phy-msm-usb.o
-obj-$(CONFIG_USB_QCOM_8X16_PHY)	+= phy-qcom-8x16-usb.o
-obj-$(CONFIG_USB_MV_OTG)		+= phy-mv-usb.o
-obj-$(CONFIG_USB_MXS_PHY)		+= phy-mxs-usb.o
-obj-$(CONFIG_USB_ULPI)			+= phy-ulpi.o
-obj-$(CONFIG_USB_ULPI_VIEWPORT)		+= phy-ulpi-viewport.o
-obj-$(CONFIG_KEYSTONE_USB_PHY)		+= phy-keystone.o
+# transceiver drivers, keep the list sorted
+#obj-$(CONFIG_AB8500_USB)		+= phy-ab8500-usb.o
+#obj-$(CONFIG_FSL_USB2_OTG)		+= phy-fsl-usb.o
+#obj-$(CONFIG_ISP1301_OMAP)		+= phy-isp1301-omap.o
+#obj-$(CONFIG_NOP_USB_XCEIV)		+= phy-generic.o
+#obj-$(CONFIG_TAHVO_USB)			+= phy-tahvo.o
+#obj-$(CONFIG_AM335X_CONTROL_USB)	+= phy-am335x-control.o
+#obj-$(CONFIG_AM335X_PHY_USB)		+= phy-am335x.o
+#obj-$(CONFIG_OMAP_OTG)			+= phy-omap-otg.o
+#obj-$(CONFIG_TWL6030_USB)		+= phy-twl6030-usb.o
+#obj-$(CONFIG_USB_EHCI_TEGRA)		+= phy-tegra-usb.o
+#obj-$(CONFIG_USB_GPIO_VBUS)		+= phy-gpio-vbus-usb.o
+#obj-$(CONFIG_USB_ISP1301)		+= phy-isp1301.o
+#obj-$(CONFIG_USB_MSM_OTG)		+= phy-msm-usb.o
+#obj-$(CONFIG_USB_QCOM_8X16_PHY)	+= phy-qcom-8x16-usb.o
+#obj-$(CONFIG_USB_MV_OTG)		+= phy-mv-usb.o
+#obj-$(CONFIG_USB_MXS_PHY)		+= phy-mxs-usb.o
+#obj-$(CONFIG_USB_ULPI)			+= phy-ulpi.o
+#obj-$(CONFIG_USB_ULPI_VIEWPORT)		+= phy-ulpi-viewport.o
+#obj-$(CONFIG_KEYSTONE_USB_PHY)		+= phy-keystone.o
--- a/drivers/usb/phy/phy0-sunplus.c	1970-01-01 03:00:00.000000000 +0300
+++ a/drivers/usb/phy/phy0-sunplus.c	2018-11-12 06:42:56.000000000 +0300
@@ -0,0 +1,163 @@
+#include <linux/kernel.h>
+#include <linux/export.h>
+#include <linux/err.h>
+#include <linux/device.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/of.h>
+#include <linux/platform_device.h>
+#include <linux/usb/phy.h>
+#include <linux/usb/sp_usb.h>
+
+static struct resource *uphy0_res_mem;
+
+static void uphy0_init(void)
+{
+	u32 val, set;
+	void __iomem *usb_otp_reg;
+	void __iomem *regs = (void __iomem *)B_SYSTEM_BASE;
+
+	usb_otp_reg = ioremap_nocache(USB_OTP_REG, 1);
+
+	/* 1. Default value modification */
+	writel(RF_MASK_V(0xffff, 0x4002), regs + UPHY0_CTL0_OFFSET);
+	writel(RF_MASK_V(0xffff, 0x8747), regs + UPHY0_CTL1_OFFSET);
+
+	/* 2. PLL power off/on twice */
+	writel(RF_MASK_V(0xffff, 0x88), regs + UPHY0_CTL3_OFFSET);
+	mdelay(1);
+	writel(RF_MASK_V(0xffff, 0x80), regs + UPHY0_CTL3_OFFSET);
+	mdelay(1);
+	writel(RF_MASK_V(0xffff, 0x88), regs + UPHY0_CTL3_OFFSET);
+	mdelay(1);
+	writel(RF_MASK_V(0xffff, 0x80), regs + UPHY0_CTL3_OFFSET);
+	mdelay(1);
+	writel(RF_MASK_V(0xffff, 0x00), regs + UPHY0_CTL3_OFFSET);
+
+	/* 3. reset UPHY0 */
+	writel(RF_MASK_V_SET(1 << 13), regs + USB_RESET_OFFSET);
+	writel(RF_MASK_V_CLR(1 << 13), regs + USB_RESET_OFFSET);
+	mdelay(1);
+
+	/* 4.b board uphy 0 internal register modification for tid certification */
+	val = readl(usb_otp_reg);
+	set = val & OTP_DISC_LEVEL_BIT;
+	if (!set || set >= OTP_DISC_LEVEL_BIT) {
+		set = DISC_LEVEL_DEFAULT;
+	}
+
+	val = readl(uphy0_base_addr + DISC_LEVEL_OFFSET);
+	val = (val & ~OTP_DISC_LEVEL_BIT) | (OTP_DISC_LEVEL_TEMP - set);
+	writel(val, uphy0_base_addr + DISC_LEVEL_OFFSET);
+	
+	val = readl(uphy0_base_addr + ECO_PATH_OFFSET);
+	val &= ~(ECO_PATH_SET);
+	writel(val, uphy0_base_addr + ECO_PATH_OFFSET);
+
+	val = readl(uphy0_base_addr + POWER_SAVING_OFFSET);
+	val &= ~(POWER_SAVING_SET);
+	writel(val, uphy0_base_addr + POWER_SAVING_OFFSET);
+
+	/* 5. USBC 0 reset */
+	writel(RF_MASK_V_SET(1 << 10), regs + USB_RESET_OFFSET);
+	writel(RF_MASK_V_CLR(1 << 10), regs + USB_RESET_OFFSET);
+	
+	/* port 0 uphy clk fix */
+	writel(RF_MASK_V_SET(1 << 6), regs + UPHY0_CTL2_OFFSET);
+
+	/* 6. switch to host */
+	writel(RF_MASK_V_SET(3 << 4), regs + USBC_CTL_OFFSET);
+
+#ifdef CONFIG_USB_SUNPLUS_OTG
+	writel(RF_MASK_V_CLR(1 << 4), regs + USBC_CTL_OFFSET);
+	mdelay(1);
+#endif
+
+	iounmap(usb_otp_reg);
+}
+
+static int sunplus_usb_phy0_probe(struct platform_device *pdev)
+{
+	uphy0_irq_num = platform_get_irq(pdev, 0);
+	if (uphy0_irq_num < 0) {
+		printk(KERN_NOTICE "no irq provieded,ret:%d\n",uphy0_irq_num);
+		return uphy0_irq_num;
+	}
+	printk(KERN_NOTICE "uphy0_irq:%d\n",uphy0_irq_num);
+
+	uphy0_res_mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!uphy0_res_mem) {
+		printk(KERN_NOTICE "no memory recourse provieded");
+		return -ENXIO;
+	}
+
+	if (!request_mem_region(uphy0_res_mem->start, resource_size(uphy0_res_mem), "uphy0")) {
+		printk(KERN_NOTICE "hw already in use");
+		return -EBUSY;
+	}
+
+	uphy0_base_addr = ioremap_nocache(uphy0_res_mem->start, resource_size(uphy0_res_mem));
+	if (!uphy0_base_addr){
+		release_mem_region(uphy0_res_mem->start, resource_size(uphy0_res_mem));
+		 return -EFAULT;
+	}
+	
+	uphy0_init();
+
+	return 0;
+}
+
+static int sunplus_usb_phy0_remove(struct platform_device *pdev)
+{
+	iounmap(uphy0_base_addr);
+	release_mem_region(uphy0_res_mem->start, resource_size(uphy0_res_mem));
+
+	return 0;
+}
+
+static const struct of_device_id phy0_sunplus_dt_ids[] = {
+	{ .compatible = "sunplus,sunplus-usb-phy0" },
+	{ }
+};
+
+MODULE_DEVICE_TABLE(of, phy0_sunplus_dt_ids);
+
+static struct platform_driver sunplus_usb_phy0_driver = {
+	.probe		= sunplus_usb_phy0_probe,
+	.remove		= sunplus_usb_phy0_remove,
+	.driver		= {
+		.name	= "sunplus-usb-phy0",
+		.of_match_table = phy0_sunplus_dt_ids,
+	},
+};
+
+
+static int __init usb_phy0_sunplus_init(void)
+{
+	if (sp_port_enabled & PORT0_ENABLED) {
+		printk(KERN_NOTICE "register sunplus_usb_phy0_driver\n");
+		return platform_driver_register(&sunplus_usb_phy0_driver);	
+	} else {
+		printk(KERN_NOTICE "uphy0 not enabled\n");
+		return 0;
+	}
+}
+subsys_initcall(usb_phy0_sunplus_init);
+
+static void __exit usb_phy0_sunplus_exit(void)
+{
+	if (sp_port_enabled & PORT0_ENABLED) {
+		printk(KERN_NOTICE "unregister sunplus_usb_phy0_driver\n");
+		platform_driver_unregister(&sunplus_usb_phy0_driver);
+	} else {
+		printk(KERN_NOTICE "uphy0 not enabled\n");
+		return;
+	}
+}
+module_exit(usb_phy0_sunplus_exit);
+
+
+MODULE_ALIAS("sunplus_usb_phy0");
+MODULE_AUTHOR("qiang.deng");
+MODULE_LICENSE("GPL");
+
--- a/drivers/usb/phy/phy1-sunplus.c	1970-01-01 03:00:00.000000000 +0300
+++ a/drivers/usb/phy/phy1-sunplus.c	2018-11-12 06:42:56.000000000 +0300
@@ -0,0 +1,163 @@
+#include <linux/kernel.h>
+#include <linux/export.h>
+#include <linux/err.h>
+#include <linux/device.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/of.h>
+#include <linux/platform_device.h>
+#include <linux/usb/phy.h>
+#include <linux/usb/sp_usb.h>
+
+static struct resource *uphy1_res_mem;
+
+static void uphy1_init(void)
+{
+	u32 val, set;
+	void __iomem *usb_otp_reg;
+	void __iomem *regs = (void __iomem *)B_SYSTEM_BASE;
+
+	usb_otp_reg = ioremap_nocache(USB_OTP_REG, 1);
+
+	/* 1. Default value modification */
+	writel(RF_MASK_V(0xffff, 0x4002), regs + UPHY1_CTL0_OFFSET);
+	writel(RF_MASK_V(0xffff, 0x8747), regs + UPHY1_CTL1_OFFSET);
+
+	/* 2. PLL power off/on twice */
+	writel(RF_MASK_V(0xffff, 0x88), regs + UPHY1_CTL3_OFFSET);
+	mdelay(1);
+	writel(RF_MASK_V(0xffff, 0x80), regs + UPHY1_CTL3_OFFSET);
+	mdelay(1);
+	writel(RF_MASK_V(0xffff, 0x88), regs + UPHY1_CTL3_OFFSET);
+	mdelay(1);
+	writel(RF_MASK_V(0xffff, 0x80), regs + UPHY1_CTL3_OFFSET);
+	mdelay(1);
+	writel(RF_MASK_V(0xffff, 0x00), regs + UPHY1_CTL3_OFFSET);
+
+
+	/* 3. reset UPHY 1 */
+	writel(RF_MASK_V_SET(1 << 14), regs + USB_RESET_OFFSET);
+	writel(RF_MASK_V_CLR(1 << 14), regs + USB_RESET_OFFSET);
+	mdelay(1);
+
+	/* 4.b board uphy 1 internal register modification for tid certification */
+	val = readl(usb_otp_reg);
+	set = (val >> UPHY1_OTP_DISC_LEVEL_OFFSET) & OTP_DISC_LEVEL_BIT;
+	if (!set || set >= OTP_DISC_LEVEL_BIT) {
+		set = DISC_LEVEL_DEFAULT;
+	}
+
+	val = readl(uphy1_base_addr + DISC_LEVEL_OFFSET);
+	val = (val & ~OTP_DISC_LEVEL_BIT) | (OTP_DISC_LEVEL_TEMP - set);
+	writel(val, uphy1_base_addr + DISC_LEVEL_OFFSET);
+	
+	val = readl(uphy1_base_addr + ECO_PATH_OFFSET);
+	val &= ~(ECO_PATH_SET);
+	writel(val, uphy1_base_addr + ECO_PATH_OFFSET);
+	val = readl(uphy1_base_addr + POWER_SAVING_OFFSET);
+	val &= ~(POWER_SAVING_SET);
+	writel(val, uphy1_base_addr + POWER_SAVING_OFFSET);
+
+	/* 5. USBC 1 reset */
+	writel(RF_MASK_V_SET(1 << 11), regs + USB_RESET_OFFSET);
+	writel(RF_MASK_V_CLR(1 << 11), regs + USB_RESET_OFFSET);
+
+	/* port 1 uphy clk fix */
+	writel(RF_MASK_V_SET(1 << 6), regs + UPHY1_CTL2_OFFSET);
+
+	/* 6. switch to host */
+	writel(RF_MASK_V_SET(3 << 12), regs + USBC_CTL_OFFSET);
+
+#ifdef CONFIG_USB_SUNPLUS_OTG
+	writel(RF_MASK_V_CLR(1 << 12), regs + USBC_CTL_OFFSET);
+	mdelay(1);
+#endif
+
+	iounmap(usb_otp_reg);
+}
+
+static int sunplus_usb_phy1_probe(struct platform_device *pdev)
+{
+	uphy1_irq_num = platform_get_irq(pdev, 0);
+	if (uphy1_irq_num < 0) {
+		printk(KERN_NOTICE "no irq provieded,ret:%d\n",uphy1_irq_num);
+		return uphy1_irq_num;
+	}
+	printk(KERN_NOTICE "uphy0_irq:%d\n",uphy1_irq_num);
+
+	uphy1_res_mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!uphy1_res_mem) {
+		printk(KERN_NOTICE "no memory recourse provieded");
+		return -ENXIO;
+	}
+
+	if (!request_mem_region(uphy1_res_mem->start, resource_size(uphy1_res_mem), "uphy0")) {
+		printk(KERN_NOTICE "hw already in use");
+		return -EBUSY;
+	}
+
+	uphy1_base_addr = ioremap_nocache(uphy1_res_mem->start, resource_size(uphy1_res_mem));
+	if (!uphy1_base_addr){
+		release_mem_region(uphy1_res_mem->start, resource_size(uphy1_res_mem));
+		 return -EFAULT;
+	}
+	
+	uphy1_init();
+
+	return 0;
+}
+
+static int sunplus_usb_phy1_remove(struct platform_device *pdev)
+{
+	iounmap(uphy1_base_addr);
+	release_mem_region(uphy1_res_mem->start, resource_size(uphy1_res_mem));
+
+	return 0;
+}
+
+static const struct of_device_id phy1_sunplus_dt_ids[] = {
+	{ .compatible = "sunplus,sunplus-usb-phy1" },
+	{ }
+};
+
+MODULE_DEVICE_TABLE(of, phy1_sunplus_dt_ids);
+
+static struct platform_driver sunplus_usb_phy1_driver = {
+	.probe		= sunplus_usb_phy1_probe,
+	.remove		= sunplus_usb_phy1_remove,
+	.driver		= {
+		.name	= "sunplus-usb-phy1",
+		.of_match_table = phy1_sunplus_dt_ids,
+	},
+};
+
+
+static int __init usb_phy1_sunplus_init(void)
+{
+	if (sp_port_enabled & PORT1_ENABLED) {
+		printk(KERN_NOTICE "register sunplus_usb_phy1_driver\n");
+		return platform_driver_register(&sunplus_usb_phy1_driver);	
+	} else {
+		printk(KERN_NOTICE "uphy1 not enabled\n");
+		return 0;
+	}
+}
+subsys_initcall(usb_phy1_sunplus_init);
+
+static void __exit usb_phy1_sunplus_exit(void)
+{
+	if (sp_port_enabled & PORT1_ENABLED) {
+		printk(KERN_NOTICE "unregister sunplus_usb_phy1_driver\n");
+		platform_driver_unregister(&sunplus_usb_phy1_driver);
+	} else {
+		printk(KERN_NOTICE "uphy1 not enabled\n");
+		return;
+	}
+}
+module_exit(usb_phy1_sunplus_exit);
+
+
+MODULE_ALIAS("sunplus_usb_phy1");
+MODULE_AUTHOR("qiang.deng");
+MODULE_LICENSE("GPL");
+
--- a/drivers/usb/storage/transport.c	2018-11-23 10:16:16.011815954 +0300
+++ a/drivers/usb/storage/transport.c	2018-11-23 10:31:03.798050991 +0300
@@ -1116,6 +1116,9 @@
 	return 0;
 }
 
+#ifdef CONFIG_USB_HOST_RESET_SP
+extern void Usb_dev_power_reset(struct usb_device *udev,int delayms);
+#endif
 int usb_stor_Bulk_transport(struct scsi_cmnd *srb, struct us_data *us)
 {
 	struct bulk_cb_wrap *bcb = (struct bulk_cb_wrap *) us->iobuf;
@@ -1176,6 +1179,15 @@
 				us->recv_bulk_pipe : us->send_bulk_pipe;
 		result = usb_stor_bulk_srb(us, pipe, srb);
 		usb_stor_dbg(us, "Bulk data transfer result 0x%x\n", result);
+#ifdef CONFIG_USB_HOST_RESET_SP
+		//printk("CMD=0x%x result=%d \n",srb->cmnd[0],result);
+		if ( (result == USB_STOR_XFER_STALLED)/*||(result == USB_STOR_XFER_ERROR)*/){
+			if ((srb->cmnd[0] == READ_10)||(srb->cmnd[0] == WRITE_10)){
+				printk("\n\n SCSI:%x stall \n",srb->cmnd[0] );
+				Usb_dev_power_reset(us->pusb_dev,2000);
+			}
+		}
+#endif
 		if (result == USB_STOR_XFER_ERROR)
 			return USB_STOR_TRANSPORT_ERROR;
 
--- a/drivers/usb/storage/usb.c	2018-11-23 10:16:16.012815894 +0300
+++ a/drivers/usb/storage/usb.c	2018-11-23 10:31:03.798050991 +0300
@@ -87,7 +87,7 @@
 module_param(delay_use, uint, S_IRUGO | S_IWUSR);
 MODULE_PARM_DESC(delay_use, "seconds to delay before using a new device");
 
-static char quirks[128];
+static char quirks[128] = "1567:8902:r,1234:ffff:n";
 module_param_string(quirks, quirks, sizeof(quirks), S_IRUGO | S_IWUSR);
 MODULE_PARM_DESC(quirks, "supplemental list of device IDs and their quirks");
 
--- a/include/linux/usb/ehci_pdriver.h	2018-11-23 10:16:16.366794866 +0300
+++ a/include/linux/usb/ehci_pdriver.h	2018-11-23 10:31:03.819049743 +0300
@@ -49,6 +49,8 @@
 	unsigned	no_io_watchdog:1;
 	unsigned	reset_on_resume:1;
 	unsigned	dma_mask_64:1;
+	unsigned	port_power_on:1;
+	unsigned	port_power_off:1;
 
 	/* Turn on all power and clocks */
 	int (*power_on)(struct platform_device *pdev);
--- a/include/linux/usb/gadget_chips.h	1970-01-01 03:00:00.000000000 +0300
+++ a/include/linux/usb/gadget_chips.h	2018-11-23 10:31:03.819049743 +0300
@@ -0,0 +1,158 @@
+/*
+ * USB device controllers have lots of quirks.  Use these macros in
+ * gadget drivers or other code that needs to deal with them, and which
+ * autoconfigures instead of using early binding to the hardware.
+ *
+ * This SHOULD eventually work like the ARM mach_is_*() stuff, driven by
+ * some config file that gets updated as new hardware is supported.
+ * (And avoiding all runtime comparisons in typical one-choice configs!)
+ *
+ * NOTE:  some of these controller drivers may not be available yet.
+ * Some are available on 2.4 kernels; several are available, but not
+ * yet pushed in the 2.6 mainline tree.
+ */
+
+#ifndef __GADGET_CHIPS_H
+#define __GADGET_CHIPS_H
+
+/*
+ * NOTICE: the entries below are alphabetical and should be kept
+ * that way.
+ *
+ * Always be sure to add new entries to the correct position or
+ * accept the bashing later.
+ *
+ * If you have forgotten the alphabetical order let VIM/EMACS
+ * do that for you.
+ */
+#define gadget_is_amd5536udc(g)		(!strcmp("amd5536udc", (g)->name))
+#define gadget_is_at91(g)		(!strcmp("at91_udc", (g)->name))
+#define gadget_is_atmel_usba(g)		(!strcmp("atmel_usba_udc", (g)->name))
+#define gadget_is_ci13xxx_msm(g)	(!strcmp("ci13xxx_msm", (g)->name))
+#define gadget_is_ci13xxx_pci(g)	(!strcmp("ci13xxx_pci", (g)->name))
+#define gadget_is_dummy(g)		(!strcmp("dummy_udc", (g)->name))
+#define gadget_is_dwc3(g)		(!strcmp("dwc3-gadget", (g)->name))
+#define gadget_is_fsl_qe(g)		(!strcmp("fsl_qe_udc", (g)->name))
+#define gadget_is_fsl_usb2(g)		(!strcmp("fsl-usb2-udc", (g)->name))
+#define gadget_is_goku(g)		(!strcmp("goku_udc", (g)->name))
+#define gadget_is_imx(g)		(!strcmp("imx_udc", (g)->name))
+#define gadget_is_langwell(g)		(!strcmp("langwell_udc", (g)->name))
+#define gadget_is_m66592(g)		(!strcmp("m66592_udc", (g)->name))
+#define gadget_is_musbhdrc(g)		(!strcmp("musb-hdrc", (g)->name))
+#define gadget_is_net2272(g)		(!strcmp("net2272", (g)->name))
+#define gadget_is_net2280(g)		(!strcmp("net2280", (g)->name))
+#define gadget_is_omap(g)		(!strcmp("omap_udc", (g)->name))
+#define gadget_is_pch(g)		(!strcmp("pch_udc", (g)->name))
+#define gadget_is_pxa(g)		(!strcmp("pxa25x_udc", (g)->name))
+#define gadget_is_pxa27x(g)		(!strcmp("pxa27x_udc", (g)->name))
+#define gadget_is_r8a66597(g)		(!strcmp("r8a66597_udc", (g)->name))
+#define gadget_is_renesas_usbhs(g)	(!strcmp("renesas_usbhs_udc", (g)->name))
+#define gadget_is_s3c2410(g)		(!strcmp("s3c2410_udc", (g)->name))
+#define gadget_is_s3c_hsotg(g)		(!strcmp("s3c-hsotg", (g)->name))
+#define gadget_is_s3c_hsudc(g)		(!strcmp("s3c-hsudc", (g)->name))
+
+#ifdef CONFIG_USB_GADGET_SUNPLUS
+#define gadget_is_sp628(g)     !strcmp("sp_udc", (g)->name)
+#else
+#define gadget_is_sp628(g)     0
+#endif
+#ifdef CONFIG_USB_GADGET_3502
+#define gadget_is_sp3502(g)	!strcmp("sp3502_udc", (g)->name)
+#else
+#define gadget_is_sp3502(g)	0
+#endif
+/**
+ * usb_gadget_controller_number - support bcdDevice id convention
+ * @gadget: the controller being driven
+ *
+ * Return a 2-digit BCD value associated with the peripheral controller,
+ * suitable for use as part of a bcdDevice value, or a negative error code.
+ *
+ * NOTE:  this convention is purely optional, and has no meaning in terms of
+ * any USB specification.  If you want to use a different convention in your
+ * gadget driver firmware -- maybe a more formal revision ID -- feel free.
+ *
+ * Hosts see these bcdDevice numbers, and are allowed (but not encouraged!)
+ * to change their behavior accordingly.  For example it might help avoiding
+ * some chip bug.
+ */
+static inline int usb_gadget_controller_number(struct usb_gadget *gadget)
+{
+	if (gadget_is_net2280(gadget))
+		return 0x01;
+	else if (gadget_is_dummy(gadget))
+		return 0x02;
+	else if (gadget_is_pxa(gadget))
+		return 0x03;
+	else if (gadget_is_goku(gadget))
+		return 0x06;
+	else if (gadget_is_omap(gadget))
+		return 0x08;
+	else if (gadget_is_pxa27x(gadget))
+		return 0x11;
+	else if (gadget_is_s3c2410(gadget))
+		return 0x12;
+	else if (gadget_is_at91(gadget))
+		return 0x13;
+	else if (gadget_is_imx(gadget))
+		return 0x14;
+	else if (gadget_is_musbhdrc(gadget))
+		return 0x16;
+	else if (gadget_is_atmel_usba(gadget))
+		return 0x18;
+	else if (gadget_is_fsl_usb2(gadget))
+		return 0x19;
+	else if (gadget_is_amd5536udc(gadget))
+		return 0x20;
+	else if (gadget_is_m66592(gadget))
+		return 0x21;
+	else if (gadget_is_fsl_qe(gadget))
+		return 0x22;
+	else if (gadget_is_ci13xxx_pci(gadget))
+		return 0x23;
+	else if (gadget_is_langwell(gadget))
+		return 0x24;
+	else if (gadget_is_r8a66597(gadget))
+		return 0x25;
+	else if (gadget_is_s3c_hsotg(gadget))
+		return 0x26;
+	else if (gadget_is_pch(gadget))
+		return 0x27;
+	else if (gadget_is_ci13xxx_msm(gadget))
+		return 0x28;
+	else if (gadget_is_renesas_usbhs(gadget))
+		return 0x29;
+	else if (gadget_is_s3c_hsudc(gadget))
+		return 0x30;
+	else if (gadget_is_net2272(gadget))
+		return 0x31;
+	else if (gadget_is_dwc3(gadget))
+		return 0x32;
+	else if (gadget_is_sp3502(gadget))		
+		return 0x33;
+	else if (gadget_is_sp628(gadget))
+                return 0x34;
+
+	return -ENOENT;
+}
+
+
+/**
+ * gadget_supports_altsettings - return true if altsettings work
+ * @gadget: the gadget in question
+ */
+static inline bool gadget_supports_altsettings(struct usb_gadget *gadget)
+{
+	/* PXA 21x/25x/26x has no altsettings at all */
+	if (gadget_is_pxa(gadget))
+		return false;
+
+	/* PXA 27x and 3xx have *broken* altsetting support */
+	if (gadget_is_pxa27x(gadget))
+		return false;
+
+	/* Everything else is *presumably* fine ... */
+	return true;
+}
+
+#endif /* __GADGET_CHIPS_H */
--- a/include/linux/usb/gadget.h	2018-11-23 10:16:16.366794866 +0300
+++ a/include/linux/usb/gadget.h	2018-11-23 10:31:03.820049683 +0300
@@ -303,7 +303,7 @@
 	void	(*get_config_params)(struct usb_dcd_config_params *);
 	int	(*udc_start)(struct usb_gadget *,
 			struct usb_gadget_driver *);
-	int	(*udc_stop)(struct usb_gadget *);
+	int	(*udc_stop)(struct usb_gadget_driver *);
 	struct usb_ep *(*match_ep)(struct usb_gadget *,
 			struct usb_endpoint_descriptor *,
 			struct usb_ss_ep_comp_descriptor *);
@@ -494,7 +494,14 @@
  */
 static inline int gadget_is_dualspeed(struct usb_gadget *g)
 {
-	return g->max_speed >= USB_SPEED_HIGH;
+#ifdef CONFIG_USB_GADGET_DUALSPEED
+	/* runtime test would check "g->max_speed" ... that might be
+	 * useful to work around hardware bugs, but is mostly pointless
+	 */
+	return true;
+#else
+	return false;
+#endif
 }
 
 /**
--- a/include/linux/usb/hcd.h	2018-11-23 10:16:16.366794866 +0300
+++ a/include/linux/usb/hcd.h	2018-11-23 10:31:03.818049802 +0300
@@ -205,6 +205,29 @@
 #define	HC_IS_RUNNING(state) ((state) & __ACTIVE)
 #define	HC_IS_SUSPENDED(state) ((state) & __SUSPEND)
 
+#ifdef CONFIG_USB_HOST_RESET_SP
+	wait_queue_head_t reset_queue;
+	u32 *ptr_flag;
+	u32 idle;
+#define RESET_UPHY_SIGN	(1<<0)
+#define	RESET_HC_SIGN	(1<<1)
+#define RESET_HC_DEAD	(1<<2)
+#define RESET_HC_CNT	(1<<3)
+#define RESET_HC_IPHONE	(1<<30)
+#define RESET_SENDER	(1<<31)
+#endif
+
+	u8 enum_msg_flag;
+	int uphy_irq_num;
+	int hub_port_num;
+	int enum_port_status;
+
+	bool *enum_flag;
+	u32 *uphy_disconnect_level;
+	struct task_struct *hub_thread;
+	struct urb *current_active_urb;
+	struct tasklet_struct host_irq_tasklet;
+
 	/* more shared queuing code would be good; it should support
 	 * smarter scheduling, handle transaction translators, etc;
 	 * input size of periodic table to an interrupt scheduler.
@@ -276,6 +299,11 @@
 	/* shutdown HCD */
 	void	(*shutdown) (struct usb_hcd *hcd);
 
+#ifdef CONFIG_USB_LOGO_TEST
+	/*  remon add for usb logo test */
+	int (*usb_logo_test) (struct usb_hcd * hcd, int idProduct);
+#endif
+
 	/* return current frame number */
 	int	(*get_frame_number) (struct usb_hcd *hcd);
 
@@ -398,7 +426,7 @@
 	int	(*find_raw_port_number)(struct usb_hcd *, int);
 	/* Call for power on/off the port if necessary */
 	int	(*port_power)(struct usb_hcd *hcd, int portnum, bool enable);
-
+	int (*get_port_status_from_register) (struct usb_hcd * hcd);
 };
 
 static inline int hcd_giveback_urb_in_bh(struct usb_hcd *hcd)
@@ -457,6 +485,15 @@
 struct platform_device;
 extern void usb_hcd_platform_shutdown(struct platform_device *dev);
 
+#include <linux/platform_device.h>
+static inline int usb_hcd_get_pl_id(struct usb_hcd *hcd)
+{
+	struct platform_device *pdev;
+
+	pdev = to_platform_device(hcd->self.controller);
+	return pdev->id;
+}
+
 #ifdef CONFIG_USB_PCI
 struct pci_dev;
 struct pci_device_id;
--- a/include/linux/usb/otg.h	2018-11-23 10:16:16.367794806 +0300
+++ a/include/linux/usb/otg.h	2018-11-23 10:31:03.817049862 +0300
@@ -56,6 +56,14 @@
 	bool adp_support;
 };
 
+#ifdef CONFIG_USB_SUNPLUS_OTG
+extern int usb_set_transceiver_sunplus(struct usb_phy *, int);
+#endif
+
+#ifdef CONFIG_USB_SUNPLUS_OTG
+extern struct usb_phy *usb_get_transceiver_sunplus(int bus_num);
+#endif
+
 extern const char *usb_otg_state_string(enum usb_otg_state state);
 
 /* Context: can sleep */
--- a/include/linux/usb/sp_usb.h	1970-01-01 03:00:00.000000000 +0300
+++ a/include/linux/usb/sp_usb.h	2018-11-23 10:31:03.818049802 +0300
@@ -0,0 +1,273 @@
+#ifndef __SP_USB_H
+#define __SP_USB_H
+
+#include <asm/io.h>
+#include <mach/irqs.h>
+#include <mach/io_map.h>
+#include <mach/gpio_drv.h>
+#include <linux/semaphore.h>
+#include <linux/io.h>
+
+#define RF_MASK_V(_mask, _val)       (((_mask) << 16) | (_val))
+#define RF_MASK_V_SET(_mask)        (((_mask) << 16) | (_mask))
+#define RF_MASK_V_CLR(_mask)        (((_mask) << 16) | 0)
+
+#define USB_PORT0_ID						0
+#define USB_PORT1_ID						1
+#define USB_PORT_NUM						3
+
+#define	VBUS_GPIO_CTRL_0					7
+#define	VBUS_GPIO_CTRL_1					87
+
+#define CDP_MODE_VALUE						0
+#define DCP_MODE_VALUE						1
+#define SDP_MODE_VALUE						2
+#define UPHY1_OTP_DISC_LEVEL_OFFSET 		5
+#define OTP_DISC_LEVEL_TEMP					0x16
+#define DISC_LEVEL_DEFAULT					0x0B
+#define OTP_DISC_LEVEL_BIT					0x1F
+#define GET_BC_MODE							0xFF00
+
+#define PORT0_ENABLED						(1 << 0)
+#define PORT1_ENABLED						(1 << 1)
+#define POWER_SAVING_SET					(1 << 5)
+#define ECO_PATH_SET						(1 << 6)
+#define	UPHY_DISC_0							(1 << 2)
+
+#define USB_RESET_OFFSET					0x5C
+#define USBC_CTL_OFFSET						0x244
+
+#define UPHY0_CTL0_OFFSET					0x248
+#define UPHY0_CTL1_OFFSET					0x24C
+#define UPHY0_CTL2_OFFSET					0x250
+#define UPHY0_CTL3_OFFSET					0x254
+#define UPHY1_CTL0_OFFSET					0x258
+#define UPHY1_CTL1_OFFSET					0x25C
+#define UPHY1_CTL2_OFFSET					0x260
+#define UPHY1_CTL3_OFFSET					0x264
+
+#define	POWER_SAVING_OFFSET					0x4
+
+#define DISC_LEVEL_OFFSET					0x1c
+#define	ECO_PATH_OFFSET						0x24
+#define	UPHY_DISC_OFFSET					0x28
+#define BIT_TEST_OFFSET						0x10
+#define CDP_REG_OFFSET						0x40
+#define	DCP_REG_OFFSET						0x44
+#define	UPHY_INTR_OFFSET					0x4c
+
+#define	UPHY_DEBUG_SIGNAL_REG_OFFSET		0x30
+#define UPHY_INTER_SIGNAL_REG_OFFSET		0xC
+#define USB_OTP_REG							0x9c00af18
+
+#define PORT_OWNERSHIP						0x00002000
+#define CURRENT_CONNECT_STATUS				0x00000001
+#define EHCI_CONNECT_STATUS_CHANGE			0x00000002
+#define OHCI_CONNECT_STATUS_CHANGE			0x00010000
+
+#define WAIT_TIME_AFTER_RESUME				25
+#define ELAPSE_TIME_AFTER_SUSPEND			15000
+#define SEND_SOF_TIME_BEFORE_SUSPEND		15000
+#define SEND_SOF_TIME_BEFORE_SEND_IN_PACKET	15000
+
+
+extern u32 bc_switch;
+extern u32 cdp_cfg16_value;
+extern u32 cdp_cfg17_value;
+extern u32 dcp_cfg16_value;
+extern u32 dcp_cfg17_value;
+extern u32 sdp_cfg16_value;
+extern u32 sdp_cfg17_value;
+
+extern int uphy0_irq_num;
+extern int uphy1_irq_num;
+extern void __iomem *uphy0_base_addr;
+extern void __iomem *uphy1_base_addr;
+
+extern u8 max_topo_level;
+extern bool tid_test_flag;
+extern u8 sp_port_enabled;
+extern uint accessory_port_id;
+extern bool enum_rx_active_flag[USB_PORT_NUM];
+extern bool platform_device_mode_flag[USB_PORT_NUM];
+extern struct semaphore enum_rx_active_reset_sem[USB_PORT_NUM];
+
+typedef enum {
+	eHW_GPIO_FIRST_FUNC = 0,
+	eHW_GPIO_FIRST_GPIO = 1,
+	eHW_GPIO_FIRST_NULL
+} eHW_GPIO_FIRST;
+
+typedef enum {
+	eHW_GPIO_IOP = 0,
+	eHW_GPIO_RISC = 1,
+	eHW_GPIO_MASTER_NULL
+} eHW_GPIO_Master;
+
+typedef enum {
+	eHW_GPIO_IN = 0,
+	eHW_GPIO_OUT = 1,
+	eHW_GPIO_OE_NULL
+} eHW_GPIO_OE;
+
+typedef enum {
+	eHW_GPIO_STS_LOW = 0,
+	eHW_GPIO_STS_HIGH = 1,
+	eHW_GPIO_STS_NULL
+} eHW_IO_STS;
+
+
+#define SET_USB_VBUS(gpio, Val) do {			\
+	GPIO_F_SET((gpio), eHW_GPIO_FIRST_GPIO);	\
+	GPIO_M_SET((gpio), eHW_GPIO_RISC);		\
+	GPIO_E_SET((gpio), eHW_GPIO_OUT);		\
+	GPIO_O_SET((gpio), (Val) & 0x01);		\
+} while (0)
+
+const static u8 USB_VBUS_PORT_NUM[2] = {VBUS_GPIO_CTRL_0, VBUS_GPIO_CTRL_1};
+
+#define	ENABLE_VBUS_POWER(port) SET_USB_VBUS(USB_VBUS_PORT_NUM[port], eHW_GPIO_STS_HIGH)
+
+#define	DISABLE_VBUS_POWER(port) SET_USB_VBUS(USB_VBUS_PORT_NUM[port], eHW_GPIO_STS_LOW)
+
+
+static inline void uphy_force_disc(int en, int port)
+{
+	void __iomem *reg_addr;
+	u32 uphy_val;
+
+	if (port > USB_PORT1_ID)
+		printk("-- err port num %d\n", port);
+
+	reg_addr = port ? uphy1_base_addr : uphy0_base_addr;
+	uphy_val = readl(reg_addr + UPHY_DISC_OFFSET);
+	if (en) {
+		uphy_val |= UPHY_DISC_0;
+	} else {
+		uphy_val &= ~UPHY_DISC_0;
+	}
+
+	writel(uphy_val, reg_addr + UPHY_DISC_OFFSET);
+}
+
+#define Reset_Usb_Power(port) do {	\
+	DISABLE_VBUS_POWER(port);	\
+	uphy_force_disc(1, (port));	\
+	msleep(500);			\
+	uphy_force_disc(0, (port));	\
+	ENABLE_VBUS_POWER(port);	\
+} while (0)
+
+static inline int get_uphy_swing(int port)
+{
+	int uphy_ctl_offset = port ? UPHY1_CTL2_OFFSET : UPHY0_CTL2_OFFSET;
+	void __iomem *reg_addr = (void __iomem *)B_SYSTEM_BASE;
+	u32 val;
+
+	val = readl(reg_addr + uphy_ctl_offset);
+	return (val >> 8) & 0xFF;
+
+	return 0;
+}
+
+static inline int set_uphy_swing(u32 swing, int port)
+{
+	int uphy_ctl_offset = port ? UPHY1_CTL2_OFFSET : UPHY0_CTL2_OFFSET;
+	void __iomem *reg_addr = (void __iomem *)B_SYSTEM_BASE;
+
+	writel(RF_MASK_V_CLR(0x3F << 8), reg_addr + uphy_ctl_offset);
+	writel(RF_MASK_V_SET((swing & 0x3F) << 8), reg_addr + uphy_ctl_offset);
+	writel(RF_MASK_V_SET(1 << 15), reg_addr + uphy_ctl_offset);
+
+	return 0;
+}
+
+static inline int get_disconnect_level(int port)
+{
+	void __iomem *reg_addr;
+	u32 val;
+
+	if (port > USB_PORT1_ID) {
+		return -1;
+	}
+
+	reg_addr = port ? uphy1_base_addr : uphy0_base_addr;
+	val = readl(reg_addr + DISC_LEVEL_OFFSET);
+
+	return val & 0x1F;
+}
+
+static inline int set_disconnect_level(u32 disc_level, int port)
+{
+	void __iomem *reg_addr;
+	u32 val;
+
+	if (port > USB_PORT1_ID) {
+		return -1;
+	}
+
+	reg_addr = port ? uphy1_base_addr : uphy0_base_addr;
+	val = readl(reg_addr + DISC_LEVEL_OFFSET);
+	val = (val & ~0x1F) | disc_level;
+	writel(val, reg_addr + DISC_LEVEL_OFFSET);
+
+	return 0;
+}
+
+/*
+ * return: 0 = device, 1 = host
+ */
+static inline int get_uphy_owner(int port)
+{
+	void __iomem *reg_addr = (void __iomem *)B_SYSTEM_BASE;
+	u32 val;
+
+	val = readl(reg_addr + USBC_CTL_OFFSET);
+
+	return (val & (1 << (port * 8 + 5))) ? 1 : 0;
+}
+
+static inline void reset_uphy(int port){
+	void __iomem *reg_addr = (void __iomem *)B_SYSTEM_BASE;
+
+	writel(RF_MASK_V_SET(1 << (13 + port)), reg_addr + USB_RESET_OFFSET);
+	writel(RF_MASK_V_CLR(1 << (13 + port)), reg_addr + USB_RESET_OFFSET);
+	writel(RF_MASK_V_SET(1 << (10 + port)), reg_addr + USB_RESET_OFFSET);
+	writel(RF_MASK_V_CLR(1 << (10 + port)), reg_addr + USB_RESET_OFFSET);
+}
+
+static inline void reinit_uphy(int port)
+{
+	void __iomem *reg_addr;
+	u32 val;
+
+	reg_addr = port ? uphy1_base_addr : uphy0_base_addr;
+
+	val = readl(reg_addr + ECO_PATH_OFFSET);
+	val &= ~(ECO_PATH_SET);
+	writel(val, reg_addr + ECO_PATH_OFFSET);
+	val = readl(reg_addr + POWER_SAVING_OFFSET);
+	val &= ~(POWER_SAVING_SET);
+	writel(val, reg_addr + POWER_SAVING_OFFSET);
+
+#ifdef CONFIG_USB_BC
+	switch (bc_switch & GET_BC_MODE) {
+	case CDP_MODE_VALUE:
+		writel(cdp_cfg16_value, reg_addr + CDP_REG_OFFSET);
+		writel(cdp_cfg17_value, reg_addr + DCP_REG_OFFSET);
+		break;
+	case DCP_MODE_VALUE:
+		writel(dcp_cfg16_value, reg_addr + CDP_REG_OFFSET);
+		writel(dcp_cfg17_value, reg_addr + DCP_REG_OFFSET);
+		break;
+	case SDP_MODE_VALUE:
+		writel(sdp_cfg16_value, reg_addr + CDP_REG_OFFSET);
+		writel(sdp_cfg17_value, reg_addr + DCP_REG_OFFSET);
+		break;
+	default:
+		break;
+	}
+#endif
+}
+
+#endif	/* __SP_USB_H */
--- a/include/linux/usb.h	2018-11-23 10:16:16.365794925 +0300
+++ a/include/linux/usb.h	2018-11-23 10:31:03.822049565 +0300
@@ -22,6 +22,10 @@
 #include <linux/mutex.h>	/* for struct mutex */
 #include <linux/pm_runtime.h>	/* for runtime PM */
 
+
+/*#define CONFIG_RETRY_TIMES*/
+
+
 struct usb_device;
 struct usb_driver;
 struct wusb_dev;
@@ -688,6 +692,11 @@
 	struct usb3_lpm_parameters u1_params;
 	struct usb3_lpm_parameters u2_params;
 	unsigned lpm_disable_count;
+#ifdef	CONFIG_RETRY_TIMES
+	int reset_count;
+	struct timespec t_prev;
+#endif
+	struct urb* current_urb;
 };
 #define	to_usb_device(d) container_of(d, struct usb_device, dev)
 
@@ -1559,6 +1568,7 @@
 	usb_complete_t complete;	/* (in) completion routine */
 	struct usb_iso_packet_descriptor iso_frame_desc[0];
 					/* (in) ISO ONLY */
+	u8 uphy_stuck_flag;
 };
 
 /* ----------------------------------------------------------------------- */
--- a/include/uapi/asm-generic/errno.h	2018-11-23 10:16:19.363616836 +0300
+++ a/include/uapi/asm-generic/errno.h	2018-11-23 10:31:03.824049446 +0300
@@ -119,4 +119,6 @@
 
 #define EHWPOISON	133	/* Memory page has hardware error */
 
+#define ENOTCONN_IRQ    134
+
 #endif
--- a/include/uapi/linux/usb/ch9.h	2018-11-23 10:16:19.386615469 +0300
+++ a/include/uapi/linux/usb/ch9.h	2018-11-23 10:31:03.822049565 +0300
@@ -324,6 +324,7 @@
 #define USB_CLASS_MISC			0xef
 #define USB_CLASS_APP_SPEC		0xfe
 #define USB_CLASS_VENDOR_SPEC		0xff
+#define USB_CLASS_DEVICE_NOT_SUPPORT	0x1f
 
 #define USB_SUBCLASS_VENDOR_SPEC	0xff
 
